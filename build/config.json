{"JBlog":{"path":"/blog","title":"blog","children":[{"path":"/blog/CSS层叠样式表","title":"CSS层叠样式表","children":[{"path":"/blog/CSS层叠样式表/flex.md","title":"flex","text":"# 容器属性(父元素)\n\n## flex-direction\n\n定义 flex 布局的主轴方向(默认 row)\n\n```css\n.container {\n  flex-direction: row | row-reverse | column | column-reverse;\n}\n```\n\n## flex-wrap\n\n默认情况下，flex 布局容器会把子元素排在同一行，设置 flex-wrap 可以决定是否允许溢出换行。\n\n```css\n.container {\n  flex-wrap: nowrap | wrap | wrap-reverse;\n}\n```\n\n## justify-content\n\n定义子元素沿主轴方向的对齐方式\n\n```css\n.container {\n  justify-content: flex-start | flex-end | center | space-between | space-around;\n}\n```\n\n#### flex-start\n\n默认值，贴主轴起点。\n\n#### flex-end\n\n贴主轴终点。\n\n#### center\n\n沿主轴方向居中。\n\n#### space-between\n\n贴主轴两端，第一个子元素在主轴起点，最后一个子元素在主轴终点。\n\n#### space-around\n\n沿主轴子元素之间均匀分布。\n\n> 要注意的是子元素看起来间隙是不均匀的，第一个子元素和最后一个子元素离父元素的边缘有一个单位的间隙，但两个子元素之间有两个单位的间隙，因为每个子元素的两侧都有一个单位的间隙。\n\n## align-items\n\n定义了子元素在交叉轴方向的对齐方向\n\n```css\n.container {\n  align-items: flex-start | flex-end | center | baseline | stretch;\n}\n```\n\n## align-content\n\n> 类似于 justify-content\n\n> 当只有一行的时候，该属性并不起作用。\n\n```css\n.container {\n  align-content: flex-start | flex-end | center | space-between | space-around |\n    stretch;\n}\n```\n\n# 子元素属性\n\n## order\n\n默认情况下，子元素按照代码书写的先后顺序布局，但 order 属性可以更改子元素排列顺序。\n\n```css\n.item {\n  order: 0;\n}\n```\n\n## flex-grow\n\n决定在空间允许的情况下，子元素如何按照比例分配可用剩余空间。\n\n如果设定为 1，则父元素中的剩余空间会分给子元素。\n\n如果设定为 2，则在分配剩余空间时该子元素将获得其他元素二倍的空间。\n\n> 默认值为 0，即使有剩余空间，子元素也不会放大。\n\n```css\n.item {\n  flex-grow: 1;\n}\n```\n\n## flex-shrink\n\n当空间不足时子元素的缩小比例。\n\n## align-self\n\n> 可以覆盖父元素中 align-items 所设置的对齐方式\n\n```css\n.item {\n  align-self: auto | flex-start | flex-end | center | baseline | stretch;\n}\n```\n\n> float,clear 和 vertical-align 对 flex 子元素无效。\n"},{"path":"/blog/CSS层叠样式表/三角形.md","title":"三角形","text":"当元素宽高为 0 时，上下左右边框就会变成三角形\n\n分 3 种情况：\n\n1.  只设置两个边框时，会出现两个对角直角三角形\n2.  设置三个边框时，对称的两个会变成对角直角三角\n3.  设置四个边框时，是四个对心三角形\n\n向上的等腰三角形\n\n```css\n.triangle {\n  width: 0;\n  height: 0;\n  /* transparent为透明色彩，左右透明，下面部分就是朝上的三角形 */\n  border-left: 50px solid transparent;\n  border-right: 50px solid transparent;\n  border-bottom: 50px solid aqua;\n}\n```\n\n四个对心三角形\n\n```css\n.triangle0 {\n  width: 0;\n  height: 0;\n  border-left: 50px solid #ffae00;\n  border-right: 50px solid #ff00d4;\n  border-top: 50px solid #00ffff;\n  border-bottom: 50px solid #ff0062;\n}\n```\n\n左上角三角形\n\n```css\n.triangle1 {\n  width: 0;\n  height: 0;\n  border-right: 50px solid transparent;\n  border-top: 50px solid aqua;\n}\n```\n"},{"path":"/blog/CSS层叠样式表/垂直居中.md","title":"垂直居中","text":"## table + vertical-align\n\n> 基于基线(四线三行)\n\n```css\n.parent {\n  display: table;\n}\n\n.child {\n  display: table-cell;\n  vertical-align: middle;\n}\n```\n\n## transform\n\n```css\n.parent {\n  position: relative;\n}\n\n.child {\n  position: absolute;\n  top: 50%; /* absolute定位参照物是父容器 */\n  transform: translateY(-50%); /*translate的参照物是自身 */\n}\n```\n\n> 如果子元素宽度知道，也可以把 translateY 换成 margin-top 负边距(偏移自身一半)\n\n## align-items:center\n\nflex 容器\n\n> 不兼容 IE10 以下\n\n```css\n.parent {\n  display: flex;\n  align-items: center;\n}\n\n/*或者*/\n.child {\n  align-self: center;\n}\n```\n\n## line-height\n\n子元素行高设置为父元素高度\n\n```css\n.parent {\n  height: 100px;\n}\n\n.child {\n  line-height: 100px;\n}\n```\n"},{"path":"/blog/CSS层叠样式表/水平垂直居中.md","title":"水平垂直居中","text":"## text-align + (table + vertical-align)\n\n```css\n.parent {\n  text-align: center;\n  display: table;\n}\n\n.child {\n  display: table-cell;\n  vertical-align: middle;\n  /* 文本恢复左对齐 */\n  text-align: left;\n}\n```\n\n## transform\n\n```css\n.parent {\n  position: relative;\n}\n\n.child {\n  position: absolute;\n  /*absolute定位参照物是父容器*/\n  left: 50%;\n  top: 50%;\n  /*translate的参照物是自身*/\n  transform: translate(-50%, -50%);\n}\n```\n\n> 如果子元素宽度知道，也可以把 translate 换成 (margin-left + margin-top) 负边距(偏移自身一半)\n\n## justify-content + align-items\n\nflex 容器\n\n> 不兼容 IE10 以下\n\n```css\n.parent {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n```\n"},{"path":"/blog/CSS层叠样式表/水平居中.md","title":"水平居中","text":"## text-align: center\n\n在块级父容器中，让行内元素(或者类行内元素)居中，只需使用 text-align: center，\n\n> 类行内元素: inline/inline-block/inline-table/inline/flex\n\n```css\n.parent {\n  text-align: center;\n}\n\n.child {\n  display: inline-block;\n  /* 文本会继承child类的居中，需要取消文本居中 */\n  text-align: left;\n}\n```\n\n当子节点中出现多个行内元素的时候，每个子节点之间会有缝隙，这不是 bug，因为文本文字之间就需要缝隙。\n\n#### 去除办法\n\n1. 在父元素(容器)中设置 font-size: 0 可以去除缝隙\n\n```css\n.parent {\n  font-size: 0;\n}\n.chilc {\n  /* 注意子元素恢复 */\n  font-size: 16px;\n}\n```\n\n2. 使用 letter-spacing 或者 word-spacing\n\n## margin:0 auto\n\n子元素需要为块级元素，但需要设置 width。\n\n> table 元素 width 由内容决定\n\n```css\n.child {\n  display: table;\n  margin: 0 auto;\n}\n```\n\n## transform\n\n子绝父相\n\n> absolute 元素 width 由内容决定\n\n```css\n.parent {\n  position: relative;\n}\n\n.child {\n  position: absolute;\n  left: 50%; /*absolute定位参照物是父容器*/\n  transform: translateX(-50%); /*百分比的参照物是自身*/\n}\n```\n\n> 如果子元素宽度知道，也可以把 translateX 换成 margin-left 负边距(偏移自身一半)\n\n## justify-content:center;\n\nflex 容器\n\n> 不兼容 IE10 以下\n\n```css\n.parent {\n  display: flex;\n  justify-content: center;\n}\n```\n"},{"path":"/blog/CSS层叠样式表/盒子模型.md","title":"盒子模型","text":"# 标准(w3c)盒模型\n\nwidth = content (元素宽度 = 内容宽度)\n\n> 以 content 为边界\n\n> 内容宽度不变，向外扩展\n\n```css\n.contentBox {\n  background-color: aquamarine;\n  width: 100px;\n  height: 100px;\n  box-sizing: content-box;\n  border: 10px solid blue;\n  padding: 20px;\n  margin: 20px;\n}\n```\n\n所以.contentBox 元素的宽度为 100px\n\n# 怪异(IE)盒模型\n\nwidth = content + padding + border (元素宽度 = 内容宽度 + 内边距宽度 + 边框宽)\n\n> 以 border 为边界\n\n> 设置 padding 和 border 会挤压内容\n\n```css\n.borderBox {\n  background-color: yellowgreen;\n  width: 100px;\n  height: 100px;\n  box-sizing: border-box;\n  border: 10px solid blue;\n  padding: 20px;\n  margin: 20px;\n}\n```\n\n所以.borderBox 元素的宽度为 100px + 20px + 10px = 130px\n"}]},{"path":"/blog/Git版本控制","title":"Git版本控制","children":[{"path":"/blog/Git版本控制/branch.md","title":"branch","text":"如果不是fork流，那就是几个人共用一个local repository。\n\n然后不同的人在不同的branch上commit，最后合并到master分支。\n出现冲突使用merge或者rebase。\n\nmerge即字面意思合并，rebase就是重置初始提交。merge会保留被merge branch上的commits，而rebase不会。rebase就是将commits取消掉然后合并成一个commit。\n\n### rebase\n\n例如\n\n```bash\ngit rebase master\n```\n\n这行命令会将当前分支的commits取消掉变成patches，然后更新为master分支，最后再把patches应用过来，生成一个commit。\n\n### cherry-pick\n\n复制指定commit到当前branch\n\n```bash\ngit cherry-pick <hash>\n\ngit cherry-pick <hash1>..<hash2>\n```\n\n"},{"path":"/blog/Git版本控制/checkout.md","title":"checkout","text":"checkout是git最常用最重要的命令之一。\n\n### 切换分支\n\n```bash\ngit checkout <branch-name>\n```\n\n> 切换到一个新分支 git checkout -b <branch-name>\n\n### 文件回退\n\n> git log得到hash提交历史\n\n```bash\ngit checkout <hash> <file>\n```\n\n> 放弃未提交的所有修改 git checkout .\n"},{"path":"/blog/Git版本控制/github与git.md","title":"github与git","text":"1. github即remote repository，是local repository的一个远程镜像。\n2. 本地git提交后，local repository会超前于remote repository，需要执行git push更新远程仓库。\n3. 如果是多人开发，远程仓库很有可能超前于本地分支，导致无法push本地到远程。需要先执行git pull，将远程的新内容更新到本地，再push。\n> 如果有冲突需要取舍。\n\n4. github上的贡献方式一般为 fork -> clone -> commit -> test -> push -> open pull request.\n\n> 一般的就这样可以了。\n"},{"path":"/blog/Git版本控制/log.md","title":"log","text":"```bash\ngit log\n\ngit reflog\n```\nreflog可以看到被reset的commit。"}]},{"path":"/blog/HTTP协议","title":"HTTP协议","children":[{"path":"/blog/HTTP协议/HTTP跨域之OPTIONS请求.md","title":"HTTP跨域之OPTIONS请求","text":"前几天在写一个前后端交互的项目，遇到个问题：Header 无法发送 Authorization 字段。\n\n我明明用 RESTClient 发 POST 测试得好好的。。(后来知道 OPTIONS 请求是浏览器自动发的，RESTClient 要手动发)\n\n后端 API 鉴权采用类 jwt 的方式，为什么说类 jwt 呢，因为我不是按标准格式编码的，直接利用 JSON.stringify 来序列化 json 数据（当然 token 属性我已经私钥加密了）。前端从 localStorage 里拿到了 jwt，放请求头 Authorization 字段里，firefox 抓包发现请求头没带上 jwt，请求变成了 OPTIONS 请求。\n\n1. 什么是 OPTIONS 请求？\n\nOPTIONS 请求又称预检请求，就是在正式请求服务端 API 前的一个\"打招呼、询问\"。\n\n2. 为什么需要 OPTIONS 请求？\n\n前端带了特殊的请求头去访问后端，就会触发 OPTIONS 请求，会先询问后端是否支持该请求头字段(对应响应头 Access-Control-Allow-Headers)，以及后端是否支持该请求方法(对应响应头 Access-Control-Allow-Methods)。\n\n3. 那这样每次不得发两次请求？\n\nOPTIONS 请求可以被缓存(对应响应头 Access-Control-Max-Age)，在缓存过期前，不会再发 OPTIONS 请求询问。\n"},{"path":"/blog/HTTP协议/基本概念.md","title":"基本概念","text":"# 概念\n\nHTTP 是面向事务的应用层协议，全称为 HyperText Transfer Protocol，即为超文本传输协议，是互联网应用最为广泛的一种网络协议，所有的 www 文件都必须遵守这个标准。\n\n# 特性\n\nHTTP 是无连接无状态的\nHTTP 一般构建于 TCP/IP 协议(传输层)之上，默认端口号是 80\nHTTP 可以分为两个部分，即请求和响应。\n\n# 请求\n\n由 3 个部分构成，分别是：状态行，请求头(Request Header)，请求正文。\n\nHTTP 定义了在与服务器交互的不同方式，最常用的方法有 4 种，分别是 GET，POST，PUT， DELETE。\n\n> URL 全称为资源描述符，可以这么认为：一个 URL 地址，对应着一个网络上的资源，而 HTTP 中的 GET，POST，PUT，DELETE 就对应着对这个资源的查询，修改，增添，删除 4 个操作。\n\n### GET 请求和 POST 请求的区别\n\n1. 请求参数位置不同，GET 请求对应的参数放在 URL 中，而 POST 请求对应的参数放在 HTTP 请求主体中。\n\n> 但是这只是一种约定，GET 请求中出现 Body 也是被允许的。\n\n2. 虽然 HTTP 协议的 RFC 规范 并没有详细规定 URL 的最大字符长度限制，但实际上，在浏览器或者服务器中总会存在限制的，这就导致了 GET 请求中参数数量是有限的。\n\n3. 处于安全考虑，在一些涉及安全的请求比如：登录请求需要用 POST 提交表单，而 GET 请求一般用来获取静态资源。\n\n4. GET、POST 请求都可以被缓存，但 GET 请求可以被收藏为书签， POST 不可以。\n\n5. GET 请求的参数在 URL 中，因此绝不能用 GET 请求传输敏感数据。POST 请求数据则写在 HTTP 的请求头中，安全性略高于 GET 请求。\n\n> 只是略高\n\n# 响应\n\n由三个部分构成。分别是：状态行，响应头(Response Header)，响应正文\n\n#### HTTP 状态码\n\n1xx : 表示请求已经接受了，继续处理。\n2xx : 表示请求已经处理掉了。\n3xx : 重定向。\n4xx : 一般表示客户端有错误，请求无法实现。\n5xx : 一般为服务器端的错误。\n\n常见的状态码：\n200 OK 客户端请求成功。\n301 Moved Permanently 请求永久重定向。\n302 Moved Temporarily 请求临时重定向。\n304 Not Modified 文件未修改，可以直接使用缓存的文件。\n400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。\n401 Unauthorized 请求未经授权，无法访问。\n403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因。\n404 Not Found 请求的资源不存在，比如输入了错误的 URL。500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。\n503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。\n\n# OSI 7层模型\n\n1. 应用层：与其它计算机进行通讯的一个应用，例如HTTP、FTP、DNS等。\n2. 表示层：定义数据格式及加密。例如二进制或ASCII格式。\n3. 会话层：定义了如何开始、控制和结束一个会话。例如SQL。\n4. 传输层：对输入进行复用、排序。例如TCP、UDP。\n5. 网络层：对端到端的包传输进行定义，标识所有结点的逻辑地址。例如IP。\n6. 数据链路层：定义了在单个链路上如何传输数据，与被讨论的介质有关。\n7. 物理层：有关传输介质的特性。"}]},{"path":"/blog/Javascript基础","title":"Javascript基础","children":[{"path":"/blog/Javascript基础/HTML特殊字符转义.md","title":"HTML特殊字符转义","text":"# 利用正则转义\n\n正则对象(全局 g)的 exec 方法可用来迭代搜索字符串，并把匹配到的位置记录到 lastIndex 属性\n\n1. 利用 split 把字符串拆解成字符序列\n2. 根据匹配到的 index 修改序列对应元素\n3. 利用 join 反序列为字符串\n\n```js\nconst element = `<script>hello</script>`\n\nconst transform0 = element => {\n  // 得到字符序列\n  const words = element.split(\"\")\n  const reg = /<|>/g\n  let res = reg.exec(element)\n  while (res) {\n    // 匹配到的位置会被记录到lastIndex属性，由于是从1开始，所以要-1\n    const index = reg.lastIndex - 1\n    // 修改序列对应元素\n    words.splice(index, 1, element.charCodeAt(index))\n    // 迭代搜索下一个位置\n    res = reg.exec(element)\n  }\n  return words.join(\"\")\n}\n\nconsole.log(transform0(element))\n```\n\n# 利用 dom innerText 转义\n\n```js\n// innerText输入,innerHTML输出\nconst transform1 = element => {\n  const dom = document.createElement(\"span\")\n  dom.innerText = element\n  return dom.innerHTML\n}\n\nconsole.log(transform1(element))\n```\n"},{"path":"/blog/Javascript基础/JSONP跨域.md","title":"JSONP跨域","text":"```js\n/**\n * @param {string} url\n */\nconst jsonp = url =>\n  new Promise((resolve, reject) => {\n    // 创建标签\n    const script = document.createElement(\"script\")\n    // 设置回调名\n    const callbackId = `jsonp_${Date.now()}`\n    // 拼接请求的url，异步请求在这里，判断是否已经有参数\n    script.src = url.includes(\"?\")\n      ? `${url}&callback=${callbackId}`\n      : `${url}?callback=${callbackId}`\n    // 设置读取返回结果的回调函数, 必须设置在window上\n    window[callbackId] = result => {\n      // 释放内存\n      delete window[callbackId]\n      document.body.removeChild(script)\n      // 结果\n      result ? resolve(result) : reject(\"404\")\n    }\n    script.addEventListener(\"error\", () => reject(\"script create fail\"))\n    // 发出请求\n    document.body.appendChild(script)\n  })\n\njsonp(\"http://localhost:3005/jsonp?name=saber2pr&age=21\").then(console.log)\n```\n"},{"path":"/blog/Javascript基础/bind call apply和原理.md","title":"bind call apply和原理","text":"# 作用域\n\n```js\n// 对象作用域\nconst objContext = {\n  value: 1,\n  getValue(v1, v2) {\n    if (v1 && v2) return v1 + v2 + this.value\n    return this.value\n  }\n}\n// 获取对象作用域内的函数\nconst method = objContext.getValue\n\n// 函数作用域下（父作用域不能访问子作用域！）\nconsole.log(method()) // undefined\n\n// 手动转移（绑定、指定）执行上下文到objContext上下文中\nconsole.log(method.apply(objContext)) // 1\nconsole.log(method.call(objContext)) // 1\nconsole.log(method.bind(objContext)()) // 1\n```\n\n# 实现 call\n\n```js\nFunction.prototype.myCall = function(thisArg, ...argArray) {\n  // Symbol是es6增加的第六个基本类型，对于对象属性就是uuid\n  const id = Symbol()\n  // 获取要指定的上下文\n  context = thisArg || window\n  // 将当前函数链接到指定的上下文中\n  context[id] = this\n  // 当前函数在context上下文中执行\n  const result = context[id](...argArray)\n  // 移除context中已执行的当前函数\n  delete context[id]\n  // 返回结果\n  return result\n}\n```\n\n# 实现 bind\n\n```js\nFunction.prototype.myBind = function(thisArg, ...argArray) {\n  return () => this.myCall(thisArg, ...argArray)\n}\n```\n\n# 实现 apply\n\n```js\nFunction.prototype.myApply = function(thisArg, argArray = []) {\n  return this.myCall(thisArg, ...argArray)\n}\n```\n\n```js\nconsole.log(Math.max.myCall(null, ...[1, 2, 3])) // 3\n\nconsole.log(method.myApply(objContext, [1, 2])) // 4\nconsole.log(method.myCall(objContext, 1, 2)) // 4\nconsole.log(method.myBind(objContext, 1, 2)()) // 4\n\nconsole.log(objContext)\n```\n\n# 总结一下\n\n核心就是 call 的实现。其实 apply 和 bind 实现任意一个就好了。\nmethod.call(thisArg, ...items)\n一个函数内部如果不读取上下文的话，call 不 call 没区别。\n原因就是 js 函数执行的上下文和声明时所处的上下文并不总是相同，也就是 this 是个动态变化的值\n所以为了避免函数内调用 this 时发生错误，一般用 call 绑定到声明时所处的上下文\n所以 call 需要做的：\n\n1.  由于在 call 函数内，this 本身就是函数，所以直接把 this 赋给 context 的属性就完成了绑定\n2.  在 context 内声明一个新的函数值指向 this，然后用对象作用域调用这个新的函数\n    其实就是利用了`obj[method]`这种方法实现的绑定，给 obj 内新建一个函数指向当前，然后执行，obj 作为上下文去调用自己的属性\n"},{"path":"/blog/Javascript基础/es6","title":"es6","children":[{"path":"/blog/Javascript基础/es6/promise原理.md","title":"promise原理","text":"promise本质是Monad，用于在纯函数中处理副作用。\n\n> 在Node.js上常用来处理callback-hell。其实是利用了promise暴露的executor。\n\nMonad依赖系统实现的微任务队列，用于在纯函数执行后执行副作用。\n\n# 微任务\n\n```ts\nexport interface Microtask extends MutationCallback {}\n\nexport function microtask(task: Microtask) {\n  if (\n    typeof process !== 'undefined' &&\n    typeof process.nextTick === 'function'\n  ) {\n    process.nextTick(task)\n  } else {\n    const observer = new MutationObserver(task)\n    const element = document.createTextNode('')\n    observer.observe(element, {\n      characterData: true\n    })\n    element.data = ''\n  }\n}\n```\n\n> 兼容Node.js和Browser环境\n\n# Promise实现\n\n### 类型定义\n\n```ts\nexport type Resolve<T> = (value?: T) => any\nexport type Reject<T> = (reason?: T) => any\n\nexport type Executor<T> = (resolve: Resolve<T>, reject: Reject<T>) => void\nexport type Catch<T> = (onRejected: Reject<T>) => any\n\nexport type Then<T> = (\n  onfulfilled?: Resolve<T>,\n  onrejected?: Reject<T>\n) => Promise<T>\n\nexport type Status = 'pending' | 'resolved' | 'rejected'\n```\n\n### 实现\n\n```ts\nexport class Promise<T> {\n  public constructor(executor: Executor<T>) {\n    try {\n      // 构造函数同步执行\n      executor(this.resolve, this.reject)\n    } catch (error) {\n      this.reject(error)\n    }\n  }\n  private status: Status = 'pending'\n  private data = undefined\n  private onResolvedCallback: Array<Resolve<T>> = []\n  private onRejectedCallback: Array<Reject<T>> = []\n\n  // microtask中处理then注册的Callbacks\n  private resolve: Resolve<T> = value => microtask(() => {\n    if (this.status === 'pending') {\n      this.status = 'resolved'\n      this.data = value\n      this.onResolvedCallback.forEach(resolve => resolve(value))\n    }\n  })\n  private reject: Reject<T> = reason => microtask(() => {\n    if (this.status === 'pending') {\n      this.status = 'rejected'\n      this.data = reason\n      this.onRejectedCallback.forEach(reject => reject(reason))\n    }\n  })\n\n  // 下文实现then\n}\n\nexport namespace Promise {\n  export function resolve<T>(value?: T) {\n    return new Promise<T>(resolve => resolve(value))\n  }\n\n  export function reject<T>(reason?: T) {\n    return new Promise<T>((_, reject) => reject(reason))\n  }\n}\n```\n\n### then实现\n\n将普通值类型提升为Promise类型\n\nes6实现中，将>>=操作和lift操作在if中分情况合并了。\n\n```ts\nexport class Promise<T> {\n  public then: Then<T> = (\n    onfulfilled = value => value,\n    onrejected = reason => {\n      throw reason\n    }\n  ) => {\n    // then返回新的Promise\n    return new Promise((resolve, reject) => {\n      if (this.status === 'resolved') {\n        try {\n          // 执行onfulfilled，然后将普通值提升为Promise类型\n          // 下文都是这个步骤\n          const p = onfulfilled(this.data)\n          if (p instanceof Promise) {\n            p.then(resolve, reject)\n          } else {\n            // 提升为Promise类型\n            resolve(p)\n          }\n        } catch (error) {\n          reject(error)\n        }\n      }\n\n      if (this.status === 'rejected') {\n        try {\n          const p = onrejected(this.data)\n          if (p instanceof Promise) {\n            p.then(resolve, reject)\n          } else {\n            reject(this.data)\n          }\n        } catch (error) {\n          reject(error)\n        }\n      }\n\n      if (this.status === 'pending') {\n        this.onResolvedCallback.push(() => {\n          try {\n            const p = onfulfilled(this.data)\n            if (p instanceof Promise) {\n              p.then(resolve, reject)\n            } else {\n              resolve(p)\n            }\n          } catch (error) {\n            reject(error)\n          }\n        })\n\n        this.onRejectedCallback.push(() => {\n          try {\n            const p = onrejected(this.data)\n            if (p instanceof Promise) {\n              p.then(resolve, reject)\n            } else {\n              reject(this.data)\n            }\n          } catch (error) {\n            reject(error)\n          }\n        })\n      }\n    })\n  }\n\n  // 注册一个onRejected到callbacks\n  public catch = (onRejected: Reject<T>) => {\n    return this.then(null, onRejected)\n  }\n}\n```\n\n至于async/await那就真的是语法糖了。就是haskell中的do block。\n\nes6中可以利用yield和promise实现。"}]},{"path":"/blog/Javascript基础/es7","title":"es7","children":[{"path":"/blog/Javascript基础/es7/async & await原理.md","title":"async & await原理","text":"# es5 生成器 generator\n\n> yield 会保存执行位置，外部调用 next 回到 yield 处往下执行\n\n```js\nfunction* generator() {\n  const next1 = yield 1\n  console.log(next1)\n\n  const next2 = yield 2\n  console.log(next2)\n\n  const next3 = yield 3\n  console.log(next3)\n}\nconst iterator = generator()\nconsole.log(iterator.next()) // 第一次调用返回第一次yield的值，后续每调用一次向后迭代一次\nconsole.log(iterator.next())\nconsole.log(iterator.next())\nconsole.log(iterator.next()) // done true 意思是后面没有yield了，迭代结束\n// next函数可接受一个值，会覆盖生成器中yield左边的值\n```\n\n# async 实现\n\n```js\nfunction async(generator) {\n  // 调用生成器生成迭代器\n  const iterator = generator()\n\n  return function next(onfulfilled) {\n    // 迭代一次\n    const result = iterator.next(onfulfilled)\n    // 如果yield完成，则返回\n    if (result.done) return\n    // 注册下一次迭代到promise回调中\n    // 如果yield的值不是promise，则包装为Promise.resolve\n    result.value.then\n      ? result.value.then(onfulfilled => next(onfulfilled))\n      : Promise.resolve(result.value).then(onfulfilled => next(onfulfilled))\n  }\n}\n\nconst delay = (time, value) =>\n  new Promise(res => setTimeout(() => res(value), time))\n\nasync(function*() {\n  const first = yield 1\n  console.log(first)\n\n  const second = yield delay(1000, 2) // 阻塞2秒\n  console.log(second)\n\n  const third = yield 3\n  console.log(third)\n})()\n```\n"}]},{"path":"/blog/Javascript基础/fiber遍历.md","title":"fiber遍历","text":"# 虚拟 dom 构造函数\n\n```js\nfunction VDom(props, children) {\n  this.props = props\n  this.children = children\n}\n```\n\n# Fiber 构造函数\n\n```js\nfunction Fiber(instance, parent, child, sibling) {\n  this.instance = instance\n  this.parent = parent\n  this.child = child\n  this.sibling = sibling\n}\n```\n\n# Link\n\n> 链接 fiber 实例 vdom 的 children 为单向链表，并返回第一个子节点，若 fiber 实例 vdom 没有 children，则返回 null\n\n```js\nfunction link(fiber) {\n  if (!fiber.instance.children) return null\n  return (fiber.child = fiber.instance.children.reduceRight(\n    (sibling, current) => new Fiber(current, fiber, null, sibling),\n    null\n  ))\n}\n```\n\n# Fiber 迭代算法\n\n> 深度优先遍历\n\n```js\nfunction next(fiber) {\n  const child = link(fiber)\n  if (child) return child\n  let current = fiber\n  while (current) {\n    if (current.sibling) return current.sibling\n    current = current.parent\n  }\n}\n/**\n * 循环迭代\n * @param {Fiber} fiber\n * @param {(fiber:Fiber) => void} callback\n */\nfunction loop(fiber, callback) {\n  let current = fiber\n  while (current) {\n    callback(current)\n    current = next(current)\n  }\n}\n```\n\n```js\n// 虚拟dom树\nconst root = new VDom({ value: 1 }, [\n  new VDom({ value: 2 }, [new VDom({ value: 4 })]),\n  new VDom({ value: 3 }, [new VDom({ value: 5 })])\n])\n\n// 虚拟dom树转为fiber链表，开始遍历\nloop(new Fiber(root), fiber => console.log(fiber.instance.props))\n\nlet __current = new Fiber(root)\n// 使用浏览器调度API-requestIdleCallback\nfunction work(dline) {\n  console.log(__current.instance.props, dline.timeRemaining())\n  __current = next(__current)\n  if (__current) requestIdleCallback(work)\n}\n\nrequestIdleCallback(work)\n```\n"},{"path":"/blog/Javascript基础/vdom渲染.md","title":"vdom渲染","text":"# 虚拟 dom 构造函数\n\n```js\nfunction VDom(type, props, children) {\n  this.type = type\n  this.props = props\n  this.children = children\n}\n\nfunction h(type, props, children = []) {\n  return new VDom(type, props, children)\n}\n\nconst tree = h(\"div\", {}, [h(\"p\", { innerText: \"hello\" })])\n```\n\n# 渲染函数\n\n```js\nfunction renderDom(vdom, container) {\n  const dom = document.createElement(vdom.type)\n  Object.entries(vdom.props).forEach(([k, v]) => (dom[k] = v))\n  container.append(dom)\n  vdom.children && vdom.children.forEach(child => renderDom(child, dom))\n}\n\nrenderDom(tree, document.getElementById(\"root\"))\n```\n\n# 迭代器遍历\n\n```js\nfunction* toIterable(vdom, stack = [vdom]) {\n  while (stack.length) {\n    const node = stack.pop()\n    node.children && stack.push(...node.children)\n    yield node\n  }\n}\nconsole.log(Array.from(toIterable(tree)))\n```\n"},{"path":"/blog/Javascript基础/事件捕获冒泡.md","title":"事件捕获冒泡","text":"```javascript\n/**\n * lisen\n * @param {string[]} ids\n * @param {boolean} isCatch\n */\nconst lisen = (ids, isCatch) =>\n  ids.forEach(id =>\n    document\n      .getElementById(id)\n      .addEventListener(\"click\", () => alert(id), isCatch)\n  )\n\n// BubbleEvent\nlisen([\"root_b\", \"first_b\", \"second_b\", \"target_b\"], false)\n\n// CatchEvent\nlisen([\"root_c\", \"first_c\", \"second_c\", \"target_c\"], true)\n```\n\n关于 addEventListener 的第三个参数 options\n如果是 boolean 值，则 false 为冒泡事件，true 为捕获事件，默认为冒泡\n如果是一个对象，即一个指定有关 listener 属性的可选参数对象。可用的选项如下：\n\n1. capture: Boolean，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发。\n\n2. once: Boolean，表示 listener 在添加之后最多只调用一次。如果是 true， listener 会在其被调用之后自动移除。\n\n3. passive: Boolean，设置为 true 时，表示 listener 永远不会调用 preventDefault()。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。如果一个事件不需要 preventDefault，直接设置 passive true 可以起到优化作用。\n"},{"path":"/blog/Javascript基础/作用域和闭包.md","title":"作用域和闭包","text":"```js\nif (1) {\n  // var变量声明预编译提升到上一层，或者说if没有块级\n  var val = 233\n}\n\ntry {\n  console.log(val) // 233\n} catch (error) {\n  console.error(error)\n}\n\nif (1) {\n  try {\n    console.log(_val) // 没有初始化，即暂定死区。改成var声明会输出undefined，var默认初始化为undefined\n  } catch (error) {\n    console.log(error)\n  }\n  // let块作用域\n  let _val = 344\n}\n\ntry {\n  console.log(_val) // _val is not defined，因为_val在块作用域内(子作用域)\n} catch (error) {\n  console.error(error)\n}\n\n// 函数作用域也是块级\nfunction Block() {\n  // 函数封闭作用域\n  var _val_0 = 344\n}\n\ntry {\n  console.log(_val_0) // _val_0 is not defined\n} catch (error) {\n  console.error(error)\n}\n\nconst People = (function() {\n  // iife闭包环境\n\n  // 被闭包的变量，所有实例共享\n  var _age = 21\n\n  function People(name) {\n    this.name = name\n  }\n\n  People.prototype.getAge = function() {\n    return _age\n  }\n\n  People.prototype.addAge = function() {\n    _age++\n  }\n\n  return People\n})()\n\nconst me = new People(\"saber2pr\")\nme.addAge()\nconsole.log(me.getAge()) // 22\n\nconst saber = new People(\"saber\")\nsaber.addAge()\nconsole.log(saber.getAge()) // 23\n```\n\njs 里存在 3 种作用域\n\n1. 全局作用域\n2. 函数作用域\n3. 对象作用域\n   每个作用域里的 var 声明都会提升到该作用域顶层\n   子作用域声明覆盖父作用域\n"},{"path":"/blog/Javascript基础/原型链.md","title":"原型链","text":"```js\n// 实例的构造函数\nfunction Cat() {}\n// 实例\nconst cat = new Cat()\n\n// 实例的原型就是构造函数的prototype\nconsole.log(cat.__proto__ === Cat.prototype)\n\n// 实例构造函数的原型就是构造函数的原型\nconsole.log(Cat.__proto__ === Function.prototype)\n\n// 构造函数的原型的构造函数就是自己\nconsole.log(Cat.prototype.constructor === Cat)\n\n// 构造函数的原型的原型就是Object构造函数的原型\nconsole.log(Function.prototype.__proto__ === Object.prototype)\nconsole.log(Array.prototype.__proto__ === Object.prototype)\nconsole.log(Date.prototype.__proto__ === Object.prototype)\nconsole.log(Error.prototype.__proto__ === Object.prototype)\n// 这些对象的构造函数就是Object\nconsole.log(JSON.__proto__ === Object.prototype)\nconsole.log(Reflect.__proto__ === Object.prototype)\n\n// 实例的原型的构造函数就是实例的构造函数\nconsole.log(Cat.prototype.constructor === Cat)\n\n// 实例原型的原型就是Object构造函数的prototype\nconsole.log(Cat.prototype.__proto__ === Object.prototype)\n\n// Object实例的原型的原型是null\nconsole.log(Object.prototype.__proto__ === null)\n\n// __proto__链：cat实例 -> Cat原型 -> Object原型 -> null\nconsole.log(cat.__proto__.__proto__.__proto__ === null)\n\n// Function和Object的关系\n// 所有的函数对象的原型都是Function的prototype，Object也是个函数对象\nconsole.log(Object.__proto__ === Function.prototype)\n// 那Function的原型是? [native code]\nconsole.log(Function.__proto__)\n// 应该是Function.prototype\nconsole.log(Function.__proto__ === Function.prototype)\n```\n\n## `__proto__` 的作用\n\n当读取实例属性时，先在实例身上找，找不到就去`__proto__`上找，`__proto__`就是一条连接实例和实例原型的链条，\n当然实例原型也有自己的原型。\n顺着`__proto__`一直向上找会找到 Object.prototype，再往上就是 null\n\n## prototype 的作用\n\n获得构造函数的原型，用于给原型添加方法和属性\n\n## constructor 的作用\n\n在 prototype 上有一个 constructor 属性，指向构造函数。\n即 constructor.prototype.constructor === constructor\n如果 prototype 被改变，则 constructor 指向也改变\n\n# 总结一下\n\n1. 构造函数和原型之间通过 constructor.prototype.constructor === constructor ，双向连接\n2. 实例通过`__proto__`一直向原型方向找（constructor.prototype），向上找到 Object.prototype，再上就是 null\n3. prototype 就是原型，`__proto__`就是原型链，`__proto__`把实例和一系列的 prototype 连起来\n4. 构造函数的 prototype 就是原型\n5. 实例的`__proto__`指向自己构造函数的 prototype，而自己构造函数的原型（包括所有函数的原型）都是 Function.prototype\n   (甚至 Function 自己的原型也指向 Function.prototype)\n6. 对象实例的原型最终指向 Object.prototype(再向上为 null)，函数的原型指向 Function.prototype\n"},{"path":"/blog/Javascript基础/双向绑定.md","title":"双向绑定","text":"## Object.defineProperty\n\n```js\n/**\n * bind\n * @param {object} target\n * @param {object} model\n * @param {object} map\n */\nconst bind = (target, model, map) =>\n  Object.keys(map || target).forEach(key =>\n    Object.defineProperty(target, key, {\n      set(value) {\n        const mkey = map ? map[key] : key\n        model[mkey] = value\n      },\n      get() {\n        const mkey = map ? map[key] : key\n        return model[mkey]\n      }\n    })\n  )\n\nwindow.__alternate = {}\nconst p = document.getElementById(\"p\")\n\nbind(__alternate, p, {\n  value: \"innerHTML\"\n})\n```\n\n## Proxy\n\n```js\n/**\n * bind\n * @param {object} model\n * @param {object} map\n */\nconst bind = (model, map) =>\n  new Proxy(map || model, {\n    get(_, key) {\n      const mkey = map ? map[key] : key\n      return Reflect.get(model, mkey)\n    },\n    set(_, key, value) {\n      const mkey = map ? map[key] : key\n      return Reflect.set(model, mkey, value)\n    }\n  })\n\nwindow.__alternate = bind(document.getElementById(\"p\"), {\n  value: \"innerHTML\"\n})\n```\n"},{"path":"/blog/Javascript基础/可迭代对象(iterable).md","title":"可迭代对象(iterable)","text":"# 可迭代对象(iterable)\n\n可迭代对象(iterable)就是部署有 Symbol.iterator 的对象\n\n使用 for-of 遍历时会自动获取迭代器的返回值\n\n```js\nconst obj = {\n  [Symbol.iterator]: function*() {\n    for (let i = 9; i > 0; i--) yield i\n  }\n}\n\nfor (let i of obj) {\n  console.log(i)\n}\n```\n\n# 判断一个对象是否是可遍历对象\n\n> 就是看有没有部署 Symbol.iterator 接口，该属性是 function 类型\n\n```js\nfunction isIterable(obj) {\n  return typeof obj[Symbol.iterator] === \"function\"\n}\n```\n\n# js 内置 iterable\n\nString、Array、Map、Set、arguments 和其他伪数组、generator\n\n> 注意 WeakMap 和 WeakSet 不是 iterable\n\n```js\nconsole.log(isIterable(\"\")) // true\nconsole.log(isIterable([])) // true\nconsole.log(isIterable(new Map())) // true\nconsole.log(isIterable(new WeakMap())) // false\nconsole.log(isIterable(new Set())) // true\nconsole.log(isIterable(new WeakSet())) // false\nconsole.log(isIterable(arguments)) // true\nconsole.log(isIterable(document.getElementsByTagName(\"script\"))) // true\nconsole.log(isIterable((function*() {})())) // true\n```\n"},{"path":"/blog/Javascript基础/封装一个ajax.md","title":"封装一个ajax","text":"```js\n/**\n * @param {string} url\n * @param {string} method\n * @param {object} params\n * @returns\n */\nfunction request(url, method = \"GET\", params = null) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest()\n    xhr.open(method, url)\n    xhr.addEventListener(\"readystatechange\", () => {\n      if (xhr.readyState === 4) {\n        if (xhr.status === 200) {\n          resolve(xhr.responseText)\n        } else {\n          reject({\n            code: xhr.status,\n            response: xhr.response\n          })\n        }\n      }\n    })\n    setTimeout(() => reject(\"timeout:1000\"), 1000)\n    xhr.send(JSON.stringify(params))\n  })\n}\n\nrequest(\"http://localhost:3005/user/?name=saber&age=21\").then(console.log)\nrequest(\"http://localhost:3005/user/\", \"POST\", {\n  name: \"saber\",\n  age: 233\n}).then(console.log)\n\nrequest(\"http://localhost:30051/user/?name=saber&age=21\").then(console.log)\nrequest(\"http://localhost:30051/user/\", \"POST\", {\n  name: \"saber\",\n  age: 233\n}).then(console.log)\n```\n\n# onreadystatechange\n\n每当 readyState 属性改变时，就会调用该函数\n\n### readyState\n\n0. 请求未初始化\n1. 服务器连接已建立\n2. 请求已接收\n3. 请求处理中\n4. 请求已完成，且响应已就绪\n\n### status http 状态码\n\n1xx: 请求正在处理\n2xx: 请求处理完毕\n3xx: 重定向\n4xx: 浏览器端（客户端）错误\n5xx: 服务器内部错误\n"},{"path":"/blog/Javascript基础/数组克隆&数组 ES6 API实现.md","title":"数组克隆&数组 ES6 API实现","text":"# 判断一个对象是不是数组\n\n```js\nconst isArray0 = obj => Array.isArray(obj)\nconst isArray1 = obj => Object.prototype.toString.call(obj) === \"[object Array]\"\nconsole.log(isArray0([]))\nconsole.log(\n  isArray0({\n    0: \"value\",\n    length: 1\n  })\n)\nconsole.log(isArray1([]))\nconsole.log(\n  isArray1({\n    0: \"value\",\n    length: 1\n  })\n)\nconsole.log(isArray0(arguments))\nconsole.log(isArray1(arguments))\nconsole.log(isArray0(document.getElementsByClassName(\"\")))\nconsole.log(isArray1(document.getElementsByClassName(\"\")))\nconsole.log(isArray0(document.getElementsByTagName(\"div\")))\nconsole.log(isArray1(document.getElementsByTagName(\"div\")))\nconsole.log(\n  Array.from({\n    0: \"value\",\n    length: 1\n  })\n)\nconsole.log(\n  isArray0(\n    Array.from({\n      0: \"value\",\n      length: 1\n    })\n  )\n)\nconsole.log(\n  isArray1(\n    Array.from({\n      0: \"value\",\n      length: 1\n    })\n  )\n)\n```\n\n# es5 方法实现拷贝\n\n```js\n// for遍历基本类型，注意for of是取数组元素，for in是取对象属性\nconst clone0 = arr => {\n  const result = []\n  for (let item of arr) {\n    result.push(item)\n  }\n  return result\n}\n\nconst arr0 = [1, 2, 3]\nconst newArr0 = clone0(arr0)\narr0[2] = 233\nconsole.log(newArr0)\n\n/// slice是纯函数，用来截取指定区间的内容\nconst arr1 = [1, 2, 3]\nconst newArr1 = arr1.slice()\narr1[2] = 233\nconsole.log(newArr1)\n\n// concat也是纯函数\nconst arr2 = [1, 2, 3]\nconst newArr2 = Array.prototype.concat(arr2)\narr2[2] = 233\nconsole.log(newArr2)\n```\n\n# es6 方法实现拷贝\n\n```js\nconst arr3 = [1, 2, 3]\nconst newArr3 = Object.assign([], arr3)\narr3[2] = 233\nconsole.log(newArr3)\n\nconst arr4 = [1, 2, 3]\nconst newArr4 = [...arr4]\narr4[2] = 233\nconsole.log(newArr4)\n\nconst arr5 = [1, 2, 3]\nconst newArr5 = arr5.map(i => i)\narr5[2] = 233\nconsole.log(newArr5)\n\nconst arr6 = [1, 2, 3]\nconst newArr6 = arr6.reduce((out, cur) => {\n  out.push(cur)\n  return out\n}, [])\narr6[2] = 233\nconsole.log(newArr6)\n\nconst arr7 = [1, 2, 3]\nconst newArr7 = arr7.filter(_ => 1)\narr7[2] = 233\nconsole.log(newArr7)\n```\n\n# API 实现\n\n### map\n\n```js\nArray.prototype.myMap = function(callbackfn, thisArg) {\n  const newArr = []\n  for (let i = 0; i < this.length; i++) {\n    newArr.push(callbackfn.call(thisArg, this[i], i, this))\n  }\n  return newArr\n}\nconsole.log([1, 2, 3].myMap(i => i * i))\n```\n\n### reduce\n\n> 为什么原生的 reduce 没有 thisArg??\n\n```js\nArray.prototype.myReduce = function(callbackfn, initialValue = null) {\n  for (let i = 0; i < this.length; i++) {\n    initialValue = callbackfn(initialValue, this[i], i, this)\n    // initialValue = callbackfn.call(thisArg, initialValue, this[i], i, this)\n  }\n  return initialValue\n}\nconsole.log([1, 2, 3].myReduce((pre, cur) => pre + cur))\n```\n\n### filter\n\n```js\nArray.prototype.myFilter = function(callbackfn, thisArg) {\n  const newArr = []\n  for (let i = 0; i < this.length; i++) {\n    callbackfn.call(thisArg, this[i], i, this) && newArr.push(this[i])\n  }\n  return newArr\n}\nconsole.log([1, 2, 3].myFilter(i => i >= 2))\n```\n\n## 对象作用域\n\n```js\nconst obj = {\n  value: 2,\n  testFilter() {\n    // function函数作用域，上下文随调用时的作用域决定\n    return [1, 2, 3].myFilter(function(i) {\n      return i >= this.value\n    }, this)\n  },\n  testReduce() {\n    return [1, 2, 3].myReduce((pre, cur) => pre + this.value + cur, 0)\n  }\n}\nconsole.log(obj.testFilter())\nconsole.log(obj.testReduce())\n```\n"},{"path":"/blog/Javascript基础/深拷贝.md","title":"深拷贝","text":"```js\nconst clone = value => {\n  if (typeof value !== \"object\") return value\n  // 遍历每个属性，执行clone，并把返回值添加到新对象对应属性上\n  return Object.keys(value).reduce(\n    (out, key) =>\n      Object.assign(out, {\n        [key]: clone(value[key])\n      }),\n    {}\n  )\n}\n\nconst obj = {\n  name: \"saber\",\n  age: 21,\n  like: [\"js\", \"ts\"]\n}\n\nconst newObj = clone(obj)\nconsole.log(obj, newObj)\nobj.age = 233\nobj.like.push(\"vv\")\nconsole.log(obj, newObj)\n```\n\n# 补充\n\n深拷贝遇到循环引用会无限递归导致堆栈溢出\nlodash 却可以实现循环引用的拷贝，它的原理：\n利用了 stack，每次访问一个属性后，把值存入 stack 中，如果 stack 中已经存在，说明发生了循环引用，则直接返回。\n即遇到循环引用的属性，就浅拷贝\n"},{"path":"/blog/Javascript基础/矩形相交.md","title":"矩形相交","text":"# 测试相交元素\n\n```js\n/**\n * `请确保两个元素在同一个父元素下`\n * @param {HTMLElement} element1\n * @param {HTMLElement} element2\n * @param {Function} onEnter\n * @param {Function} onOut\n */\nconst testEnter = (element1, element2, onEnter, onOut) => {\n  // clientWidth表示内容宽，包含内边距\n  const width1 = element1.clientWidth\n  const height1 = element1.clientHeight\n  const width2 = element2.clientWidth\n  const height2 = element2.clientHeight\n  // offsetLeft表示相对父元素左边的距离\n  const x1 = element1.offsetLeft\n  const y1 = element1.offsetTop\n  const x2 = element2.offsetLeft\n  const y2 = element2.offsetTop\n\n  // 坐标区间测试\n  if (\n    x1 > x2 - width1 &&\n    x1 < x2 + width2 &&\n    y1 > y2 - height1 &&\n    y1 < y2 + height2\n  ) {\n    onEnter && onEnter()\n  } else {\n    onOut && onOut()\n  }\n}\n```\n"},{"path":"/blog/Javascript基础/类和继承.md","title":"类和继承","text":"```js\n// 首先定义父类\nfunction Animal(name) {\n  // 构造函数中都是实例的属性，不同实例不共享\n  this.name = name || \"Animal\"\n  this.getName = function() {\n    return this.name\n  }\n}\n\n// 原型上的属性，不同实例会共享此属性，不能多继承\nAnimal.prototype.age = 233\n```\n\n# 原型链继承\n\n> 实例上找不到属性会去`__proto__`原型上找\n\n```js\nfunction Dog(name) {\n  this.name = name\n}\n// 设置原型为Animal实例，这会导致所有实例共享以下属性\nDog.prototype = new Animal(\"Dog\")\n```\n\n# 构造函数继承\n\n劫持父类的构造方法来初始化子类属性，多继承就多 call 几个\n\n> 只能继承构造属性，不能继承原型属性\n> 不能实现函数复用，每个子例都会拷贝一份\n> 实例不是父类实例，调用 instanceof(父类)会输出 false\n\n```js\nfunction Cat(name) {\n  Animal.call(this, name)\n}\n```\n\n# 实例继承\n\n> 为父类实例添加属性后返回。类似工厂函数。\n\n> 实例是父类实例，不是子类实例，不能多继承\n\n```js\nfunction Pig(name) {\n  const instance = new Animal(name)\n  return instance\n}\n```\n\n# 拷贝继承\n\n> 效率低，不可访问不可枚举方法\n\n```js\nfunction Chick(name) {\n  const instance = new Animal(name)\n  Object.assign(Chick.prototype, instance)\n}\n```\n\n# 组合继承\n\n> 即构造继承 + 原型继承\n\n```js\nfunction Cow(name) {\n  Animal.call(this, name)\n}\n// 调用了两次构造函数！(子类优先级高，屏蔽父类属性)\nCow.prototype = new Animal()\n// 上面重写了prototype！所以一定记得修复丢失的constructor\nCow.prototype.constructor = Cow\n```\n\n# 寄生组合继承\n\n> 思路是，去掉第二次构造函数调用\n\n```js\nfunction Horse(name) {\n  Animal.call(this, name)\n}\n// Horse.prototype = Object.create(Animal.prototype)\n// 修复因重写prototype丢失的constructor\nHorse.prototype.constructor = Horse\n;(function() {\n  // 用一个空的构造函数替换掉父类构造函数就行了\n  const Super = function() {}\n  Super.prototype = Animal.prototype\n  Horse.prototype = new Super()\n})()\n```\n\n# 实现私有、静态属性\n\n```js\nconst People = (function(_super) {\n  // 但是，请注意，这个私有的变量会被所有实例共享！！\n  // 所以typescript没有选择这种私有方式\n  const _name = \"this is private\"\n\n  function People(age) {\n    // 继承构造函数\n    _super.call(this)\n    this.age = age\n    this.getName = function() {\n      // 获取私有属性\n      return _name\n    }\n  }\n\n  // Object.create可以不依赖构造函数，直接使用原型生成一个实例\n  // 等价于用一个空的构造函数替换原型的构造函数再new\n  // 继承原型属性\n  // People.prototype = Object.create(_super.prototype)\n  People.prototype = Object_create(_super.prototype)\n  // 上面重写了原型，修复构造函数指向\n  People.prototype.constructor = People\n  // 静态属性\n  People.id = \"233\"\n\n  return People\n})(Base)\n\nfunction Base() {\n  this.type = \"base\"\n}\n\nBase.prototype.getType = function() {\n  return this.type\n}\n\nconst p = New(People)(21)\n\nconsole.log(p)\n// instanceof判断右边构造函数的prototype原型是否在左边实例的__proto__原型链上\nconsole.log(p instanceof Base) // true\nconsole.log(p instanceof People) // true\n```\n\n# Object.create 实现\n\n```js\nfunction Object_create(prototype) {\n  // 替换构造函数法\n  // const ctor = function () {}\n  // ctor.prototype = prototype\n  // return new ctor()\n  // 跳过构造函数法，直接绑定原型(原型链指向原型)\n  const obj = {\n    __proto__: prototype\n  }\n  return obj\n}\n```\n\n# new 实现\n\n> new 是用来执行函数的，只不过顺便绑定了原型。\n> 所以手动实现：\n\n1. 新对象绑定原型`__proto__`\n2. 执行构造函数(注意上下文)\n3. 返回新对象\n\n```js\n/**\n * @param {Function} constructor\n * @returns\n */\nfunction New(constructor) {\n  // return function () {\n  //   const obj = Object.create(constructor.prototype)\n  //   constructor.apply(obj, arguments)\n  //   return obj\n  // }\n  return function() {\n    var obj = {\n      __proto__: constructor.prototype\n    }\n    constructor.apply(obj, arguments)\n    return obj\n  }\n}\n```\n"},{"path":"/blog/Javascript基础/节流防抖.md","title":"节流防抖","text":"# 节流\n\n```js\nconst throttle = (callback, delta = 500, metaKey = \"__$$count\") => {\n  const next = () => Reflect.set(throttle, metaKey, Date.now() + delta)\n  Reflect.has(throttle, metaKey) || next()\n  if (Date.now() > Reflect.get(throttle, metaKey)) {\n    next()\n    callback()\n  }\n}\n```\n\n# 防抖\n\n```js\nexport const debounce = (callback: Function, delta = 300) => {\n  clearTimeout(callback[\"throttle\"])\n  callback[\"throttle\"] = setTimeout(callback, delta)\n}\n```\n"},{"path":"/blog/Javascript基础/进入视口范围检测.md","title":"进入视口范围检测","text":"```js\n/**\n * 进入视口范围检测\n *\n * @param {HTMLElement} element\n * @param {VoidFunction} onEnter\n * @param {VoidFunction} onOut\n * @param {number} [deltaTop=0]\n * @param {number} [deltaBottom=0]\n */\nfunction testClientRect(\n  element,\n  onEnter,\n  onOut,\n  deltaTop = 0,\n  deltaBottom = 0\n) {\n  const rect = element.getBoundingClientRect()\n  // 坐标区间检测\n  if (\n    rect.y < window.innerHeight + deltaTop &&\n    rect.y > -rect.height + deltaBottom\n  ) {\n    onEnter && onEnter()\n  } else {\n    onOut && onOut()\n  }\n}\n```\n"}]},{"path":"/blog/Node","title":"Node","children":[{"path":"/blog/Node/koa中间件机制.md","title":"koa中间件机制","text":"```js\nasync function job1(ctx, next) {\n  console.log(ctx.name, \"1\")\n  await next()\n  console.log(ctx.name, \"5\")\n}\n\nasync function job2(ctx, next) {\n  console.log(ctx.name, \"2\")\n  await next()\n  console.log(ctx.name, \"4\")\n}\n\nasync function job3(ctx) {\n  console.log(ctx.name, \"3\")\n}\n\nconst ctx = { name: \"koa\" }\n```\n\n原理就是把下一个 promise 传给上一个\n\n```javascript\nconst process = (...jobs) =>\n  jobs.reduceRight((next, job) => async () => await job(ctx, next), null)\n\nprocess(job1, job2, job3)() // koa 1, koa 2, koa 3, koa 4, koa 5\n```\n"},{"path":"/blog/Node/promisify.md","title":"promisify","text":"# promisify\n\n快速将 callback style 的 API 转为 Promise style.\n\n```js\nimport { promisify } from \"util\"\nimport { readdir, readFile, stat, exists, mkdir, writeFile } from \"fs\"\n\nexport const ReadDir = promisify(readdir)\nexport const ReadFile = promisify(readFile)\nexport const Stat = promisify(stat)\nexport const Exists = promisify(exists)\nexport const MkDir = promisify(mkdir)\nexport const WriteFile = promisify(writeFile)\n```\n\n## 原理\n\n> 简化版，一个参数。\n\n```ts\nconst promiseify = <Arg, CB extends (err: Error, result: any) => any>(\n  method: (arg: Arg, callback: CB) => void\n) => (arg: Arg) =>\n  new Promise<Parameters<CB>[\"1\"]>((resolve, reject) => {\n    const callback = (err: Error, result: any) =>\n      err ? reject(err) : resolve.call(this, result)\n    try {\n      method.apply(null, [arg, callback])\n    } catch (err) {\n      reject(err)\n    }\n  })\n```\n\n将(args, callback) => void 中 callback 重写，在 callback 中执行 promise 的 executor。\n\ntypescript 类型中对 Arg 类型只能枚举，原因是 rest 参数只能作为最后一个参数。(看一下 node 的 types 声明)\n(同样的难题在 reselect 库中也发生)\n\n> c++可变长模板参数也是如此。\n"}]},{"path":"/blog/React原理","title":"React原理","children":[{"path":"/blog/React原理/React-Fiber实现.md","title":"React-Fiber实现","text":"## 前言\n\ngithub 上添加 react-like 标签的项目有 20 个左右，几乎所有的项目都是使用 Javascript 编码。\n难以搞清楚一个对象的具体结构，就比如 Fiber 对象，上面有很多属性，有些是指针域，有些是对象，有些是数组，有些必选有些可选。。。\n如果不对数据结构进行合理建模的话，很难掌握对象的属性变动，也难以分析潜在的 bug，更不用说优化、重构之类的了。\n\n下面是来自某个项目的一段 JS 代码\n\n```javascript\nlet oldFiber,\n  newFiber,\n  element,\n  instance = workInProgress.stateNode;\nlet newState = Object.assign(\n  instance.state || {},\n  instance._partialState || {}\n);\nlet oldProps = instance.props;\nlet newProps = workInProgress.props;\nconst getDerivedStateFromProps = instance.constructor.getDerivedStateFromProps;\n```\n\n从这段代码中可以大致了解到 Fiber 拥有 stateNode、props 属性，Fiber.stateNode 上有 state、partialState、props 属性同时它还是个构造函数的原型（不难看出 Fiber.stateNode 应该是个 es6 class 对象）。\n\n是不是开始感到混乱了...\n\n不是说 Javascript 代码不好，相反 JS 代码相对简洁，但是作为 Typescript 的忠实粉丝，我决定还是使用 TS 来重写一遍，顺便加深对 Fiber Reconcile 过程的理解。\n"},{"path":"/blog/React原理/reconciler实现","title":"reconciler实现","children":[{"path":"/blog/React原理/reconciler实现/beginWork.md","title":"beginWork","text":"## reconcile 阶段入口\n\n判断当前 fiber 的类型(host or hook)，如果是 host 类型则根据 fiber.tag 生成一个 dom 节点，如果是 hook 类型则实例就是自己，在实例上保存一个 stateNode 属性(还是自己)用于在 createWorkInProgress 执行中回溯到 rootFiber。\n\n```typescript\nfunction beginWork(fiber: Fiber) {\n  if (fiber.type === \"hook\") {\n    return updateHOOKComponent(fiber);\n  } else {\n    return updateHostComponent(fiber);\n  }\n}\n```\n\n### updateHostComponent\n\n更新 host Fiber\n\n```typescript\nfunction updateHostComponent(fiber: Fiber) {\n  // 如果实例不存在，则生成一个真实DOM节点赋给instance\n  if (!fiber.instance) fiber.instance = renderToDOM(fiber);\n  // 对props.children(通过React.createElement生成的VNode树的children集合)进行reconcile新旧比对，标记effectType\n  return reconcileChildren(fiber, fiber.props.children);\n}\n```\n\n#### renderToDOM\n\n根据 host Fiber 生成对应实例(真实 DOM)\n\n```typescript\nfunction renderToDOM(fiber: Fiber) {\n  // 如果fiber.tag是function类型，则返回(这里主要用于类型安全)\n  if (typeof fiber.tag === \"function\") return;\n\n  // host Fiber实例可能是Element也可能是Text\n  let dom: HTMLElement | Text = null;\n\n  if (fiber.tag === \"text\") {\n    // 如果tag 值为 text，则创建一个文本节点\n    dom = document.createTextNode(\"\");\n  } else {\n    // 根据fiber.tag创建对应真实DOM\n    dom = document.createElement(fiber.tag);\n  }\n\n  // 根据fiber.props(即JSX标签上的属性)更新DOM节点\n  // 第二个参数为oldProps，因为这是Fiber实例初始化，故没有alternate(旧的Fiber)。直接传一个空属性进去。\n  updateHostProperties(dom, {}, fiber.props);\n\n  return dom as FiberInstance;\n}\n```\n\n### updateHOOKComponent\n\n更新 hook Fiber\n\n```typescript\nfunction updateHOOKComponent(fiber: Fiber) {\n  // 如果实例不存在，则把函数组件对应Fiber(就是自己)赋给instance\n  if (!fiber.instance) fiber.instance = fiber as FiberInstance;\n  // 在实例上保存一个 stateNode 属性(还是自己)用于回溯到 rootFiber。\n  fiber.instance.stateNode = fiber;\n\n  // 给全局变量currentFiber赋值，在Hook API使用\n  currentFiber = fiber.instance;\n\n  // 用于hook API ID 分配，hook需要一个id来标识\n  // 例如函数组件内多个useState Hook，在fiber.state上保存initialState时需要利用id区分\n  // Order.fallback在hook组件执行后将id分配器回滚。(具体见后续实现)\n  Order.fallback();\n\n  // 这里判断fiber.tag是否为function类型，hook Fiber的实例是函数组件，所以tag就是函数组件。\n  if (typeof fiber.tag !== \"function\") return;\n  // 执行函数组件，并传入props对象，返回hook Fiber的 Vnode children\n  return reconcileChildren(fiber, fiber.tag(fiber.props));\n}\n```\n"},{"path":"/blog/React原理/reconciler实现/commitAllWork.md","title":"commitAllWork","text":"## commit 阶段\n\n检测到 pendingCommit 被赋值后则立刻进入 commit 阶段\n\n### 函数声明\n\n```typescript\nfunction commitAllWork(fiber: Fiber): void;\n```\n\n传入 pendingCommit(一个 EffectFibers 链表，其实是 rootFiber，rootFiber 的 effectList 属性就相当于一个 Fiber 链表。JS 里数组不也是一种链表么，还是可迭代对象(Iteratable)呢)\n\n### 函数实现\n\n```typescript\nfunction commitAllWork(fiber: Fiber) {\n  // 遍历effectList链表，对每个EffectFiber执行commitWork操作\n  fiber.effectList.forEach(commitWork);\n\n  // 所有任务commit完毕后，将workInProgress和pendingCommit置空\n  workInProgress = null;\n  pendingCommit = null;\n}\n```\n"},{"path":"/blog/React原理/reconciler实现/commitWork.md","title":"commitWork","text":"## 单个 Fiber 的 commit 操作\n\n### 函数声明\n\n```typescript\nfunction commitWork(fiber: Fiber): void;\n```\n\n根据 Fiber.effectType 的类型进行 commit 操作\n\n### 函数实现\n\n```typescript\nfunction commitWork(fiber: Fiber) {\n  // 向上查找host Fiber类型的parent节点\n  let parentFiber = fiber.parent;\n  while (parentFiber.type === \"hook\") {\n    parentFiber = parentFiber.parent;\n  }\n\n  // 拿到host Fiber类型的parentFiber的实例(host Fiber类型的实例是真实DOM)\n  const parentDom = parentFiber.instance;\n\n  // 判断effectType\n  if (fiber.effectType === \"place\" && fiber.type === \"host\") {\n    // 如果是effectType:place，并且当前fiber是host Fiber类型\n\n    // 因为组件要被其他组件替换，即UnMount，则执行effects中的清理函数。\n    commitEffects(fiber);\n    // place替换真实DOM节点(或append创建)\n    commitPlace(fiber, parentDom, parentFiber.refChild);\n  } else if (fiber.effectType === \"update\") {\n    // 如果是effectType:update\n    // diff 新旧fiber的props属性(利用alternate链接到旧的fiber的props)\n    updateHostProperties(fiber.instance, fiber.alternate.props, fiber.props);\n  } else if (fiber.effectType === \"delete\") {\n    // 如果是effectType:delete\n    // 组件卸载，执行effects中的清理函数\n    commitEffects(fiber);\n    // 删除真实DOM节点\n    commitDelete(fiber, parentDom);\n  }\n\n  // 如果组件WillMount或者UnMount则执行一次commitEffects\n  // 本质是遍历Fiber.effects数组，执行注册的副作用任务，并收集副作用的返回值(清理函数)。\n  if (!fiber.isMount) commitEffects(fiber);\n\n  // 如果props中注册了ref指针，并且当前fiber是host Fiber类型，则将实例(真实DOM)赋值给ref.current\n  if (\"ref\" in fiber.props && fiber.type === \"host\") {\n    fiber.props.ref.current = fiber.instance;\n  }\n}\n```\n\n#### commitPlace\n\n替换或者创建 host Fiber 的实例\n\n```typescript\nfunction commitPlace(fiber: Fiber, parentDom: FiberInstance, refChild: Fiber) {\n  if (refChild) {\n    // 如果存在refChild表示是一次place操作\n    const newChild = fiber.instance;\n    // refChild就是fiber.alternate.sibling.instance，即旧fiber的兄弟节点\n    const oldChild = refChild.instance;\n\n    // 在旧fiber的兄弟节点前插入新fiber的实例\n    parentDom.insertBefore(newChild, oldChild);\n  } else {\n    // 没有refChild，则是一次create操作\n    // 组件WillMount，设置标志位true\n    fiber.isMount = true;\n    // 在DOM树上添加host Fiber实例\n    parentDom.append(fiber.instance);\n  }\n}\n```\n\n#### commitDelete\n\n删除 host Fiber 的实例(从 DOM 树上移除)\n\n```typescript\nfunction commitDelete(fiber: Fiber, parentDom: FiberInstance) {\n  // 如果是hook Fiber，则找它的host Fiber子节点，但不能是text类型tag\n  while (fiber.type === \"hook\") {\n    if (fiber.child.tag === \"text\") break;\n    fiber = fiber.child;\n  }\n  // 找到了hook Fiber的host Fiber子节点，将它的实例从DOM树上移除\n  parentDom.removeChild(fiber.instance);\n}\n```\n"},{"path":"/blog/React原理/reconciler实现/createElement.md","title":"createElement","text":"## jsxFactory 函数\n\n即 React.createElement 函数，用于生成 VNode 节点并链接成 VNode 树\n\n### 函数声明\n\n```typescript\nfunction createElement<K extends keyof HTMLElementTagNameMap>(\n  tag: K,\n  props: Partial<HTMLElementTagNameMap[K]>,\n  ...childNodes: JSX.Element[]\n): JSX.Element;\n```\n\nK 泛型参数约束为 keyof HTMLElementTagNameMap，例如\"div\"、\"a\"、\"button\"等，可以看看 TS 标准库中对 HTMLElementTagNameMap 的定义:\n\n```typescript\ninterface HTMLElementTagNameMap {\n  a: HTMLAnchorElement;\n  abbr: HTMLElement;\n  address: HTMLElement;\n  applet: HTMLAppletElement;\n  area: HTMLAreaElement;\n  article: HTMLElement;\n  aside: HTMLElement;\n  audio: HTMLAudioElement;\n  b: HTMLElement;\n  base: HTMLBaseElement;\n  basefont: HTMLBaseFontElement;\n  bdo: HTMLElement;\n  blockquote: HTMLQuoteElement;\n  body: HTMLBodyElement;\n  br: HTMLBRElement;\n  button: HTMLButtonElement;\n  ...\n}\n```\n\n所以 HTMLElementTagNameMap[K]就是 K 对应 HTMLElement 的属性类型。\n\nchildNodes 为子节点，举个例子\n\n```typescript\nconst List = React.createElement(\n  \"ul\",\n  null,\n  React.createElement(\"li\", null),\n  React.createElement(\"li\", null)\n);\n```\n\n这个 List 是个 JSX.Element 实例，其 childNodes 为[{tag:\"li\", props:null}, {tag:\"li\", props:null}]，渲染到真实 DOM 就是\n\n```html\n<ul>\n  <li></li>\n  <li></li>\n</ul>\n```\n\n### 函数实现\n\n```typescript\nexport function createElement<K extends keyof HTMLElementTagNameMap>(\n  tag: K,\n  props: Partial<HTMLElementTagNameMap[K]>,\n  ...childNodes: JSX.Element[]\n): JSX.Element {\n  // 用于map的映射函数\n  // 判断childNode类型，如果它是string或者number类型，则生成一个为tag为text的VNode\n  // 将childNode(就是文本节点内容)作为props中nodeValue的值\n  const mapper = (c: any): any =>\n    typeof c === \"string\" || typeof c === \"number\"\n      ? createElement(\"text\" as \"span\", { nodeValue: c as string })\n      : c;\n\n  // 对childNodes中每个子节点执行上面的映射函数\n  const children = [].concat(...childNodes).map(mapper);\n  // 将处理好的children保存在props中然后返回一个VNode节点\n  return <any>{ tag, props: { ...props, children } };\n}\n```\n\n这里有个非常有趣的操作，看似无用\n\n```typescript\n[].concat(...childNodes);\n```\n\n[].concat(...array) 这个表达式常用来对 array 数组降维，例如\n\n```typescript\n[].concat(...[1, 2, [3, 4]]); // [1, 2, 3, 4]\n```\n\n那么 childNodes 数组什么时候可能会变的不“平坦”呢？\n\n举个场景例子，在 React 组件中常有一种操作\n\n比如想通过数组['a', 'b']得到一个 a, b, c 的列表\n\n```html\n<ul>\n  <li>a</li>\n  <li>b</li>\n  <li>c</li>\n</ul>\n```\n\n在 React 中 JSX 标签可以看作是值，那么可以使用数组 map 来高效生成：\n\n```typescript\n<ul>\n  {[\"a\", \"b\"].map(ch => (\n    <li key={ch}>{ch}</li>\n  ))}\n  <li>c</li>\n</ul>\n```\n\n编译之后\n\n```typescript\nReact.createElement(\n  \"ul\",\n  null,\n  [\"a\", \"b\"].map(ch =>\n    React.createElement(\n      \"li\",\n      { key: ch },\n      React.createElement(\"text\", { nodeValue: ch })\n    )\n  ),\n  React.createElement(\n    \"li\",\n    null,\n    React.createElement(\"text\", { nodeValue: \"c\" })\n  )\n);\n```\n\n分析一下它生成的 VNode 树\n\n```typescript\n{\n  tag: \"ul\", props: null,\n  [\n    {tag:\"li\", null,\n      {tag:\"text\", {nodeValue: 'a'}}\n    },\n    {tag:\"li\", null,\n      {tag:\"text\", {nodeValue: 'b'}}\n    }\n  ],\n  {tag:\"li\", null,\n      {tag:\"text\", {nodeValue: 'c'}}\n  }\n}\n```\n\n简化一下就是变成了[['a', 'b'], 'c']的结构，变不“平坦”了！但是三个 li 标签在结构上应该是['a', 'b', 'c']才对，所以需要数组降维。\n"},{"path":"/blog/React原理/reconciler实现/hook","title":"hook","children":[{"path":"/blog/React原理/reconciler实现/hook/createContext.md","title":"createContext","text":"## Context Hook\n\ncontext 理解为全局变量就好了，只不过约定使用 createContext 创建，使用 useContext 读取。\n(如果是 class 组件，需要实现为 provider & customer，但当前只实现函数组件。)\n\n### 实现\n\n```typescript\nfunction createContext<T extends Dict>(context: T) {\n  return context;\n}\n\nfunction useContext<T extends Dict>(context: T) {\n  return context;\n}\n```\n\ncontext 初次听起来怪怪的，但是实际上它就是这样。\nuseContext 读取了 context，其实就已经引入了副作用，至少它访问了外部环境。需要将 Context 包装在 Monad 里才对，然后把对 Context 的操作 liftM 进 Context Monad 里。(貌似 React 内部的 useContext 会引发 rerender，应该是改变 context 后需要重新通知所有组件一次)\n"},{"path":"/blog/React原理/reconciler实现/hook/useEffect.md","title":"useEffect","text":"## Effect Hook\n\n这是一个 pure 操作，将副作用包裹在了 Monad 里（可以理解为外面又包了一层函数），react 调度机制会在一轮渲染之后执行这些副作用操作，保证了副作用与函数组件主体的充分隔离。\n\n### Effect 类型\n\n```typescript\ntype Effect = () => Effect | void;\n```\n\n这是一个利用函数特性实现的 Monad。首先是个映射到自身类型的自函子，然后可以 return 可以 >>=，即自函子范畴上的幺半群。\n\n## useEffect 实现\n\n```typescript\nexport function useEffect(effect: Effect, deps?: any[]) {\n  if (deps) {\n    // 如果deps存在，使用memorize优化\n    useMemo(() => currentFiber.effects.push(effect), deps);\n  } else {\n    currentFiber.effects.push(effect);\n  }\n}\n```\n\n这里将 Moand 放到了一个 List 中，在纯函数组件执行完之后(进入 commitWork 阶段)，依次执行。\n"},{"path":"/blog/React原理/reconciler实现/hook/useMemo.md","title":"useMemo","text":"## Memo Hook\n\nmemorize 优化\n\n因为对于纯函数来说，相同的输入得到相同的输出，所以可以把结果缓存起来，对于同样的输入没必要再执行第二遍。\n\n### 对 deps 数组的 diff\n\n```typescript\nconst diffArray = <T extends any[]>(a: T, b: T) => {\n  if (a.length && b.length) {\n    let i = a.length > b.length ? a.length : b.length;\n    while (i--) if (a[i] !== b[i]) return false;\n    return true;\n  } else {\n    return false;\n  }\n};\n```\n\n没什么好解释的。\n\n## useMemo 实现\n\n依赖 Fiber.memorize 属性\n\n```typescript\n// memo hook的顺序id分配器\nconst MemoOrder = Order.create();\n\nexport function useMemo(callback: Function, deps: any[] = []) {\n  // 给当前hook关联的memorize分配一个id\n  const id = MemoOrder.forward();\n\n  // currentFiber是一个不断变化的值，hook内部需要捕获并缓存一份它的瞬时值\n  // 记录即缓存一份currentFiber，拿到控制权，用于从当前记录点恢复\n  const fiber = currentFiber;\n\n  // fiber.memorize是一个memorizations map，类型为 {[id:string]: Dict}\n  const memoMap = fiber.memorize;\n\n  // 获取上一次输入\n  const memorized = memoMap[id] || [];\n\n  if (diffArray(deps, memorized)) {\n  } else {\n    // 如果和上次输入不同，则更新memorization为新的deps\n    memoMap[id] = deps;\n    // 执行memo callback\n    callback();\n  }\n}\n```\n"},{"path":"/blog/React原理/reconciler实现/hook/useRef.md","title":"useRef","text":"## Ref Hook\n\nref 用来索引到 host Fiber 的实例(真实 DOM)\n\nref 是一个指针，在 JS 中实现为对象，传递它的引用避免值拷贝\n\n### ref 类型\n\n```typescript\ntype RefAttributes<T extends HTMLElement> = {\n  current: T;\n};\n```\n\n是一个对象，只有一个成员属性 current，泛型类型约束为 HTMLElement，即 T 类型需要满足 [继承自 HTMLElement] 的条件\n\n### 何时被初始化？\n\n在组件对应 Fiber commit 时初始化(异步初始化)，在组件内部需要异步读取此值，例如在 useEffect 里，在 onClick 里等等，组件内顶层直接读取值为 null(因为组件执行是同步的)\n\n在实现 commitWork 的时候已经解释了 ref 的初始化。这里不再赘述。\n\n## useRef 实现\n\n因为它本质就是利用了 JS 中对象赋值传引用的特性。所以十分简单。\n\n```typescript\nexport function useRef<T extends HTMLElement>(\n  current: T = null\n): React.RefAttributes<T> {\n  return { current };\n}\n```\n\n没有什么好解释的。\n\n> 其实就是对 ref 惰性求值，你也可以把它实现为 pure 版本，利用 Monad 包装起来，例如 ref = () => current\n"},{"path":"/blog/React原理/reconciler实现/hook/useState.md","title":"useState","text":"## State Hook\n\n在 beginWork/updateHookComponent 函数中留了两个问题，就是关于 Order 类和 currentFiber。\n\n#### updateHOOKComponent\n\n```typescript\nfunction updateHOOKComponent(fiber: Fiber) {\n  // 省略细节...\n\n  currentFiber = fiber.instance;\n\n  Order.fallback();\n\n  // 省略细节...\n}\n```\n\n### currentFiber\n\ncurrentFiber 为调度过程中的瞬时执行点，在 hook API 闭包内会捕获并保存一份拷贝。\n\n### Order\n\n顺序 ID 分配器\n\n```typescript\nclass Order {\n  private constructor() {}\n  public static create() {\n    const instance = new Order();\n    Order.insList.push(instance);\n    return instance;\n  }\n  public static insList: Order[] = [];\n  private it = Order.INIT();\n  public forward() {\n    return this.it.next().value;\n  }\n  private fallback() {\n    this.it = Order.INIT();\n  }\n  public static fallback() {\n    Order.insList.forEach(ins => ins.fallback());\n  }\n  private static *INIT() {\n    for (let i = 0; ; ++i) yield i;\n  }\n}\n```\n\n就是个惰性的无穷数列，即[0, 1 ..]\nforward 用于分配 ID，fallback 用于分配器回滚。\n它解决了什么问题？区分多次调用同类型 Hook API 的上下文。\n\n## useState 实现\n\n依赖 Fiber.state 属性\n\n```typescript\n// state hook的顺序id分配器\nconst StateOrder = Order.create();\n\n// setState类型\ntype Dispatcher<T> = (state: T) => void;\n\nexport function useState<T>(initialState: T): [T, Dispatcher<T>] {\n  // 给当前hook关联的state分配一个id\n  const id = StateOrder.forward();\n\n  // currentFiber是一个不断变化的值，hook内部需要捕获并缓存一份它的瞬时值\n  // 记录即缓存一份currentFiber，拿到控制权，用于从当前记录点恢复\n  const fiber = currentFiber;\n\n  // fiber.state是一个state map，类型为 {[id:string]: Dict}\n  const stateMap = fiber.state;\n\n  // 如果当前id不存在则stateMap[id]初始化为init state\n  if (!(id in stateMap)) stateMap[id] = initialState;\n\n  // setState函数\n  const setState: Dispatcher<T> = state => {\n    // 检查setState执行时期，如果workInProgress存在表明是同步调用setState\n    // setState必须为异步调用，否则调度机制会陷入死循环\n    // 而且同步调用setState也没有任何意义。\n    if (workInProgress) {\n      throw new Error(\"setState should be executed asynchronously.\");\n    }\n\n    // 根据id拿到当前hook分配到的state，并更新为传入的新的state\n    stateMap[id] = state;\n\n    // 从hook 闭包内保存的fiber断点恢复(或叫返回现场)\n    React.render(fiber);\n  };\n\n  // 返回分配到的state和setState函数\n  return [stateMap[id], setState];\n}\n```\n"}]},{"path":"/blog/React原理/reconciler实现/performUnitOfWork.md","title":"performUnitOfWork","text":"## 函数声明\n\n```typescript\nfunction performUnitOfWork(fiber: Fiber): void;\n```\n\n遍历一颗 Fiber 链表，reconcile 然后收集 effectFibers(向上合并最终收集到 Fiber 链表的 head Fiber(即 rootFiber)的 effectLists 中)\n\n## 函数实现\n\n```typescript\nfunction performUnitOfWork(fiber: Fiber) {\n  // beginWork内部负责对fiber.child的两条sibling-sibling链表进行新旧比对\n  // 通过child.alternate拿到旧的链表\n  // 最终返回fiber.child\n  const next = beginWork(fiber);\n  // 如果next(也就是fiber.child)存在，则直接返回它\n  if (next) return next;\n\n  // 如果不存在，则开始回溯\n  let current = fiber;\n  while (current) {\n    // completeWork负责向上收集effectFibers，如果到达了顶点，则把当前Fiber节点赋值给pendingCommit\n    completeWork(current);\n\n    // 如果有sibling，则返回它的sibling\n    if (current.sibling) return current.sibling;\n    // 如果没有sibling，则向上回溯\n    current = current.parent;\n  }\n}\n```\n"},{"path":"/blog/React原理/reconciler实现/performWork.md","title":"performWork","text":"## performWork 渲染流程\n\nrender 渲染流程入口\n\n### 函数声明\n\n```typescript\nfunction performWork(deadline: IdleDeadline);\n```\n\nperformWork 由 requestIdleCallback 函数注册到后台协同任务队列，当 JS 线程空闲时执行队列中的函数。\n\n### 函数实现\n\n```typescript\nfunction performWork(deadline: IdleDeadline) {\n  // 内部循环迭代workInProgress\n  workLoop(deadline);\n\n  // 如果workInProgress为空了，表示当前渲染任务执行完毕，查看updateQueue是否为空\n  // 如果不为空则再请求一次后台协同任务\n  if (workInProgress || updateQueue.length) {\n    requestIdleCallback(performWork);\n  }\n}\n```\n"},{"path":"/blog/React原理/reconciler实现/reconcileChildren.md","title":"reconcileChildren","text":"## children 新旧比对\n\n拿到当前 fiber 对应 VNode 树的 children 集合作为新链表，通过 alternate 拿到旧链表，然后 diff 两条链表。\n\n### 函数声明\n\n```typescript\nfunction reconcileChildren(fiber: Fiber, newChildren: Fiber | Fiber[]): Fiber;\n```\n\n第二个参数 newChildren 来源：当 fiber 为 host Fiber 类型时，则从 props.children 中取(由 jsxFactory 函数即 React.createElement 函数收集 children VNode)；当 fiber 为 hook Fiber 类型时(此时 fiber.tag 为 function 类型，也就是你的函数组件)，执行 fiber.tag(fiber.props)，即将 props 传入函数组件执行，返回 children。\n\n### 函数实现\n\n```typescript\nfunction reconcileChildren(fiber: Fiber, newChildren: Fiber | Fiber[]) {\n  // 数组化，归一化处理。例如'a' -> ['a'], ['a', 'b'] -> ['a', 'b']\n  const children = React.Children.toArray<Fiber>(newChildren);\n\n  // 拿到旧fiber节点的child\n  let nextOldFiber = fiber.alternate ? fiber.alternate.child : null;\n\n  let newFiber: Fiber = null;\n  let i = 0;\n\n  // 新旧两条链表开始比对，一条是VNode.props.children链表，一条是oldFiber.sibling链表\n  while (i < children.length || nextOldFiber) {\n    // prevChild用来记录上一次的newFiber，用于链接新的sibling-sibling链表\n    const prevChild = newFiber;\n\n    // 遍历过程中当前旧的节点\n    const oldFiber = nextOldFiber;\n\n    // 当前新的VNode节点\n    const element = i < children.length && children[i];\n\n    // 如果oldFiber存在且element也存在，并且两者tag相同，则两个fiber节点相同\n    // 否则不同\n    const sameTag = oldFiber && element && element.tag === oldFiber.tag;\n\n    if (sameTag) {\n      // 如果新旧节点相同，则直接拷贝旧的节点，并标记effectType为update\n      // 为什么要拷贝，而不是直接newFiber = oldFiber，下文解释\n\n      newFiber = new Fiber(oldFiber.type);\n      newFiber.tag = oldFiber.tag;\n      newFiber.instance = oldFiber.instance;\n      newFiber.state = oldFiber.state;\n      newFiber.props = element.props;\n      newFiber.parent = fiber;\n      newFiber.alternate = oldFiber; // 新fiber上利用alternate链接到旧的fiber，后续commit:update需要\n      newFiber.effectType = \"update\";\n      newFiber.effects = oldFiber.effects;\n      newFiber.isMount = oldFiber.isMount;\n    }\n    if (element && !sameTag) {\n      // 如果新的节点存在，但和旧的节点不同，则保持新节点的属性，并标记effectType为place\n\n      newFiber = new Fiber(typeof element.tag === \"string\" ? \"host\" : \"hook\");\n      newFiber.tag = element.tag;\n      newFiber.props = element.props;\n      newFiber.parent = fiber;\n      newFiber.effectType = \"place\";\n      newFiber.isMount = false; // 要被替换掉，所以UnMount\n    }\n    if (oldFiber && !sameTag) {\n      // 如果旧的节点存在，但和新的节点不同，则删除旧的节点，并标记effectType为delete\n\n      oldFiber.effectType = \"delete\";\n      oldFiber.isMount = false; // 要被删除掉，所以UnMount\n      // 提交到parent Fiber effectList中\n      fiber.effectList.push(oldFiber);\n      // 节点被删除，在父节点上标记refChild\n      fiber.refChild = oldFiber.sibling;\n    }\n\n    // 旧链表向后遍历\n    if (nextOldFiber) nextOldFiber = nextOldFiber.sibling;\n\n    if (i === 0) {\n      // 如果是第一个child则赋给parentFiber.child\n      fiber.child = newFiber;\n    } else if (prevChild && element) {\n      // 链接新链表的sibling-sibling\n      prevChild.sibling = newFiber;\n    }\n\n    // 新链表向后遍历，element依靠index索引从children获取current节点\n    i++;\n  }\n\n  // 返回第一个child\n  return fiber.child;\n}\n```\n\n解释当 effectType 为 update 时为什么要拷贝:\n一个词 immutable.\n"},{"path":"/blog/React原理/reconciler实现/render.md","title":"render","text":"## ReactDOM.render\n\n渲染流程起点\n\n### 函数声明\n\n```typescript\nexport namespace ReactDOM {\n  export function render(component: JSX.Element): void;\n  export function render(component: JSX.Element, container: HTMLElement): void;\n}\n```\n\n函数重载两次\n\n传入 container 参数(也就是 div#root)，表示这是第一次渲染，并清空 rootContainer 子节点。创建一个 host Fiber(rootFiber)，其实例为 container，将 component 添加到 rootFiber 的子节点(即保存到 rootFiber.props 的 children 属性 )。\n\n不传 container 参数表示是一次由 hook 函数组件调用 ReactDispatcher 引起的更新(场景为用户点击事件)，例如 useState 返回的 setState 函数执行，在 createWorkInProgress 函数中将从当前 fiber 实例上的 stateNode 向上回溯到 rootFiber 并赋值给 workInProgress。\n\n### 函数实现\n\n```typescript\nexport namespace ReactDOM {\n  export function render(\n    component: JSX.Element,\n    container?: HTMLElement\n  ): void {\n    let fiber: Fiber;\n\n    if (container) {\n      // 第一次渲染\n\n      // 创建一个rootFiber\n      fiber = new Fiber(\"host\");\n\n      // rootFiber实例为真实DOM(div#root)\n      fiber.instance = container as FiberInstance;\n\n      // 清空rootFiber实例子节点\n      container.innerHTML = null;\n\n      // 将component添加到 rootFiber 的子节点\n      fiber.props = { children: component };\n    } else {\n      // 创建一个hook Fiber\n      fiber = new Fiber(\"hook\");\n\n      // 将函数组件作为hook Fiber的实例\n      fiber.instance = component as FiberInstance;\n\n      // 设置高优先级\n      fiber.expirationTime = 1;\n    }\n\n    // 放入待调度队列\n    updateQueue.push(fiber);\n\n    // 启动渲染流程\n    requestIdleCallback(performWork);\n  }\n}\n```\n"},{"path":"/blog/React原理/reconciler实现/updateHostProperties.md","title":"updateHostProperties","text":"## 更新 DOM\n\ndom 操作\n\n### 函数声明\n\n```typescript\ntype Dict = { [k: string]: any };\n\nfunction updateHostProperties(\n  dom: (HTMLElement | Text) & Dict,\n  oldProps: Dict,\n  newProps: Dict\n): void;\n```\n\n三个参数，dom 的类型为 HTMLElement 或者 Text，`& Dict`用于给这俩个类型添加属性索引，第二个参数为 dom 节点旧的属性，即 host Fiber 的 alternate.props，第三个参数为新的 host Fiber 的 props，由 React.createElement 生成的 VNode 节点提供。\n\n### 函数实现\n\n```typescript\n// props中需要过滤掉的属性\nconst fiberProps = [\"children\", \"ref\"];\n\nfunction updateHostProperties(\n  dom: (HTMLElement | Text) & Dict,\n  oldProps: Dict,\n  newProps: Dict\n) {\n  // 遍历newProps属性，diff\n  Object.entries(newProps).forEach(([k, v]) => {\n    // 过滤属性\n    if (fiberProps.includes(k)) return;\n    // style属性过滤掉，下文单独处理\n    if (k === \"style\") return;\n    // 新旧值没变化，跳过此次DOM操作\n    if (oldProps[k] === v) return;\n    // on开头的event事件handle变lower case\n    if (k.startsWith(\"on\")) k = k.toLowerCase();\n    // 应用变化的属性到真实DOM\n    dom[k] = v;\n  });\n  // style属性diff\n  if (\"style\" in dom) {\n    const newStyle = newProps.style || {};\n    const oldStyle = oldProps.style || {};\n    Object.entries(newStyle).forEach(([k, v]) => {\n      // 新旧样式属性没变化，跳过此次DOM操作\n      if (oldStyle[k] === v) return;\n      // 应用变化的样式属性到真实DOM\n      dom.style[k] = v;\n    });\n  }\n}\n```\n"},{"path":"/blog/React原理/reconciler实现/workLoop.md","title":"workLoop","text":"## workLoop 渲染循环\n\n用于创建并迭代更新 workInProgress(一个 Fiber 链表)。同时负责检查 pendingCommit(就是收集了 effectFibers 的 rootFiber，也可以实现为一个 Fiber 链表)，如果有就进入 commit 阶段。\n\n### 函数声明\n\n```typescript\nfunction workLoop(deadline: IdleDeadline);\n```\n\n传入了一个 deadline 对象，检查空闲时间。\n\n### 函数实现\n\n```typescript\nfunction workLoop(deadline: IdleDeadline) {\n  // 如果workInProgress为空，则先构建一个Fiber赋值给workInProgress\n  // 本质是回溯到rootFiber\n  if (!workInProgress) workInProgress = createWorkInProgress(updateQueue);\n\n  // 如果workInProgress不为空且当前空闲时间足够就开始迭代更新。\n  while (\n    workInProgress &&\n    deadline.timeRemaining() > workInProgress.expirationTime\n  ) {\n    // 迭代更新\n    workInProgress = performUnitOfWork(workInProgress);\n  }\n\n  // 如果有pendingCommit则立刻commit\n  if (pendingCommit) commitAllWork(pendingCommit);\n}\n```\n"},{"path":"/blog/React原理/reconciler实现/全局变量.md","title":"全局变量","text":"## 概览\n\n在调度更新时全局范围内存在有四个变量\n\n```typescript\nconst updateQueue: Fiber[] = [];\nlet workInProgress: Fiber;\nlet pendingCommit: Fiber;\nlet currentFiber: Fiber;\n```\n\n### updateQueue\n\n一个任务队列。用于注册待调度更新的 Fiber 链表。当浏览器空闲时会从中取出 Fiber 链表开始调度更新。\n\n### workInProgress\n\n在迭代更新(新旧更替)过程中的 Fiber 链表快照。\n\n### pendingCommit\n\n在 workLoop 过程中收集到的标记有 EffectType 的 Fiber 链表，等待 commit。\n\n### currentFiber\n\n当前正在调度更新的 Fiber 节点。在 Hook API 中会读取并缓存一份此值的拷贝(保存现场，即 yield)，用于在渲染完毕之后返回现场。\n"}]},{"path":"/blog/React原理/数据结构类型","title":"数据结构类型","children":[{"path":"/blog/React原理/数据结构类型/Fiber数据结构.md","title":"Fiber数据结构","text":"## Fiber 链表\n\n> 数据域和 React Fiber 有所区别，但核心的指针域是一样的。\n\n### 概览\n\n```typescript\ntype Fiber = {\n  type: FiberType;\n  tag: Tag | React.FC;\n  effectType: EffectType;\n  parent: Fiber;\n  child: Fiber;\n  sibling: Fiber;\n  alternate: Fiber;\n  props: Props;\n  state: Dict;\n  memorize: Dict;\n  effects: Effect[];\n  effectList: Fiber[];\n  instance: FiberInstance;\n  stateNode: Fiber;\n  expirationTime: number;\n  isMount: boolean = false;\n  refChild: Fiber;\n};\n```\n\n### Fiber.type\n\n```typescript\ntype FiberType = \"host\" | \"hook\";\n```\n\n如果一个 Fiber 的 type 值为 \"host\"，那么表示它的实例(Fiber.instance)是原生 DOM 节点。\n如果值为\"hook\"，那么表示它的实例是函数组件(React.FC)对应的 Fiber，也就是自己，此时 Fiber.tag 是函数组件(function)。\n\n### Fiber.tag\n\n```typescript\ntype Fiber = {\n  tag: Tag | React.FC;\n};\n\n// Dict 字典类型\ntype Dict = { [k: string]: any };\n\nnamespace React {\n  // FC 函数组件类型\n  export type FC<T extends Dict = Dict> = (props: T) => JSX.Element;\n}\n\ntype Tag = keyof HTMLElementTagNameMap | \"text\";\n```\n\nFiber.tag 的类型可以是 string 类型，也可以是 function 类型。string 类型就是原生 DOM 节点的 TagNameMap 集合成员，这里在集合中添加了一个新的 tag: \"text\"，用于表示原生 Text 对象，即文本节点。\n\n当 tag 为 string 类型时，Fiber.instance 就是 DOM 实例，为 function 类型时，Fiber.instance 就是函数组件对应的 Fiber\n\n### Fiber.effectType\n\n```typescript\ntype EffectType = \"place\" | \"delete\" | \"update\";\n```\n\neffectType 有三种类型，替换，删除，更新。\n\n其实还有创建，但是其过程和 place 相似(从无到有不也是一种替换么？)，故只要在 reconcile 阶段 和 commit 阶段 处理中稍作判断即可当作 place 处理。\n\n### Fiber 指针域(parent, child, sibling)\n\n```typescript\ntype Fiber = {\n  parent: Fiber;\n  child: Fiber;\n  sibling: Fiber;\n};\n```\n\nFiber 链表的空间结构\n\n```typescript\nparent\n|    \\\nchild-sibling\n|\nchild\n```\n\n和 TreeNode 数据结构有所不同，Fiber 添加了一个称做 sibling 的指针域，指向自己的兄弟节点。在 TreeNode 的遍历中可以直接拿到 children 集合，然后使用栈或者队列进行深度优先或者广度优先遍历。而在 Fiber 节点中，采取的是深度优先 + 回溯的办法遍历，优先向下遍历 child-child 链表，到头之后优先回溯到 sibling，再向下遍历 child-child 链表，如果没有 sibling 就回溯到 parent，如果没有 parent 就遍历终止。\n\n### Fiber.alternate\n\n```typescript\ntype Fiber = {\n  alternate: Fiber;\n};\n```\n\nalternate 用于链接到旧的自己。\n\n在 reconcileChildrenArray 阶段中判断 tag 是否相同，相同则标记 effectType:'update'，tag 不同或者旧的自己为 null 则标记 effectType:'place'，并把旧的自己标记 effectType:'delete'然后提交到 parent 的 effectList 中。\n\n在 commit 阶段的 effectType:update 处理中，利用 alternate 链接到旧的自己并与之 diff props 判断，更新变化的属性到真实 DOM。\n\n### Fiber.props\n\n```typescript\ntype Dict = { [k: string]: any };\n\ninterface Props extends Dict {\n  children?: Fiber | Fiber[];\n  ref?: React.RefAttributes<any>;\n}\n```\n\n如果 Fiber.type 值为'host'， 那么 props 表示真实 DOM 数据域，用于描述 DOM 属性。在 commit effectType:'update' 阶段参与属性 diff。\n\n如果 Fiber.type 值为'hook'，则 props 用于函数组件传值，例如传递 children。在 updateHookComponent 阶段中将 props 传入函数组件实例并执行，得到新的 elements(VDom tree 的所有孩子节点) 用于 reconcileChildrenArray。\n\n### Fiber.state\n\n```typescript\ntype Fiber = {\n  state: Dict;\n};\n```\n\nFiber 函数组件状态。在 useState Hook 中读取和更新。\n\n### Fiber.memorize\n\n```typescript\ntype Fiber = {\n  memorize: Dict;\n};\n```\n\n记录 memo hook 上次的输入。\n\n### Fiber.effects\n\n```typescript\ntype Effect = (...args: any) => Effect | void;\n\ntype Fiber = {\n  effects: Effect[];\n};\n```\n\nFiber 函数组件中的副作用操作，在该 Fiber 最终的 commit 阶段执行。\n如果 effect 执行后返回了新的函数，则保存新的函数到 effects 中，在 commit effectType:'place'阶段和 commit effectType:'delete'执行。\n\n使用 Fiber.isMount 来确定副作用是否需要 commit，如果组件已经 Mount，则保持 effects。\n\n> Effect 是一个自函子类型，将自身映射为自身类型，其实应该算是 Monad 了。其实函数本身就是个 Monad，函数本身就实现了 return (高阶化) 和>>= (函数执行降阶)。\n\n### Fiber.effectList\n\n```typescript\ntype Fiber = {\n  effectList: Fiber[];\n};\n```\n\n用于向上收集打上 effectType 标记的 Fiber 节点，最终收集到 rootFiber。在 commit 阶段遍历 effectList 中所有 Fiber。\n\n### Fiber.instance\n\n```typescript\ntype FiberInstance = Fiber & HTMLElement;\n\ntype Fiber = {\n  instance: FiberInstance;\n};\n```\n\nFiber 实例，当 Fiber.type 值为'host'时，instance 就是真实 DOM，值为'hook'时，instance 就是函数组件对应 Fiber(自己)。\n\n### Fiber.stateNode\n\n```typescript\ntype Fiber = {\n  stateNode: Fiber;\n};\n```\n\n在 rootFiber 实例(rootContainer 也就是 div#root 节点) 上链接到 rootFiber。\n\n### Fiber.expirationTime\n\n```typescript\ntype Fiber = {\n  expirationTime: number;\n};\n```\n\nFiber 完成一次 reconcile 所需要的最少时间。\n\n### Fiber.isMount\n\n```typescript\ntype Fiber = {\n  isMount: boolean;\n};\n```\n\n标记 Fiber Mount 状态\n\n### Fiber.refChild\n\n```typescript\ntype Fiber = {\n  refChild: Fiber;\n};\n```\n\n当 Fiber.effectType 为'delete'时将自己的 sibling 标记到 parent 的 refChild 属性，用于 commit effectType:'place'阶段的 insertBefore。\n在 commit effectType:'place'阶段会判断 parent 上的 refChild 属性是否为空，如果为空则表示 create 操作(append)，如果不为空则表示 place 操作(insertBefore)。\n"},{"path":"/blog/React原理/数据结构类型/关于TSX的类型定义.md","title":"关于TSX的类型定义","text":"## JSX 接口\n\n在 global 命名空间中有一个抽象接口 JSX\n\nJSX 接口中的部分类型\n\n```typescript\ndeclare global {\n  namespace JSX {\n    // 标签集合接口，定义了可用的标签类型和对应属性。(需要你实现。)\n    type IntrinsicElements = {};\n    // JSX.Element 接口(需要你实现。)\n    interface Element {}\n    // Children 类型接口，用于对闭合标签中children做类型检查。(需要你实现。)\n    interface ElementChildrenAttribute {}\n  }\n}\n```\n\n#### JSX.IntrinsicElements\n\nJSX 标签集合接口，类似 HTMLElementTagNameMap\n\n```typescript\ndeclare global {\n  namespace JSX {\n    type IntrinsicElements = {\n      view: { bindtap?: Function };\n      richText: { bindtap?: Function };\n      text: { bindtap?: Function };\n      label: { bindtap?: Function };\n      navigator: { bindtap?: Function };\n    };\n  }\n}\n```\n\n在 global::JSX::IntrinsicElements 中实现标签名和对应的属性，然后在.tsx 文件中的 JSX 标签就会有 view、richText 这些的类型提示，并且都提示有一个可选的 bindtap 属性。例如\n\n```typescript\nfunction App() {\n  return (\n    <view>\n      <text bindtap={() => console.log(\"click\")} />\n      <text />\n    </view>\n  );\n}\n```\n\n#### 类型 mapped type\n\n因为都有 bindtap 属性所以可以直接抽离出来，然后使用 mapped type，将 TagNameMap 集合中每个属性的值并入一个 Base 基类型得到一个新的集合类型 IntrinsicElements\n\n> 有点类似 Functor，将`& Base`运算应用到 TagNameMap 范畴中的每个值，然后得到新的范畴 IntrinsicElements\n\n```typescript\n// TagNameMap 范畴\ntype TagNameMap = {\n  view: {};\n  richText: {};\n  text: {};\n  label: {};\n  navigator: {};\n};\n\ntype Base = {\n  bindtap?: Function;\n};\n\ndeclare global {\n  namespace JSX {\n    // IntrinsicElements 范畴\n    type IntrinsicElements = {\n      [Tag in keyof TagNameMap]: TagNameMap[Tag] & Base\n    };\n  }\n}\n```\n\n### JSX.ElementChildrenAttribute\n\n它用来干什么，举个例子 8\n\n就在上面例子基础上扩展\n\n```typescript\ndeclare global {\n  namespace JSX {\n    type IntrinsicElements = {\n      [Tag in keyof TagNameMap]: TagNameMap[Tag] & Base\n    };\n    export interface Element extends Base {}\n    export interface ElementChildrenAttribute {\n      children: any; // JSX标签中子节点即children的类型\n    }\n  }\n}\n```\n\n写一个 Component，子节点是个 function，即 render props 方式渲染\n\n```typescript\nfunction Text({ children }: { children?: (value: number) => JSX.Element }) {\n  return <text>{children(233)}</text>;\n}\n\nfunction App() {\n  return (\n    <view>\n      <text bindtap={() => console.log(\"click\")} />\n      <Text>{value => <text>{value}</text>}</Text>\n    </view>\n  );\n}\n```\n\n<Text/>标签的子节点被约束为(value: number) => JSX.Element 类型，Text Component 内部传给它一个值执行返回 JSX.Element。\nReact 中 Context Customer 就是采用此种方式渲染。\n\n如果去掉 JSX.ElementChildrenAttribute 中 children 的声明，在 App 组件内调用 Text 组件时，Text 组件的子节点类型就会变成 any。所以它的作用就是用于约束 JSX Children 的类型\n\n## 关于 TSX 编译\n\n如果是 jsx 文件，需要给 babel 添加@babel/plugin-transform-react-jsx 插件，并配置 pragma(即 jsxFactory 函数)为你实现的 createElement 函数，例如默认的 React.createElement。\n\n但是现在是 tsx 文件，ts 编译到 js 可以在 tsconfig.json 中配置 compileOptions，可以指定到 target，即具体的 es 版本，和 module 模块规范等。\ntsx 需要配置两个选项：\n\n1. 一个必选的 jsx，如果指定为 react，tsc 会把 tsx 标签编译为 createElement 形式(脱糖编译)，如果指定为 preserve，则保留 jsx 部分不变(不脱糖编译)。如果要使用 Fragment 标签，则 jsx 必须指定为 react。\n\n2. 可选的 jsxFactory，默认为 React.createElement。\n"}]},{"path":"/blog/React原理/浏览器API","title":"浏览器API","children":[{"path":"/blog/React原理/浏览器API/requestIdleCallback方法.md","title":"requestIdleCallback方法","text":"## 简介\n\n这个 API 是 BOM API 之一，即 window.requestIdleCallback，由浏览器实现。在 Node.js 上没有此 API 的实现。\n\n它会在浏览器空闲时期调用注册的函数，即 JS 引擎的空闲时期。\n\n函数签名(由于还处于提案阶段，Typescript 并没有给出函数的声明，所以需要自己 declare 声明函数的签名)\n\n```typescript\ndeclare interface IdleDeadline {\n  readonly didTimeout: boolean;\n  timeRemaining(): number; // 时间片中剩余时间(0 <= timeRemained < 50)\n}\n\ndeclare type IdleOptions = {\n  timeout: number;\n};\n\ndeclare type IdleCallback = (deadline: IdleDeadline) => void;\n\ndeclare function requestIdleCallback(callback: IdleCallback): number;\n\ndeclare function requestIdleCallback(\n  callback: IdleCallback,\n  options: IdleOptions\n): number;\n```\n\n浏览器将时间以每 50ms 切成片，每个时间片内会执行 JS 线程。如果有空余时间，会执行 IdleCallback，并传入一个 deadline 对象，用于获取剩余空闲时间。\n\n## Fiber 相关\n\n此 API 对于 Fiber 调度算法的意义重大，通过判断算法复杂度和 timeRemained 的相对大小决定是否进行调度更新。\n\n在 Fiber 调度逻辑中，requestIdleCallback 用于迭代更新 workInProgress\n\n简化后的逻辑\n\n```typescript\nfunction workLoop(deadline: IdleDeadline) {\n  nextWorkInProgress = performUnitOfWork(nextWorkInProgress);\n\n  if (nextWorkInProgress) {\n    requestIdleCallback(workLoop);\n  }\n}\n\n// 开始调度循环\nrequestIdleCallback(workLoop);\n```\n"}]}]},{"path":"/blog/React基本布局","title":"React基本布局","children":[{"path":"/blog/React基本布局/下拉菜单.md","title":"下拉菜单","text":"### 意义\n\n下拉菜单在很多网站都能见到，鼠标悬浮在导航元素上时会自动弹出子菜单。\n\n好处：\n\n1. 用于导航分类\n2. 可以在有限的视区内展示更多的内容\n\n### DOM 结构\n\n导航的语义化标签为 nav，内容为列表 ul，列表元素水平分布可以利用浮动或者 flex。\n\n例如：\n\n```html\n<nav>\n  <ul>\n    <li>导航1</li>\n    <li>导航2</li>\n    <li>导航3</li>\n  </ul>\n</nav>\n```\n\n下拉菜单也是列表结构，例如：\n\n```html\n<nav>\n  <ul>\n    <li>\n      <a>导航1</a>\n      <ul>\n        <li>导航1-1</li>\n        <li>导航1-2</li>\n        <li>导航1-3</li>\n      </ul>\n    </li>\n    <li>导航2</li>\n    <li>导航3</li>\n  </ul>\n</nav>\n```\n\n> 如果是非自动(hover)弹出可以直接用 HTML5/select & options。\n\n### 响应鼠标事件\n\n1. 在鼠标离开 nav-item 及其所有子元素时，关闭 dropdown menu，对应的 DOM Event 是 mouseleave。(不是 mouseout)\n\n2. 在鼠标进入 nav-item 根元素时，打开 dropdown menu，对应的 DOM Event 是 mouseenter。(比 mouseover 准确)\n\n### Dropdown 的 TSX 结构\n\n列表由数组渲染生成，把 items 看作 Functor，将渲染函数应用到每个元素。即 fmap renderToTSX items。\n\n```ts\ntype Anchor = {\n  name: string\n  href?: string\n}\n\nconst Dropdown = ({ items }: { items: Anchor[] }) => (\n  <ul className=\"head-dropdown\">\n    {items.map(({ name, href }) => (\n      <li>\n        <a href={href}>{name}</a>\n      </li>\n    ))}\n  </ul>\n)\n```\n\n#### 对应的层叠样式表\n\n为了避免因 dropdown menu 动态显示导致 DOM 结构 reflow，所以利用绝对定位让它脱离文档流。\n\n```css\n.head-dropdown {\n  position: absolute;\n  z-index: 999;\n}\n```\n\n### 使用 Hook/useState\n\n因为要动态显示 dropdown menu，所以属于异步的 DOM 操作。使用 setState 来实现。\n\n```ts\ntype NavItemProps = Anchor & {\n  items: Anchor[]\n}\n\nconst NavItem = ({ name, href, items }: NavItemProps) => {\n  const [display, setComponent] = useState(<></>)\n  const visible = () => setComponent(<Dropdown items={items} />)\n  const hidden = () => setComponent(<></>)\n\n  return (\n    <li className=\"nav-item\" onMouseEnter={visible} onMouseLeave={hidden}>\n      <a href={href}>{name}</a>\n      {display}\n    </li>\n  )\n}\n```\n\nnav-item 的层叠样式表。需要兼容 IE10 以下就使用浮动。\n\n```css\n.nav-item {\n  float: left;\n  padding: 0 0.5rem;\n}\n```\n\n### App\n\n```ts\nconst App = () => (\n  <nav>\n    <ul>\n      <NavItem\n        name=\"item1\"\n        items={[\n          { name: \"subitem1\", href: \"#\" },\n          { name: \"subitem2\", href: \"#\" },\n          { name: \"subitem3\", href: \"#\" }\n        ]}\n      />\n    </ul>\n  </nav>\n)\n```\n"}]},{"path":"/blog/React生态","title":"React生态","children":[{"path":"/blog/React生态/React-Redux干了什么.md","title":"React-Redux干了什么","text":"> version: 7.1.0\n\n### 一、状态更新流程\n\n1. 每个 Connect 组件都订阅 Store。(包括 Provider)\n\n> 对于 Provider(组件顶层)，onStateChange 绑定 subscription.notifyNestedSubs\n> 对于下层组件，onStateChange 绑定 checkForUpdates\n> 所以说 store 里只注册了一个监听器，组件们的监听器都在 Provider::subscription 里\n> 然后 Provider 再把 store 和 subscription 建立关联\n\n> https://github.com/reduxjs/react-redux/blob/master/src/components/connectAdvanced.js#L361\n\n2. Connect 组件调用 dispatch，整个 Component 树中每个 Connect 组件都会 checkForUpdates。(即 subscription.onStateChange)\n\n> https://github.com/reduxjs/react-redux/blob/master/src/components/connectAdvanced.js#L309\n\n### 二、核心\n\n1. Provider 将 Store 记录在 ReactReduxContext\n\n> https://github.com/reduxjs/react-redux/blob/master/src/components/Provider.js#L55\n\n2. connect 函数执行 mapXXXToProps 得到 actualChildProps\n\n> https://github.com/reduxjs/react-redux/blob/master/src/components/connectAdvanced.js#L280\n\n> TODO We're reading the store directly in render() here. Bad idea?\n> This will likely cause Bad Things (TM) to happen in Concurrent Mode.\n> Note that we do this because on renders _not_ caused by store updates, we need the latest store state\n> to determine what the child props should be.\n\n这里提到了在执行 mapXXXToProps 时(与组件渲染同步执行)，读取了 Store 中的状态，可能在并发模式下出错，但是 mapXXXToProps 执行需要先拿到 Store 中的 State。所以尽量保证 mapXXXToProps 为纯函数。\n\n然后将 actualChildProps 写入 WrappedComponent 组件 props 渲染。\n\n> https://github.com/reduxjs/react-redux/blob/master/src/components/connectAdvanced.js#L388\n\n读取 Context，订阅 Store。\n\n> subscription 来自 props.context.subscription 或 ReactReduxContext.subscription\n\n> https://github.com/reduxjs/react-redux/blob/master/src/components/connectAdvanced.js#L361\n\n3. 提供了 hooks 对 FunctionComponent 的支持。hooks 从 ReactReduxContext 读取 Store。\n\n> https://github.com/reduxjs/react-redux/blob/master/src/hooks/useReduxContext.js#L22\n\n### 三、优化\n\n1. connectAdvanced 提供 shouldHandleStateChanges 参数，表示组件是否订阅 store。（即是否为纯展示型组件）减少了 batchedUpdates 任务数量。\n\n> https://github.com/reduxjs/react-redux/blob/master/src/components/connectAdvanced.js#L302\n\n2. Connect 组件中获取 actualChildProps 时，如果 Connect 组件接受的 Props 没变化(浅比较)，则直接返回上次 store.dispatch 执行后的 Props，不用再次执行 mapXXXToProps。\n\n> 即相同输入没必要再执行一次，属于 memorization 优化。\n\n> https://github.com/reduxjs/react-redux/blob/master/src/components/connectAdvanced.js#L271\n\n3. Connect 组件中 checkForUpdates 同 shouldComponentUpdate 理，对新旧 props 做了比对。（浅比较）减少 re-render。\n\n> 用了 renderIsScheduled 作为组件更新状态，处理动态改变 shouldHandleStateChanges 引起的渲染丢失情况\n\n> https://github.com/reduxjs/react-redux/blob/master/src/components/connectAdvanced.js#L336\n\n4. 异常处理。在 mapXXXToProps 执行中出现的异常被缓存到 previousStateUpdateResult，并向上传递。针对条件渲染中未显示的组件出现 mapXXXToProps 的错误在 unsubscribeWrapper 中处理。\n\n> https://github.com/reduxjs/react-redux/blob/master/src/components/connectAdvanced.js#L372\n\n> 更多笔记>> https://github.com/Saber2pr/react-opensource-learning\n"},{"path":"/blog/React生态/React生态源码阅读.md","title":"React生态源码阅读","text":"> 知其然知其所以然\n\n项目地址\n\n> https://github.com/Saber2pr/react-opensource-learning\n"},{"path":"/blog/React生态/hoist-non-react-statics源码阅读.md","title":"hoist-non-react-statics源码阅读","text":"> version 3.3.0\n\n这个包意思是重写一个 Object.assgin 专门用于 React Component，在拷贝的过程中能够滤去 React Component 内置的静态属性。只拷贝用户定义的属性。\n\n1. React ClassComponent 上的静态属性\n\n```ts\nconst REACT_STATICS = {\n  childContextTypes: true,\n  contextType: true,\n  contextTypes: true,\n  defaultProps: true,\n  displayName: true,\n  getDefaultProps: true,\n  getDerivedStateFromError: true,\n  getDerivedStateFromProps: true,\n  mixins: true,\n  propTypes: true,\n  type: true\n}\n```\n\n2. 已知的 JS Object & Function 对象内置属性\n\n```ts\nconst KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true\n}\n```\n\n3. FORWARD_REF Component 上的属性\n\n```ts\nconst FORWARD_REF_STATICS = {\n  $$typeof: true,\n  render: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true\n}\n```\n\n4. MEMO Component 上的属性\n\n```ts\nconst MEMO_STATICS = {\n  $$typeof: true,\n  compare: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true,\n  type: true\n}\n\nconst TYPE_STATICS = {}\nTYPE_STATICS[ForwardRef] = FORWARD_REF_STATICS\n```\n\n5. 获取 React Component 对应的静态属性名集合\n\n```ts\n// getStatics: component => Object\nfunction getStatics(component) {\n  if (isMemo(component)) {\n    return MEMO_STATICS\n  }\n  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS\n}\n```\n\n### hoistNonReactStatics\n\n将 sourceComponent 及其父类上的属性拷贝到 targetComponent 上。\n\n> 过滤 JS 对象内置属性，过滤 React Component 内置静态属性\n\n```ts\nexport default function hoistNonReactStatics(\n  targetComponent,\n  sourceComponent,\n  blacklist\n) {\n  if (typeof sourceComponent !== 'string') {\n    // 顺着sourceComponent的原型链将sourceComponent父类的属性也拷贝到targetComponent上\n    // 因为是从class上面找，如果是class实例就不用访问原型链了\n    if (objectPrototype) {\n      const inheritedComponent = getPrototypeOf(sourceComponent)\n      if (inheritedComponent && inheritedComponent !== objectPrototype) {\n        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist)\n      }\n    }\n\n    // keys中存入被assgin组件的属性名集合\n    let keys = getOwnPropertyNames(sourceComponent)\n\n    // keys中存入被assgin组件上的symbol集合\n    if (getOwnPropertySymbols) {\n      keys = keys.concat(getOwnPropertySymbols(sourceComponent))\n    }\n\n    // 获取Component对应的属性名集合\n    const targetStatics = getStatics(targetComponent)\n    const sourceStatics = getStatics(sourceComponent)\n\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i]\n      if (\n        // 过滤掉JS内置属性名\n        !KNOWN_STATICS[key] &&\n        // 过滤掉被黑名单的属性名\n        !(blacklist && blacklist[key]) &&\n        // 过滤掉sourceComponent上有的React Component内置静态属性名\n        !(sourceStatics && sourceStatics[key]) &&\n        // 过滤掉targetComponent上有的React Component内置静态属性名\n        !(targetStatics && targetStatics[key])\n      ) {\n        const descriptor = getOwnPropertyDescriptor(sourceComponent, key)\n        try {\n          defineProperty(targetComponent, key, descriptor)\n        } catch (e) {}\n      } // 完成属性拷贝\n    }\n  }\n\n  return targetComponent\n}\n```\n"},{"path":"/blog/React生态/useSelector和reselect源码阅读.md","title":"useSelector和reselect源码阅读","text":"看看这两个 API 背地里干了什么 (\n\n先说结论\n\n### useSelector 干了什么\n\n> 调用此 Hook API 时会在 store 上注册监听器。\n> 当 Store::state 变化时，组件会 checkForUpdates，利用 equalityFn 判断是否进行更新。\n\n#### 两个 feature:\n\n1. 订阅 Store，当 state 变化时，自动 mapState，返回的 childState 会被渲染到视图上\n2. equalityFn 等效于 shouldComponentUpdate\n\n#### 不足的地方\n\n没有对 selector 函数做 memorize 优化\n\n可以利用 useCallback 优化 selector 吗？\n\n不能。selector 的入参是 Store::State，既然使用了 react-redux 就尽量不要访问 store，而 useCallback 需要 deps，即 Store::State (对于 selector 就是入参)，这里没有办法直接拿到。\n\n解决方案，使用 reselect 对 selector 做 memorize 处理。(对 selector 入参做判断)\n\n### reselect 干了什么\n\n> 对 selector 函数(等效于 mapXXXToProps 函数)做 memorize 优化\n> 如果 selector 的入参没有发生变化，则返回上一次执行的缓存\n\n### 源码细节\n\n#### useSelectorWithStoreAndSubscription\n\n> React-Redux 库中 useSelector 函数的核心部分\n\n```js\n// selector:(storeState) => childState\n// equalityFn: <T>(newChildState:T, oldChildState:T) => boolean\n// useSelectorWithStoreAndSubscription:\n// <T>(selector: (storeState) => T, equalityFn: (newProps:T, oldProps:T) => boolean, ...) => T\n// 对于Provider使用store，下层组件使用contextSub。\nfunction useSelectorWithStoreAndSubscription(\n  selector,\n  equalityFn,\n  store,\n  contextSub\n) {\n  // forceUpdate\n  const [, forceRender] = useReducer(s => s + 1, 0)\n\n  const subscription = useMemo(() => new Subscription(store, contextSub), [\n    store,\n    contextSub\n  ])\n\n  const latestSelector = useRef() // selector的引用\n  const latestSelectedState = useRef() // mapStateToProps之后得到的State的引用\n\n  let selectedState\n\n  // 这里和connectAdvanced中计算actualChildProps的道理一样\n  if (selector !== latestSelector.current) {\n    // selector类似mapStateToProps\n    selectedState = selector(store.getState())\n  } else {\n    // selector没变化，则使用缓存\n    selectedState = latestSelectedState.current\n  }\n\n  useEffect(() => {\n    latestSelector.current = selector\n    latestSelectedState.current = selectedState\n  })\n\n  useEffect(() => {\n    function checkForUpdates() {\n      // 执行selector即mapStateToProps\n      const newSelectedState = latestSelector.current(store.getState())\n\n      // 比较新旧State即 shouldComponentUpdate\n      if (equalityFn(newSelectedState, latestSelectedState.current)) {\n        return // shouldComponentUpdate判断为state没变化 则放弃这次update\n      }\n\n      latestSelectedState.current = newSelectedState\n\n      // forceUpdate\n      forceRender({})\n\n      // 说一下为什么是`force`\n      // setState函数只有传入新的值才会re-render\n      // 例如setState(array.reverse())，这个不会引起update，因为Array.prototype.reverse不纯\n      // 这里强制传入了一个新对象，即setState({})，必定会引起update\n    }\n\n    // checkForUpdates注册到Provider::subscription\n    // 为什么是Provider？请看components/Provider.js\n    // 不严格的讲，也可以说是注册到store listeners里\n    subscription.onStateChange = checkForUpdates\n    subscription.trySubscribe()\n\n    // 初始化selector更新一次\n    checkForUpdates()\n\n    return () => subscription.tryUnsubscribe() // 清理effect。取消订阅\n  }, [store, subscription])\n\n  return selectedState\n}\n```\n\n#### createSelectorCreator\n\n```js\n// memoize: (func, equalityCheck) => (...args) => Result\n// createSelectorCreator: (memorize, ...memoizeOptions) =>\n//   (...inputSelectors, resultFunc) => State => Result\nexport function createSelectorCreator(memoize, ...memoizeOptions) {\n  // funcs: [[inputSelectors], resultFunc]\n  // funcs: [...inputSelectors, resultFunc]\n  return (...funcs) => {\n    let recomputations = 0\n\n    // 拿到funcs中最后一个函数\n    const resultFunc = funcs.pop()\n\n    // funcs: [inputSelectors] | [[inputSelectors]]\n    // dependencies: InputSelector[] = funcs\n    const dependencies = getDependencies(funcs)\n\n    // 得到resultFunc经过memorize优化后的版本\n    const memoizedResultFunc = memoize((...args) => {\n      recomputations++\n      return resultFunc(...args)\n    }, ...memoizeOptions)\n\n    // 每个inputSelector的入参都是相同的\n    // 所以将所有inputSelectors的入参统一起来做memorize优化\n    const selector = memoize((...args) => {\n      const params = []\n      const length = dependencies.length\n\n      for (let i = 0; i < length; i++) {\n        // 遍历每个inputSelector执行\n        // 并将结果收集到params里\n        params.push(dependencies[i](...args))\n      }\n\n      // 将收集到的params传给resultFunc执行\n      // 返回resultFunc执行后的结果\n      return memoizedResultFunc(...params)\n    })\n\n    selector.resultFunc = resultFunc\n    selector.dependencies = dependencies\n    selector.recomputations = () => recomputations\n    selector.resetRecomputations = () => (recomputations = 0)\n    return selector\n  }\n}\n```\n\n源码比较简单，主要看看 memorize 部分\n\n#### defaultMemoize\n\n```js\n// 对函数func进行memorize优化\n// 利用equalityCheck对入参做缓存验证\n// defaultMemoize: (func, equalityCheck) => (...args) => Result\nexport function defaultMemoize(func, equalityCheck = defaultEqualityCheck) {\n  let lastArgs /**: any[] **/ = null\n  let lastResult /**: any[] **/ = null\n  return (...args) => {\n    // 利用比较函数equalityCheck对比lastArgs和args(两个数组)\n    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, args)) {\n      // 如果不一致，则重新执行func\n      lastResult = func(args)\n    }\n\n    // 如果lastArgs和args一致\n    lastArgs = args\n\n    // 返回闭包中的缓存\n    return lastResult\n  }\n}\n\n// 两个数组之间的diff\n// 利用比较函数equalityCheck对比prev和next\n// equalityCheck: (prev: any, next: any) => boolean\n// areArgumentsShallowlyEqual: (equalityCheck, prevs: any[], nexts: any[]) => boolean\nfunction areArgumentsShallowlyEqual(equalityCheck, prev, next) {\n  if (prev === null || next === null || prev.length !== next.length) {\n    return false\n  }\n\n  const length = prev.length\n  for (let i = 0; i < length; i++) {\n    if (!equalityCheck(prev[i], next[i])) {\n      return false\n    }\n  }\n\n  return true\n}\n```\n\n### reselect 中 memorize 的不足\n\n在 reselect 中默认的 memorize 函数依靠闭包来做缓存，缺点是不能记录多次。\n\n怎么才能记录多次呢？举个例子\n\n在 react-router 库中 compilePath 的 memo 优化\n\nhttps://github.com/ReactTraining/react-router/blob/master/packages/react-router/modules/matchPath.js#L4\n\n```js\nconst cache = {}\nconst cacheLimit = 10000 // 缓存最大限制\nlet cacheCount = 0\n\nfunction compilePath(path, options) {\n  const cacheKey = `${options.end}${options.strict}${options.sensitive}`\n  const pathCache = cache[cacheKey] || (cache[cacheKey] = {})\n\n  // memorize优化\n  if (pathCache[path]) return pathCache[path]\n\n  // 省略n多代码...\n}\n```\n\n如果 path 参数有对应的缓存记录，则直接返回缓存。这里可以记录很多次，最大上限是 10k 个不同的 path(实际上不会有这么多的路由)。属于空间换时间的优化策略。\n\n### 如何正确使用 useSelector\n\n首先知道，使用了 useSelector 的组件就会订阅 store（useSelector 是 connect 函数的替代品）。useSelector 第二个参数相当于 shouldComponentUpdate。\n\n使用了 useSelector 得到的返回值需要通过调用 dispatch 来更新。(参见 useDispatch)\n\n然后，useSelector 不会避免 selector 函数重复执行。需要使用 reselect 库对 selector 函数做优化。\n"}]},{"path":"/blog/Redux状态管理","title":"Redux状态管理","children":[{"path":"/blog/Redux状态管理/applyMiddleware.md","title":"applyMiddleware","text":"### applyMiddleware源码阅读\n\n如果是TS代码就好理解了。\n\n> enhancer强行花里胡哨。看createStore中对enhancer的处理，递归createStore然后滤去enhancer参数。\n\n> 为什么不把createStore和Store的逻辑实现分离开呢？\n\n```ts\n// applyMiddleware: (middlewares) => enhancer\n// enhancer: createStore => (reducer, preloadedState) => Store\nexport default function applyMiddleware(...middlewares) {\n  // createStore: (reducer, preloadedState, enhancer) => Store\n  return createStore => (...args) => {\n    const store = createStore(...args)\n    // 设置dispatch默认值。不允许在middleware执行的时候调用dispatch。一个中间件不允许有这种权利。\n    let dispatch = () => {\n      throw new Error(\n        'Dispatching while constructing your middleware is not allowed. ' +\n          'Other middleware would not be applied to this dispatch.'\n      )\n    }\n\n    const middlewareAPI = {\n      getState: store.getState,\n      dispatch: (...args) => dispatch(...args)\n    }\n\n    // 给每个中间件传入middlewareAPI\n    // 得到chain: Array<(dispatch) => (action) => any>\n    const chain = middlewares.map(middleware => middleware(middlewareAPI))\n    // compose chain然后传入dispatch，返回dispatch: (action) => any\n    dispatch = compose(...chain)(store.dispatch)\n\n    // 返回加强后的store\n    return {\n      ...store,\n      dispatch\n    }\n  }\n}\n```"},{"path":"/blog/Redux状态管理/bindActionCreators.md","title":"bindActionCreators","text":"### bindActionCreators源码阅读\n\n> 删掉了很多非核心代码。稍微重构了下。保留清晰的核心逻辑。\n\n```ts\nfunction bindActionCreator(actionCreator, dispatch) {\n  return (...args) => dispatch(actionCreator(args))\n}\n\nexport default function bindActionCreators(actionCreators, dispatch) {\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch)\n  }\n\n  return Object.keys(actionCreators).reduce((boundActionCreators, key) => {\n    boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)\n    return boundActionCreators\n  }, {})\n}\n```\n\n貌似一眼康不出它想要做什么。\n\n这里有一个好康的Demo。\n\n```ts\nconst TodoActionCreators = {\n  addTodo: text => ({type: 'ADD_TODO', text}),\n  removeTodo: text => ({type: 'REMOVE_TODO', text})\n} as const\n\nboundActionCreators = bindActionCreators(TodoActionCreators, store.dispatch)\n```\n\nbindActionCreators遍历TodoActionCreators中每个actionCreator，将它们封装了一层。\n\nbindActionCreator返回了新的actionCreator，接受参数自动dispatch。"},{"path":"/blog/Redux状态管理/combineReducers.md","title":"combineReducers","text":"### combineReducers\n\n> 这是我实现的版本。\n\n```ts\nexport interface Action<T = any> {\n  type: T\n}\n\nexport interface AnyAction extends Action {\n  [extraProps: string]: any\n}\n\nexport type ReducersMapObject<S, A extends Action = AnyAction> = {\n  [K in keyof S]: Reducer<S[K], A>\n}\n\nexport const combineReducers = <S, A extends Action = AnyAction>(\n  reducers: ReducersMapObject<S, A>\n) => (state: S, action: A) =>\n  (Object.keys(reducers) as (keyof S)[]).reduce(\n    (nextState, key) =>\n      Object.assign(nextState, {\n        [key]: reducers[key](state[key], action)\n      }),\n    {} as S\n  )\n```\n\nimport * as reducer这句代码会构造如下对象\n\n```ts\ntype Reducers = { readonly [reducer: string]: (s: State, a: Action) => State }\n```\n\n> 注意到readonly\n\n使用Object.keys或者Object.entries遍历每个reducer，并输入state[reducer.name]和action。生成新的State返回。\n\n#### redux中实现的combineReducers\n\n```js\nexport default function combineReducers (reducers) {\n  const reducerKeys = Object.keys(reducers)\n  const finalReducers = {}\n\n  // 从reducers中过滤出function。因为reducers是import * as reducers来的\n  for (let i = 0; i < reducerKeys.length; i++) {\n    const key = reducerKeys[i]\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key]\n    }\n  }\n  // 拿到reducers名称集合\n  const finalReducerKeys = Object.keys(finalReducers)\n\n  return (state = {}, action) => {\n    let hasChanged = false\n    const nextState = {}\n\n    for (let i = 0; i < finalReducerKeys.length; i++) {\n      const key = finalReducerKeys[i]\n      // 拿到key对应的reducer和state\n      const reducer = finalReducers[key]\n      const previousStateForKey = state[key]\n\n      const nextStateForKey = reducer(previousStateForKey, action)\n\n      nextState[key] = nextStateForKey\n      // 浅比较新旧state\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n    }\n\n    // 是否有reducer动态增删\n    hasChanged =\n      hasChanged || finalReducerKeys.length !== Object.keys(state).length\n\n    // 如果state没有变化，则直接返回\n    return hasChanged ? nextState : state\n  }\n}\n\n```"},{"path":"/blog/Redux状态管理/compose.md","title":"compose","text":"### compose\n\n函数式编程喜闻乐见的组合函数。来看看redux作者是怎么实现它的。\n\n```ts\nexport default function compose(...funcs) {\n  if (funcs.length === 0) return arg => arg\n  if (funcs.length === 1) return funcs[0]\n  return funcs.reduce((a, b) => (...args) => a(b(...args)))\n}\n```\n\n当然也可以实现为\n\n```ts\nexport function compose(...fns: Array<(...value: any) => any>) {\n  return (value: any) => fns.reverse().reduce((a, b) => b(a), value)\n}\n```\n\n区别就是 是否允许funcs[0]多参数。因为compose的前提是curry后的函数。\n\n上面TS实现的compose非常糟糕。都是any。\n\n如果你看过redux或是rambda等函数式库的d.ts文件，你可能会感到绝望。\n\ncompose的类型是这样的\n\n> 前方高能\n\n```ts\nexport function compose<T1>(fn0: () => T1): () => T1\nexport function compose<V0, T1>(fn0: (x0: V0) => T1): (x0: V0) => T1\nexport function compose<V0, V1, T1>(\n  fn0: (x0: V0, x1: V1) => T1\n): (x0: V0, x1: V1) => T1\nexport function compose<V0, V1, V2, T1>(\n  fn0: (x0: V0, x1: V1, x2: V2) => T1\n): (x0: V0, x1: V1, x2: V2) => T1\n\nexport function compose<T1, T2>(fn1: (x: T1) => T2, fn0: () => T1): () => T2\nexport function compose<V0, T1, T2>(\n  fn1: (x: T1) => T2,\n  fn0: (x0: V0) => T1\n): (x0: V0) => T2\nexport function compose<V0, V1, T1, T2>(\n  fn1: (x: T1) => T2,\n  fn0: (x0: V0, x1: V1) => T1\n): (x0: V0, x1: V1) => T2\nexport function compose<V0, V1, V2, T1, T2>(\n  fn1: (x: T1) => T2,\n  fn0: (x0: V0, x1: V1, x2: V2) => T1\n): (x0: V0, x1: V1, x2: V2) => T2\n\nexport function compose<T1, T2, T3>(\n  fn2: (x: T2) => T3,\n  fn1: (x: T1) => T2,\n  fn0: () => T1\n): () => T3\nexport function compose<V0, T1, T2, T3>(\n  fn2: (x: T2) => T3,\n  fn1: (x: T1) => T2,\n  fn0: (x: V0) => T1\n): (x: V0) => T3\nexport function compose<V0, V1, T1, T2, T3>(\n  fn2: (x: T2) => T3,\n  fn1: (x: T1) => T2,\n  fn0: (x0: V0, x1: V1) => T1\n): (x0: V0, x1: V1) => T3\nexport function compose<V0, V1, V2, T1, T2, T3>(\n  fn2: (x: T2) => T3,\n  fn1: (x: T1) => T2,\n  fn0: (x0: V0, x1: V1, x2: V2) => T1\n): (x0: V0, x1: V1, x2: V2) => T3\n\nexport function compose<T1, T2, T3, T4>(\n  fn3: (x: T3) => T4,\n  fn2: (x: T2) => T3,\n  fn1: (x: T1) => T2,\n  fn0: () => T1\n): () => T4\nexport function compose<V0, T1, T2, T3, T4>(\n  fn3: (x: T3) => T4,\n  fn2: (x: T2) => T3,\n  fn1: (x: T1) => T2,\n  fn0: (x: V0) => T1\n): (x: V0) => T4\nexport function compose<V0, V1, T1, T2, T3, T4>(\n  fn3: (x: T3) => T4,\n  fn2: (x: T2) => T3,\n  fn1: (x: T1) => T2,\n  fn0: (x0: V0, x1: V1) => T1\n): (x0: V0, x1: V1) => T4\nexport function compose<V0, V1, V2, T1, T2, T3, T4>(\n  fn3: (x: T3) => T4,\n  fn2: (x: T2) => T3,\n  fn1: (x: T1) => T2,\n  fn0: (x0: V0, x1: V1, x2: V2) => T1\n): (x0: V0, x1: V1, x2: V2) => T4\n\nexport function compose<T1, T2, T3, T4, T5>(\n  fn4: (x: T4) => T5,\n  fn3: (x: T3) => T4,\n  fn2: (x: T2) => T3,\n  fn1: (x: T1) => T2,\n  fn0: () => T1\n): () => T5\nexport function compose<V0, T1, T2, T3, T4, T5>(\n  fn4: (x: T4) => T5,\n  fn3: (x: T3) => T4,\n  fn2: (x: T2) => T3,\n  fn1: (x: T1) => T2,\n  fn0: (x: V0) => T1\n): (x: V0) => T5\nexport function compose<V0, V1, T1, T2, T3, T4, T5>(\n  fn4: (x: T4) => T5,\n  fn3: (x: T3) => T4,\n  fn2: (x: T2) => T3,\n  fn1: (x: T1) => T2,\n  fn0: (x0: V0, x1: V1) => T1\n): (x0: V0, x1: V1) => T5\nexport function compose<V0, V1, V2, T1, T2, T3, T4, T5>(\n  fn4: (x: T4) => T5,\n  fn3: (x: T3) => T4,\n  fn2: (x: T2) => T3,\n  fn1: (x: T1) => T2,\n  fn0: (x0: V0, x1: V1, x2: V2) => T1\n): (x0: V0, x1: V1, x2: V2) => T5\n\nexport function compose<T1, T2, T3, T4, T5, T6>(\n  fn5: (x: T5) => T6,\n  fn4: (x: T4) => T5,\n  fn3: (x: T3) => T4,\n  fn2: (x: T2) => T3,\n  fn1: (x: T1) => T2,\n  fn0: () => T1\n): () => T6\nexport function compose<V0, T1, T2, T3, T4, T5, T6>(\n  fn5: (x: T5) => T6,\n  fn4: (x: T4) => T5,\n  fn3: (x: T3) => T4,\n  fn2: (x: T2) => T3,\n  fn1: (x: T1) => T2,\n  fn0: (x: V0) => T1\n): (x: V0) => T6\nexport function compose<V0, V1, T1, T2, T3, T4, T5, T6>(\n  fn5: (x: T5) => T6,\n  fn4: (x: T4) => T5,\n  fn3: (x: T3) => T4,\n  fn2: (x: T2) => T3,\n  fn1: (x: T1) => T2,\n  fn0: (x0: V0, x1: V1) => T1\n): (x0: V0, x1: V1) => T6\nexport function compose<V0, V1, V2, T1, T2, T3, T4, T5, T6>(\n  fn5: (x: T5) => T6,\n  fn4: (x: T4) => T5,\n  fn3: (x: T3) => T4,\n  fn2: (x: T2) => T3,\n  fn1: (x: T1) => T2,\n  fn0: (x0: V0, x1: V1, x2: V2) => T1\n): (x0: V0, x1: V1, x2: V2) => T6\n```\n\n我相信你已经没有动力想要搞清楚它了。\n\n不过我写一个例子，你应该能从中找到为什么会变成上面这个样子的原因。\n\n```ts\n// 二元运算compose\nconst compose: <A, R1, R2>(\n  f2: (a: R1) => R2,\n  f1: (a: A) => R1\n) => (a: A) => R2 = (f2, f1) => a => f2(f1(a));\n\n// 三元运算compose\nconst compose: <A, R1, R2, R3>(\n  f3: (a: R2) => R3,\n  f2: (a: R1) => R2,\n  f1: (a: A) => R1\n) => (a: A) => R3 = (f3, f2, f1) => a => f3(f2(f1(a)));\n```"},{"path":"/blog/Redux状态管理/createStore.md","title":"createStore","text":"### createStore源码阅读\n\n> 删掉了很多非核心代码。稍微重构了下。保留清晰的核心逻辑。\n\n```ts\nexport default function createStore (reducer, preloadedState, enhancer) {\n  // 如果有中间件，则应用加强\n  if (typeof enhancer !== 'undefined') {\n    return enhancer(createStore)(reducer, preloadedState)\n  }\n\n  let currentReducer = reducer\n  let currentState = preloadedState\n  const currentListeners = [] // 订阅者列表\n\n  const getState = () => currentState\n\n  function subscribe (listener) {\n    currentListeners.push(listener)\n    return () => currentListeners.splice(currentListeners.indexOf(listener), 1)\n  }\n\n  function dispatch (action) {\n    currentState = currentReducer(currentState, action)\n    currentListeners.forEach(l => l())\n    return action\n  }\n\n  function replaceReducer (nextReducer) {\n    currentReducer = nextReducer\n    dispatch({ type: ActionTypes.REPLACE })\n  }\n\n  // observable，当store state变化时自动通知observer\n  // 就是subscribe: observer => store.subscribe(() => observer.next(store.getState()))\n  // 相当于一个语法糖\n  function observable () {\n    const outerSubscribe = subscribe\n    return {\n      subscribe (observer) {\n        const observeState = () => observer.next && observer.next(getState())\n        observeState()\n        const unsubscribe = outerSubscribe(observeState)\n        return { unsubscribe }\n      },\n\n      [$$observable] () {\n        return this\n      }\n    }\n  }\n\n  dispatch({ type: ActionTypes.INIT })\n\n  return {\n    dispatch,\n    subscribe,\n    getState,\n    replaceReducer,\n    [$$observable]: observable\n  }\n}\n```\n\n就是个观察者模式很容易理解，不多说了。"},{"path":"/blog/Redux状态管理/redux-thunk.md","title":"redux-thunk","text":"### thunk异步Action中间件源码阅读\n\n```ts\nfunction createThunkMiddleware(extraArgument) {\n  // thunkMiddleware: middlewareAPI => dispatch => action => any\n  return ({ dispatch, getState }) => next => action => {\n    // 如果是异步action\n    if (typeof action === 'function') {\n      return action(dispatch, getState, extraArgument);\n    }\n\n    return next(action);\n  };\n}\n```\n\n就是判断了下action的类型，如果是function，就传dispatch和getState进去。\n\n> 中间件只能处理下dispatch和action"},{"path":"/blog/Redux状态管理/redux思想.md","title":"redux思想","text":"关于redux只要把握三大原则就够了。至于怎么实现那是你的事情。\n\n## Redux 三大原则\n\n#### 单一数据源\n\n其实是想说使用观察者模式实现。\n\n#### State 是只读的\n\nimmutable。\n\n#### 使用纯函数来执行修改\n\n强调了纯函数\n\n### 本质\n\nsubscription + immutable + pure-function 这些东西综合起来你会想到什么？\n\n没错，就是 能够处理side-effect的函数式编程 思想！\n\nside-effect(副作用)在redux中由subscriptions处理，纯的函数被叫做reducer，能够将state变换成另一个state。(想到了什么？)\n\n```ts\nState1 {                State2 {\n  name   -> reducer1 ->   name\n  age    -> reducer2 ->   age\n}                       }\n\nState1   -> reducer  -> State2\n```\n\n那么Store不就是Functor吗？dispatch就是fmap，dispatch将reducer应用到State变成另一个State。\n\n至于action完全是可有可无的东西。\n\n#### Store是Monad吗？\n\nMonad 需要实现两个运算，>>= 和 return。\n\nStore.getState就是return。(对自己的state进行pure)\n\n> 假设 Store.dispatch :: Monad m => (State -> m State) -> m State\n\n> 以下为伪代码\n\nStore >>= (\\state -> return state) == Store \n\n应该有 Store.dispatch(_ => Store.getState()) == Store\n\n运算符>>=用来串联一系列的IO操作，在redux中IO操作在subscriptions中处理，通过调用dispatch触发IO操作。\n\n问题是dispatch是同步执行，所以你不能在reducer中去调用dispatch(会死循环)。\n\n在JS中可以利用microtask来干这个事情。具体请看Promise原理。\n"}]},{"path":"/blog/Reflect反射原理","title":"Reflect反射原理","children":[{"path":"/blog/Reflect反射原理/reflect-metadata中HashMap巨大Object的读取速度优化.md","title":"reflect-metadata中HashMap巨大Object的读取速度优化","text":"HashMap 原理比较复杂，不是这篇文章重点。(其实是本菜鸡不懂(\n\nreflect-metadata 中实现了 HashMap 的 polyfill，需要能快速读取数据，而 js 的 Object 当属性很多的时候性能并不好，不然就不会有 Map 了。然而 reflect-metadata 中 HashMap 用的是 Dictionary，利用了一个非常 hack 的方法。\n\nHashMap\n\n```typescript\ntype HashMap<V> = Record<string, V>;\n\nconst HashMap = {\n  // create an obj into dictionary mode (a.k.a. \"slow\" mode on v8)\n  create: <V>() => MakeDictionary(Object.create(null) as HashMap<V>),\n\n  has: <V>(map: HashMap<V>, key: string | number | symbol) =>\n    Object.prototype.hasOwnProperty.call(map, key),\n\n  get: <V>(map: HashMap<V>, key: string | number | symbol): V | undefined =>\n    Object.prototype.hasOwnProperty.call(map, key)\n      ? map[key as string | number]\n      : undefined\n};\n```\n\n好像有点简单啊，除了有个 MakeDictionary 函数\n\n在 reflect-metadata 源码中最后有一个 MakeDictionary 函数，来看看这个神奇的函数\n\nMakeDictionary\n\n```typescript\n// uses a heuristic used by v8 and chakra to force an obj into dictionary mode.\nfunction MakeDictionary<T>(obj: T): T {\n  (<any>obj).__ = undefined;\n  delete (<any>obj).__;\n  return obj;\n}\n```\n\n它给 obj 添加了\\_\\_属性，值为 undefined，然后又删了，注释解释说这可以启发 v8 或者査克拉引擎将 Object 转换到 dictionary mode（？？），可以大幅提升 Object 属性读取的速度？\n\n下面来测试一下（Node 环境）\n\n先写一个 fill 函数，用来填充属性\n\n```typescript\nfunction fillSomething(obj: Object, size: number = 100000) {\n  while (size--) obj[size] = Math.random();\n}\n```\n\n测试一下读取速度\n\n```typescript\n// 普通obj\nconst obj = {};\n// 填充100000个随机属性\nfillSomething(obj);\n\nconsole.time(\"obj\");\nconsole.log(obj[\"5555\"]);\nconsole.timeEnd(\"obj\"); // obj 2.813ms\n\n// 创建一个hashMap\nconst hashMap = HashMap.create();\n// 填充100000个随机属性\nfillSomething(hashMap);\n\nconsole.time(\"hashMap\");\nconsole.log(HashMap.get(hashMap, \"5555\"));\nconsole.timeEnd(\"hashMap\"); // hashMap 0.398ms\n```\n\n足足快了 30 多倍？\n\n真假？。。其实把上面两个 time 顺序颠倒也不是这么回事，但出自 rbuckton 大神之手应该不是随便写的\n\n所以以后遇到巨大 Object 的时候不妨用此方法优化一下试试。\n"},{"path":"/blog/Reflect反射原理/reflect-metadata实现及其原理.md","title":"reflect-metadata实现及其原理","text":"最近研究了一下 reflect 机理，基本算是实现了所有的 api，也通过了全部的测试用例，所以想写一篇文章记录下来。\n\nps: 这篇文章最先发在我的知呼上：https://zhuanlan.zhihu.com/p/65239993\n\nReflect Metadata 是 ES7 的一个提案，它主要用来在声明的时候添加和读取元数据。Typescript 使用反射需要安装一个依赖 reflect-metadata.\n\nTypescript 拥有完整的面向对象支持，依赖注入技术(DI)已经在 Angular、Nest 等框架中大规模使用了，就像这样\n\n```typescript\nclass Service {}\n\nclass Controller {\n  constructor(private Service: Service) {}\n}\n```\n\nIOC 框架会获取到 Controller 所依赖的类，并注入一个实例或类本身，这其中获取依赖类型就会利用到 Reflect。\n\n利用元数据设计键(Design-time type annotations)来获取依赖类型\n\n```typescript\nfunction Injectable(): ClassDecorator {\n  return target => {\n    const metadata = Reflect.getMetadata(\"design:paramtypes\", target);\n    console.log(metadata);\n  };\n}\n\nclass Service {\n  constructor() {}\n}\n\n@Injectable() // 输出 [ Service() ]\nclass Controller {\n  constructor(private Service: Service) {}\n}\n```\n\n这里需要利用装饰器来获取。这里也许你会有疑问，元数据需要先 defineMetadata 然后在 getMetadata 获取，这里为什么可以直接获取?\n\n答案就是如果 tsconfig 开启了 emitDecoratorMetadata 为 true，编译器会发出设计元数据信息。\n\n来看下 ts 编译后的 js (已开启 emitDecoratorMetadata)\n\n```typescript\n// 判断一下Reflect上是否有metadata函数，并赋给__metadata\nvar __metadata =\n  (this && this.__metadata) ||\n  function(k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\n      return Reflect.metadata(k, v);\n  };\n\nvar Service = /** @class */ (function() {\n  function Service() {}\n  return Service;\n})();\n\nvar Controller = /** @class */ (function() {\n  function Controller(Service) {\n    this.Service = Service;\n  }\n  Controller = __decorate(\n    [\n      Injectable(),\n      // 注意这里，使用design-paramtypes键定义了元数据，值是[Service]\n      __metadata(\"design:paramtypes\", [Service])\n    ],\n    Controller\n  );\n  return Controller;\n})();\n\nfunction Injectable() {\n  return function(target) {\n    Reflect.getMetadata(\"design:paramtypes\", target);\n  };\n}\n```\n\n开启了 emitDecoratorMetadata 编译器会自动生成 Design-time type annotations。\n\n通过前面的实例，容易发现，Reflect 内部应该会维护一个 Map，而且应该是 WeakMap，\n\n果不其然，在 reflect-metadata 这个库内部使用了 WeakMap，而且居然还自带了 Polyfill(不仅实现 WeakMap，还有 HashMap...)\n\n[[Metadata]] internal slot\n\nhttps://github.com/rbuckton/reflect-metadata/blob/master/Reflect.ts#L685\n\nnaive WeakMap shim\n\nhttps://github.com/rbuckton/reflect-metadata/blob/master/Reflect.ts#L1725\n\n下面开始实现。\n\n实现 Reflect.defineMetadata\n\n首先创建一个 WeakMap，它将负责维护所有类和类实例的元数据，以及解决自动回收问题。\n\n```typescript\nconst Metadata = new WeakMap<Object, Map<PropertyKey, MetadataMap>>();\n```\n\n这是一个高维的 Map，对于每个 Object 也就是类或者类实例，它都关联一个 Map。这个 Map 里又关联了属性 key 和属性所对应的 Map，所以又是一个高维的 Map。所以这个 Metadata 就是一个 3 维的 Map。\n\n```typescript\nexport function defineMetadata(\n  metadataKey: MetadataKey,\n  metadataValue: MetadataValue,\n  target: Object,\n  propertyKey: PropertyKey = DEFAULTKAY\n) {\n  // 判断target类型，因为target将作为WeakMap的键，必须是对象类型\n  if (typeof target !== \"object\" && typeof target !== \"function\") {\n    throw new TypeError();\n  }\n\n  // 如果传入propertyKey，要求类型为string或symbol\n  if (propertyKey && ![\"string\", \"symbol\"].includes(typeof propertyKey)) {\n    throw new TypeError();\n  }\n\n  // 从Metadata中获取target关联的Map，若没有就创建一个新的Map\n  const targetMetadata =\n    Metadata.get(target) || new Map<PropertyKey, MetadataMap>();\n\n  // 将targetMetadata再保存回Metadata中\n  Metadata.set(target, targetMetadata);\n\n  // 从targetMetadata中获取propertyKey关联的Map，若没有就创建一个新的Map\n  const metadataMap: MetadataMap = targetMetadata.get(propertyKey) || new Map();\n\n  // 将metadataMap再保存回targetMetadata中\n  targetMetadata.set(propertyKey, metadataMap);\n\n  // 设置元数据到metadataMap，键为metadataKey，值metadataValue\n  metadataMap.set(metadataKey, metadataValue);\n}\n```\n\n实现 Reflect.getMetadata\n\n这个 api 会依赖 getMetadataMap、getOwnMetadataMap。所以先倒着来实现\n\n1. getOwnMetadataMap\n\n```typescript\nexport function getOwnMetadataMap(\n  target: Object,\n  propertyKey: PropertyKey = DEFAULTKAY\n) {\n  // 判断target类型，因为target将作为WeakMap的键，必须是对象类型\n  if (typeof target !== \"object\" && typeof target !== \"function\") {\n    throw new TypeError();\n  }\n\n  // 从Metadata中获取target关联的Map，如果没有就返回undefined\n  const targetMetadata = Metadata.get(target);\n  if (!targetMetadata) return;\n\n  // 从targetMetadata中获取propertyKey关联的Map，如果没有就返回undefined\n  const metadataMap = targetMetadata.get(propertyKey);\n  if (!metadataMap) return;\n\n  // 返回metadataMap\n  return metadataMap;\n}\n```\n\n2. getMetadataMap\n\n获取 target 及其原型上的元数据 Map，对于同一个 propertyKey，自身的 metadataMap 覆盖原型的 metadataMap\n\n```typescript\nexport function getMetadataMap(\n  target: Object,\n  propertyKey: PropertyKey = DEFAULTKAY\n) {\n  // 如果自身有了propertyKey对应的map\n  if (Boolean(getOwnMetadataMap(target, propertyKey))) {\n    return getOwnMetadataMap(target, propertyKey);\n  }\n\n  // 去原型上找propertyKey对应的map，如果没有就返回undefined\n  const targetMetadata = Metadata.get(Object.getPrototypeOf(target));\n  if (!targetMetadata) return;\n\n  // 从targetMetadata中获取propertyKey关联的Map，如果没有就返回undefined\n  const metadataMap = targetMetadata.get(propertyKey);\n  if (!metadataMap) return;\n\n  // 返回metadataMap\n  return metadataMap;\n}\n```\n\n实现 getMetadata\n\n利用 getMetadataMap 拿到 target 关联的 metadataMap，然后根据 metadataKey 获取对应的 metadataValue\n\n```typescript\nexport function getMetadata<T>(\n  metadataKey: MetadataKey,\n  target: Object,\n  propertyKey?: PropertyKey\n): T {\n  // 根据propertyKey获取target的metadataMap，如果没有就返回undefined\n  const metadataMap = getMetadataMap(target, propertyKey);\n  if (!metadataMap) return;\n\n  // 返回metadataKey对应的metadataValue\n  return metadataMap.get(metadataKey);\n}\n```\n\n同样的还有 getOwnMetadata，只需要考虑 getOwnMetadataMap 就可以了\n\n实现 Reflect.getMetadataKeys\n\n用来获取 target 身上的所有元数据键\n\n它会依赖 getOwnMetadataKeys，所以先实现 getOwnMetadataKeys\n\n实现 getOwnMetadataKeys\n\n获取 target 自身的所有元数据键\n\n```typescript\nexport function getOwnMetadataKeys(\n  target: Object,\n  propertyKey?: PropertyKey\n): MetadataKey[] {\n  // 获取target身上与propertyKey关联的metadataMap，若没有返回空数组\n  const metadataMap = getOwnMetadataMap(target, propertyKey);\n  if (!metadataMap) return [];\n\n  // metadataMap转为数组并返回\n  return Array.from(metadataMap.keys());\n}\n```\n\n实现 getMetadataKeys\n\n获取自身的 metadataKeys，获取原型的 metadataKeys，合并后返回\n\n```typescript\nexport function getMetadataKeys(\n  target: Object,\n  propertyKey?: PropertyKey\n): MetadataKey[] {\n  // 获取target自身与propertyKey关联的metadataKeys\n  const ownKeys = getOwnMetadataKeys(target, propertyKey);\n\n  // 获取target原型与propertyKey关联的metadataKeys\n  const protoKeys = getOwnMetadataKeys(\n    Object.getPrototypeOf(target),\n    propertyKey\n  );\n\n  // 返回结果\n  return [...ownKeys, ...protoKeys];\n}\n```\n\n实现 Reflect.hasMetadata\n\n用来判断 target 上是否有对应的 metadataKey\n\n注意是判断有无 key，而不是有无 value，所以不能等价 Boolean(getMetadata)，因为 metadataValue 可以是 null 和 undefined 等值。测试用例对这里做了大量的 test。\n\n```typescript\nexport function hasMetadata(\n  metadataKey: MetadataKey,\n  target: Object,\n  propertyKey?: PropertyKey\n) {\n  const metadataKeys = getMetadataKeys(target, propertyKey);\n  return metadataKeys.includes(metadataKey);\n}\n```\n\n这个很简单，没什么好说的\n\n同样还有 hasOwnMetadata，利用 getOwnMetadataKeys 就 ok\n\n实现 Reflect.deleteMetadata\n\n```typescript\nexport function deleteMetadata(\n  metadataKey: MetadataKey,\n  target: Object,\n  propertyKey?: PropertyKey\n) {\n  const metadataMap = getOwnMetadataMap(target, propertyKey);\n  if (!metadataMap) return false;\n\n  return metadataMap.delete(metadataKey);\n}\n```\n\n实现 Reflect.decorate\n\n这个可以从测试用例上获取思路\n\n```typescript\n// reflect-decorate.test.ts\n\nit(\"DecoratorCorrectTargetInPipelineForFunctionOverload\", () => {\n  let sent: Function[] = [];\n  let A = function A(): void {};\n  let B = function B(): void {};\n  let decorators = [\n    (target: Function): any => {\n      sent.push(target);\n      return undefined;\n    },\n    (target: Function): any => {\n      sent.push(target);\n      return undefined;\n    },\n    (target: Function): any => {\n      sent.push(target);\n      return A;\n    },\n    (target: Function): any => {\n      sent.push(target);\n      return B;\n    }\n  ];\n  let target = function(): void {};\n  Reflect.decorate(decorators, target);\n  expect(sent).toEqual([target, B, A, A]);\n});\n```\n\n测试中给出的 decorators 是 4 个箭头函数的数组，把 target 参数 push 到 sent 里，然后返回一个结果\n\n要求是 Reflect.decorate 执行后，sent 是[target, B, A, A]\n\n再结合测试用例的 name 分析，看到了管道(Pipeline)，那应该会想到 reduce 而且是 reduceRight。\n\ntarget 就是 initialValue，decorators 就是 reducers。\n\ndecorate\n\n有点类型 redux 的样子，target 就是 state，decorators 就是 reducers\n\n```typescript\nexport function decorate(\n  decorators: (PropertyDecorator | MethodDecorator)[],\n  target: Object | Function,\n  propertyKey?: string | symbol,\n  attributes?: PropertyDescriptor\n): PropertyDescriptor {\n  // 如果decorators是空数组则抛出TypeError\n  if (0 === decorators.length) {\n    throw new TypeError();\n  }\n\n  // target作为initialValue，遍历decorators，将上一个decorator的结果作为target传给下一个decorator\n  return decorators.reduceRight(\n    (target, decorator) => decorator(target, propertyKey, attributes) || target,\n    <any>target\n  );\n}\n```\n\n确定 Reflect 的 type 以及混入原生 Reflect\n\n为了避免类型冲突，首先需要给原生 Reflect 的 type 起个别名，就叫 IReflect 吧\n\n```typescript\nexport type IReflect = typeof Reflect;\nexport const reflect = Reflect;\n```\n\n然后混入 Reflector\n\n```typescript\nexport const Reflect: typeof Reflector & IReflect = Object.assign(\n  reflect,\n  Reflector\n);\n```\n\n因为原生 Reflect 对象的属性不可枚举，所以只能往原生 reflect 合并\n\nps: 之前我写的 IOC 框架依赖的 reflect-metadata 也换成了现在实现的这个版本，demo 也能跑起来，感觉还不错。\n\nSaber2pr/saber-ioc\n\nhttps://github.com/Saber2pr/saber-ioc\n\nGithub\n\n@saber2pr/reflect\n\nhttps://github.com/Saber2pr/-saber2pr-reflect\n"},{"path":"/blog/Reflect反射原理/依赖注入(IOC)实现.md","title":"依赖注入(IOC)实现","text":"## 实现 reflect-metadata\n\n1. 首先说明要干什么。\n   实现一个存放类的容器，并能按照类之间依赖关系自动构建实例。\n\n2. 核心原理：\n\n利用 Reflect-metadata 获取构造函数中的参数类型(design:paramtypes)。\n利用 Reflect-metadata 在目标对象上定义和获取元数据。\n\n先举个例子：\n\n```typescript\nclass Service {\n  constructor() {}\n}\n\nclass Controller {\n  constructor(private Service: Service) {}\n}\n```\n\n一个 Service 类，一个 Controller 类，其中 Controller 类依赖于 Service 类。\n\n利用 Reflect 可以轻松获取 Controller 类构造函数中的 paramtypes。\n\n## 实现@Injectable\n\n> Injectable 函数返回一个类装饰器，利用反射获取被装饰类的构造函数的参数类型。\n\n先举个栗子\n\n```typescript\nconst enum DESIGN {\n  PARAMTYPES = \"design:paramtypes\"\n}\n\nfunction Injectable(): ClassDecorator {\n  return target => {\n    // 获取被装饰类的构造函数的参数类型\n    const ctorParams: any[] = Reflect.getMetadata(DESIGN.PARAMTYPES, target);\n    console.log(ctorParams);\n  };\n}\n```\n\n利用设计键获取到参数列表：\n\n```typescript\nclass Service {\n  constructor() {}\n}\n\n@Injectable() // Array [ Service() ]\nclass Controller {\n  constructor(private Service: Service) {}\n}\n```\n\n## @Injectable\n\n```typescript\nexport function Injectable(id?: PropertyKey): ClassDecorator {\n  return target => {\n    // 索引键值默认为target.name\n    const token = id || target.name;\n\n    // 如果token已存在则抛出Error\n    if (Reflect.hasMetadata(token, MetaStore)) {\n      throw new Error(`id:[${String(token)}] is existed!`);\n    } else {\n      Reflect.defineMetadata(token, target, MetaStore);\n    }\n  };\n}\n```\n\n> Injectable 提供了可选项 id?，用来避免命名冲突。\n\n这样只要被 Injectable()装饰过的类都会被缓存到 MetaStore 中。\n\n## @Inject\n\n> 构造函数参数注入。读写 target 身上的元数据，用于注入依赖信息。\n\n```typescript\n// target身上的元数据类型(参数注入)\nexport type ParamMeta = Array<[PropertyKey, number]>;\n\nexport function Inject(id: PropertyKey): ParameterDecorator {\n  return (target, _, index) => {\n    // 获取到target身上的ParamMeta，如果没有就创建一个新的\n    const depMeta =\n      Reflect.getMetadata<ParamMeta>(CUSTOM.META_PARAM, target) || [];\n\n    // push一个ParamMeta，id和index\n    depMeta.push([id, index]);\n\n    // 再把ParamMeta保存回target\n    Reflect.defineMetadata(CUSTOM.META, depMeta, target);\n  };\n}\n```\n\n> index 即参数在函数(构造函数)arguments 数组中的下标，id 为 Injectable-token\n\n例如：\n\n```typescript\n@Injectable() // 缓存到MetaStore, id: 'Service'.\nclass Service {}\n\ninterface IService {}\n\nclass Controller {\n  // inject注解，请求依赖为id: 'Service', 位置为index: 0\n  constructor(@Inject(\"Service\") private Service: IService) {}\n}\n```\n\n## @InjectProp\n\n> 成员属性注入。读写 target 身上的元数据，用于注入依赖信息。\n\n```typescript\n// target身上的元数据类型(成员属性注入)\nexport type PropMeta = Array<[PropertyKey, PropertyKey]>;\n\nexport function InjectProp(id?: PropertyKey): PropertyDecorator {\n  return (target, key) => {\n    // 请求的依赖token，默认为成员属性名key\n    const token = id || key;\n\n    // 获取到target身上的PropMeta，如果没有就创建一个新的\n    const depMeta =\n      Reflect.getMetadata<PropMeta>(CUSTOM.META_PROP, target) || [];\n\n    // push一个PropMeta，id和index\n    depMeta.push([token, key]);\n\n    // 再把ParamMeta保存回target\n    Reflect.defineMetadata(CUSTOM.META_PROP, depMeta, target);\n  };\n}\n```\n\n例如：\n\n```typescript\n@Injectable() // 缓存到MetaStore, id: 'Service'.\nclass Service {}\n\ninterface IService {}\n\nclass Controller {\n  // inject注解，请求依赖为id: 'Service', 属性名为'Service'\n  @InjectProp() private Service: IService;\n}\n```\n\n## 实现 Injector 函数（核心）\n\n> 从入口开始构建整个依赖树，并生成根实例\n> 这里需要利用 AOP 思想，在 Target 生成实例前后做切面\n\n```typescript\ntype Constructor<T = any> = { new (...args: Array<any>): T };\n\nexport function Injector<T>(Target: Constructor<T>): T | Constructor<T> {\n  // 如果是静态类，直接返回\n  if (Reflect.hasMetadata(CUSTOM.STATIC, Target)) return Target;\n\n  // before 拿到ParamMeta实例数组\n  const instances = before(Target);\n\n  // 注入ParamMeta实例数组，生成Target实例\n  const target = new Target(...instances);\n\n  // after 进行PropMeta依赖注入\n  after(target);\n\n  return target;\n}\n```\n\n## before\n\n> 通过 Target 获取元数据信息(ParamMeta)，返回处理好的依赖项实例数组\n\n```typescript\nfunction before<T>(Target: Constructor<T>) {\n  // 获取设计元数据，也就是构造函数参数中的依赖项\n  const deps =\n    Reflect.getMetadata<Array<Constructor>>(DESIGN.PARAMTYPES, Target) || [];\n\n  // 获取Injected tags\n  const tags = Reflect.getMetadata<ParamMeta>(CUSTOM.META_PARAM, Target) || [];\n\n  // 遍历每一个tag\n  tags.forEach(([id, index]) => {\n    // 如果MetaStore中已注册\n    if (Reflect.hasMetadata(id, MetaStore)) {\n      // 找到MetaStore中id对应的metadata，按index插入deps\n      deps[index] = Reflect.getMetadata(id, MetaStore);\n    } else {\n      // 若没找到，则抛出异常\n      throw new Error(`injected dep:${String(id)} not found`);\n    }\n  });\n\n  // 对每一个ParamMeta依赖进行Injector依赖注入，得到实例数组并返回\n  return deps.map(Injector);\n}\n```\n\n## after\n\n> 通过 Target 实例获取元数据信息(PropMeta)，将处理好的依赖项定义到 Target 实例上\n\n```typescript\nfunction after<T>(target: T) {\n  // 获取PropMeta，也就是成员属性名关联的元数据\n  const props = Reflect.getMetadata<PropMeta>(CUSTOM.META_PROP, target) || [];\n\n  // 遍历每一个PropMeta元素\n  props.forEach(([id, key]) => {\n    // 如果MetaStore中已注册\n    if (Reflect.hasMetadata(id, MetaStore)) {\n      // 在MetaStore中找到对应metadata，也就是PropertyKey对应的依赖\n      const dep = Reflect.getMetadata<Constructor>(id, MetaStore);\n      // 对依赖进行依赖注入，得到依赖实例\n      const instance = Injector(dep);\n\n      // 将依赖实例作为属性定义到target上\n      Object.defineProperty(target, key, { value: instance });\n    } else {\n      // 若没找到，则抛出异常\n      throw new Error(`injected dep:${String(id)} not found`);\n    }\n  });\n}\n```\n\nDemo\n\n```typescript\n@Injectable()\nclass Service {\n  public getUser() {\n    return \"saber!\";\n  }\n}\n\nclass Controller {\n  public constructor(@Inject(\"Service\") private Service: Service) {}\n\n  // @InjectProp() private Service: Service\n\n  public test() {\n    console.log(this.Service.getUser());\n  }\n}\n\nconst app = Injector(Controller);\n\napp.test(); // 'saber!\n```\n"},{"path":"/blog/Reflect反射原理/实现一个基于IOC的HttpServer框架","title":"实现一个基于IOC的HttpServer框架","children":[{"path":"/blog/Reflect反射原理/实现一个基于IOC的HttpServer框架/实现一个基于IOC的HttpServer框架(上).md","title":"实现一个基于IOC的HttpServer框架(上)","text":"总体思路：\n\n1. Controller 用来组织元数据\n2. parse 方法将 Controller 中的 metadata 提取出来，得到 Controller-Metadata-Node\n3. transform 方法将 Controller-Metadata-Node 转为 requestListeners\n\n利用 Class 来组织元数据，利用装饰器和 Reflect 注入元数据信息\n\n```typescript\n@Controller(\"/user\") // 注入 baseUrl: '/user'\nclass UserController {\n  @Post(\"/register\") // 注入 POST: '/register'\n  public register() {}\n\n  @Get(\"/login\") // 注入 GET: '/login'\n  public login() {}\n}\n```\n\n> 现在利用 Reflect 来实现装饰器 Controller、Get、Post\n\n## 在此之前需要定义 constants\n\n> 因为 Reflect 需要 metadataKey 来索引 metadata\n\n```typescript\nexport namespace KEY {\n  export const enum Controller {\n    BaseUrl = \"controller:baseUrl\",\n    GET = \"method:get\",\n    POST = \"method:post\"\n  }\n}\n```\n\n## 实现装饰器部分\n\n### 1. @Controller\n\n> 用来注入 baseUrl 元数据\n\n```typescript\nexport function Controller(path?: string): ClassDecorator {\n  return target =>\n    Reflector.defineMetadata(KEY.Controller.BaseUrl, path, target);\n}\n```\n\n### + DecoratorFactory\n\n> @Post 和@Get 相似代码太多，抽离一个 Factory 方法\n> 输入 Method type 和路由 path，返回一个 MethodDecorator\n\n```typescript\nexport function DecoratorFactory(\n  type: KEY.Controller,\n  path: string\n): MethodDecorator {\n  return (target, key) => Reflector.defineMetadata(type, path, target, key);\n}\n```\n\n### 2. @Post、@Get\n\n> 用来注入 method 类型、路由 path、对应的响应方法名(propertyKey)\n\n```typescript\nexport function Get(path?: string): MethodDecorator {\n  return DecoratorFactory(KEY.Controller.GET, path);\n}\n\nexport function Post(path?: string): MethodDecorator {\n  return DecoratorFactory(KEY.Controller.POST, path);\n}\n```\n\n利用上述装饰器可以将 requestListener 需要的 path、method、callbackName 等信息定义在 Controller 上\n\n### parse\n\n> 解决如何提取出 Controller 中的 metadata 及其转化为 Controller-Metadata-Node\n\n首先明确，输入和输入的 type\n\n输入一个 Class，返回一个 Controller-Metadata-Node\n\n```typescript\n// 伪代码\nfunction parse(Controller: { new (): any }): Controller-Metadata-Node\n```\n\n定义 type\n\n```typescript\n// GET和POST还有别的method懒得写了\nexport type Method = \"GET\" | \"POST\";\n\n// 路由\nexport type Routes = Array<{\n  method: Method;\n  path: string;\n  callback: Function;\n}>;\n\n// Controller-Metadata-Node\nexport interface Controller {\n  baseUrl: string;\n  routes: Routes;\n}\n```\n\n实现 parse\n\n```typescript\n// parse函数实现\n// 输入一个Class类型，输出Controller-Metadata-Node\nexport function parse(Controller: { new (): any }): Controller {\n  // 提取baseUrl\n  const baseUrl = Reflector.getMetadata<string>(\n    KEY.Controller.BaseUrl,\n    Controller\n  );\n  // 实例化\n  const target = new Controller();\n  // 获取实例的所有方法callbackNames\n  const methods = Object.keys(Object.getPrototypeOf(target));\n\n  // 遍历所有callbackNames\n  // 匹配对应的method并输出\n  const routes = methods.reduce((receiver, key) => {\n    resolve(target, key, \"GET\", receiver);\n    resolve(target, key, \"POST\", receiver);\n    return receiver;\n  }, []);\n\n  // 返回Controller-Metadata-Node\n  return {\n    baseUrl,\n    routes\n  };\n}\n```\n\n说一下 resolve 函数做了什么\n\n### + resolve\n\n> reduce 的辅助函数，用于匹配 method 与 metadata\n\n```typescript\nexport function resolve(\n  target: Object,\n  key: string,\n  method: Method,\n  receiver: Routes\n) {\n  // 获取target.key上methodKey对应的metadata\n  const path = Reflector.getMetadata<string>(\n    mapMethodToKey(method),\n    target,\n    key\n  );\n  // 如果method对应的path存在，则往receiver中push一个route\n  if (path) receiver.push({ method, path, callback: target[pathToProp(path)] });\n}\n```\n\n这里需要实现两个 util 函数\n\n### + mapMethodToKey 、pathToProp\n\n> mapMethodToKey 用来进行 Pattern matching\n> pathToProp 用来处理 path 的前缀\n\n```typescript\nexport function mapMethodToKey(method: Method): KEY.Controller {\n  switch (method) {\n    case \"GET\":\n      return KEY.Controller.GET;\n    case \"POST\":\n      return KEY.Controller.POST;\n    default:\n      throw new TypeError();\n  }\n}\n\nexport function pathToProp(path: string) {\n  if (path.startsWith(\"/\")) {\n    return path.slice(1);\n  }\n  return path;\n}\n```\n\ntransform\n\n> 将 Controller-Metadata-Node 转为 requestListeners（Units）\n\n首先明确，输入和输入的 type\n\n输入一个 Controller-Metadata-Node 返回 Units\n\n```typescript\n// requestListener需要的信息\nexport interface Unit {\n  url: string;\n  callback: Function;\n  method: string;\n}\n\n// 实现transform\nexport function transform(controller: Controller): Unit[] {\n  return controller.routes.map<Unit>(({ path, callback, method }) => ({\n    url: controller.baseUrl + path,\n    callback,\n    method\n  }));\n}\n```\n\n> transform 这一步做的有点少，其实应该直接转为 requestListeners\n\n### + mapUnitToJob\n\n> 用来把 transform 得到的 units 转为 requestListeners\n\n这里用的是 Koa 所以：\n\n```typescript\n// 得到requestListeners序列\nexport function mapUnitToJob(units: Unit[]): Job<Context>[] {\n  return units.map<Job>(unit => async (ctx, next) => {\n    const { url, method } = ctx.request;\n    if (url === unit.url && method === unit.method) {\n      // 混入ctx\n      await unit.callback.apply(\n        Object.assign(unit.origin, { ContextService: ctx })\n      );\n    } else {\n      await next();\n    }\n  });\n}\n```\n\n利用 Koa-compose 就可以组合 requestListeners 序列\n\n### + ContextService\n\n```typescript\n@Injectable()\nexport class ContextService {\n  public request: Context[\"request\"];\n  public response: Context[\"response\"];\n}\n```\n\n只要注入 ContextService 就可以获取 koa-context 信息\n\n例如\n\n```typescript\n@Controller(\"/user\")\nclass UserController {\n  constructor(private ContextService: ContextService) {}\n\n  @Get(\"/login\")\n  public login() {\n    this.ContextService.response.end(\"login\");\n  }\n\n  @Get(\"/hello\")\n  public hello() {\n    this.ContextService.response.end(\"hello\");\n  }\n}\n```\n\n现在有了定义 metadata 的 decorators、parser 和 transformer\n\n最后需要的就是一个 Factory 类，将这几个过程有序组织起来\n\n### Factory\n\n```typescript\nexport class Factory {\n  public constructor(private modules: Array<{ new (): any }>) {\n    // 将classes转为units\n    this.units = [].concat(...this.modules.map(mod => transform(parse(mod))));\n  }\n  public instance: KoaBody;\n  private units: Unit[];\n  public create() {\n    // 将units转为requestListeners，实例化一个koa-app，koa.use...\n    this.instance = Koa().use(compose(...mapUnitToJob(this.units)));\n    // 返回koa实例\n    return this.instance;\n  }\n}\n```\n\ndemo\n\n```typescript\n@Controller(\"/user\")\nclass UserController {\n  constructor(private ContextService: ContextService) {}\n\n  @Get(\"/login\")\n  public login() {\n    this.ContextService.response.end(\"login\");\n  }\n\n  @Get(\"/hello\")\n  public hello() {\n    this.ContextService.response.end(\"hello\");\n  }\n}\n\nnew Factory([UserController])\n  .create()\n  .listen(3001, () => console.log(\"http://localhost:3001\"));\n```\n\n> 现在只是实现了从 Controllers 到 requestListeners，关于 Service 注入在下一篇文章分享。\n"},{"path":"/blog/Reflect反射原理/实现一个基于IOC的HttpServer框架/实现一个基于IOC的HttpServer框架(下).md","title":"实现一个基于IOC的HttpServer框架(下)","text":"上一篇文章实现了从 Controllers 到 requestListeners 的转化，下面需要解决的问题是当 Controller 使用了 IOC 容器来注入 Service 时怎么 parse 以及思路。\n\n以每个 Controller 为一个根节点构建它的实例，parser 从实例中解析出 baseUrl 和 routes\n\n之前我写的 IOC 容器被我重构了 qwq，API 现在是 Inject、Injectable、Injector.\n\n> 1. Inject 负责添加依赖信息\n> 2. Injectable 用来注册和缓存 constructors\n> 3. Injector 用来构建根实例\n\n所以需要在 parse 方法中使用 Injector 对 Controller 进行依赖注入\n\n```typescript\nexport function parse(Controller: { new (): any }): Controller {\n  const baseUrl = Reflector.getMetadata<string>(\n    KEY.Controller.BaseUrl,\n    Controller\n  );\n\n  // Injector将Controller需要的依赖注入其中，返回它的一个实例\n  const target = Injector(Controller);\n  const methods = Object.keys(Object.getPrototypeOf(target));\n\n  const routes = methods.reduce((receiver, key) => {\n    resolve(target, key, \"GET\", receiver);\n    resolve(target, key, \"POST\", receiver);\n    resolve(target, key, \"DELETE\", receiver);\n    resolve(target, key, \"PUT\", receiver);\n    return receiver;\n  }, []);\n\n  return {\n    baseUrl,\n    routes\n  };\n}\n```\n\n> emmm，这就搞定了。原来是 new Controller，现在是 Injector(Controller)\n\nDemo\n\n```typescript\n@Injectable()\nclass UserService {\n  public getUserName() {\n    return \"saber2pr!\";\n  }\n\n  public getHello() {\n    return \"Hello!\";\n  }\n}\n\n@Controller(\"/user\")\nclass UserController {\n  constructor(\n    private ContextService: ContextService,\n    @Inject(\"UserService\") private UserService: UserService\n  ) {}\n\n  @Get(\"/login\")\n  public login() {\n    this.ContextService.response.end(this.UserService.getUserName());\n  }\n\n  @Get(\"/hello\")\n  public hello() {\n    this.ContextService.response.end(this.UserService.getHello());\n  }\n}\n\nnew Factory([UserController])\n  .create()\n  .listen(3001, () => console.log(\"http://localhost:3001\"));\n// http://localhost:3001/user/login\n// http://localhost:3001/user/hello\n```\n\n> 关于 saber-ioc 现在已重构为@saber2pr/ioc\n> 之前写的文章也做了更新，主要是简化了大部分代码\n\n(最后瞎扯一句) 关于 OOP 的依赖注入和函数式的 compose 一直是个争论的问题，到底哪种方式更好谁也说不清(\n"}]}]},{"path":"/blog/Typescript基础","title":"Typescript基础","children":[{"path":"/blog/Typescript基础/对比Monad在TS和Haskell中的使用.md","title":"对比Monad在TS和Haskell中的使用","text":"因为在 TS 中没有关于 Monad 的类型，所以先实现基础设施。\n\n> 只做简单实现，重点在于与 haskell 代码风格比较。\n> 目的：加深对 Monad 的理解。\n\n### Monad\n\nMonad 中保存了一个值(惰性)。所以可以这样定义它\n\n```typescript\ntype Monad<T> = {\n  readonly _wrapped_: () => T;\n};\n```\n\nwrapped 就是一个值包装器，将一个值惰性化。\n\n> 意义: 用来保存值上下文，串联对值的一系列操作\n> 处于相对于普通值类型的上层\n> 在 haskell 中 Monad 为一个类型类\n\n### return\n\n也就是 pure。将一个值提升到 Monad。\n\n```typescript\ntype pure = <T>(a: T) => Monad<T>;\nconst pure: <T>(a: T) => Monad<T> = value => ({\n  _wrapped_: () => Object.freeze(value)\n});\n```\n\n> 意义: 将一个值惰性化\n\n### join\n\n将一个 Monad 解包，然后应用一个提升函数，返回新的 Monad。\n\n```typescript\ntype join = <A, B>(m: Monad<A>, f: (a: A) => Monad<B>) => Monad<B>;\nconst join: <A, B>(m: Monad<A>, f: (a: A) => Monad<B>) => Monad<B> = (m, f) =>\n  f(m._wrapped_());\n```\n\n> 意义：join 的返回值为 Monad 类型，接受一个 Monad 映射到的还是 Monad，即自函子。\n> 提供对 Monad 类型实例的解包。\n\n### liftA\n\n将一个 Monad 解包，然后应用一个非提升函数，返回新的 Monad。\n\n```typescript\ntype liftA = <A, B>(m: Monad<A>, f: (a: A) => B) => Monad<B>;\nconst liftA: <A, B>(m: Monad<A>, f: (a: A) => B) => Monad<B> = (m, f) =>\n  pure(f(m._wrapped_()));\n```\n\n> 将一个函数 lift 进 Monad 中\n\n### fmap\n\n和 lift 用法一样，是 Functor 类型类的方法。\n\n### compose\n\n一个二元运算\n\n```typescript\nconst compose: <A, R1, R2>(\n  f2: (a: R1) => R2,\n  f1: (a: A) => R1\n) => (a: A) => R2 = (f2, f1) => a => f2(f1(a));\n```\n\n## 与 Haskell Monad 比较\n\n1. 首先创建一个 Monad。\n\nin haskell\n\n```haskell\nasync_init :: Monad m => m Integer\nasync_init = pure 1\n```\n\nin typescript\n\n```typescript\ntype async_init = Monad<number>;\nconst async_init: Monad<number> = pure(1);\n```\n\n2. 使用 join 对 Monad 下层值进行(+1)操作\n\nin haskell\n\n```haskell\nasync_join_add :: Monad m => m Integer -> m Integer\nasync_join_add m = m >>= \\a -> pure $ a + 1\n```\n\nin typescript\n\n```typescript\ntype async_join_add = (m: Monad<number>) => Monad<number>;\nconst async_join_add: (m: Monad<number>) => Monad<number> = m =>\n  join(m, a => pure(a + 1));\n```\n\n3. 使用 lift 将(+1)函数应用到 Monad\n\nin haskell\n\n```haskell\nasync_lift_add :: Monad m => m Integer -> m Integer\nasync_lift_add m = liftA (\\a -> a + 1) m\n```\n\nin typescript\n\n```typescript\ntype async_lift_add = (m: Monad<number>) => Monad<number>;\nconst async_lift_add: (m: Monad<number>) => Monad<number> = m =>\n  liftA(m, a => a + 1);\n```\n\n4. fmap 和 lift 用法一样，这里不写了\n\n5. main 函数\n\nin haskell\n\n```haskell\nmain :: IO ()\nmain = do\n  -- a <- async_fmap_add $ async_lift_add $ async_join_add async_init\n  a <- async_fmap_add . async_lift_add . async_join_add $ async_init\n  print a\n```\n\nin typescript\n\n```typescript\nfunction main() {\n  // const a = async_fmap_add(\n  //   async_lift_add(async_join_add(async_init()))\n  // )._wrapped_();\n\n  const a = compose(\n    async_fmap_add,\n    compose(\n      async_lift_add,\n      async_join_add\n    )\n  )(async_init)._wrapped_();\n\n  return pure(() => console.log(a));\n}\n\nmain()._wrapped_()();\n```\n\n## 关于 Promise 和 async\n\nPromise 就是 Monad，Promise.resolve 就是 pure，Promise.then 就是>>=。\n\nasync 就是 do block，await 就是 <- ，return 意义一样。\n"}]},{"path":"/blog/saber2prの窝.md","title":"saber2prの窝","text":"[loading](https://saber2pr.github.io/MyWeb/resource/image/yom.webp)\n\n你说既视感？\n\n错觉！\n\n为什么会有这个 Page？\n\n大概我想记录自己的心得但穷于购买 server service。\n\n为什么要搞一些闪瞎眼的 Animation？？\n\n如果没有过渡你可能想马上关掉这个呆掉的 Page。\n\n这个 page 上面大概有些什么值得我看的东西？\n\nJS/TS 相关、React 相关。\n\n---\n\n> 这么丑的界面，得找个机会把它给重写了\n\n> 大概就是以简洁为主的 UI 啦\n"},{"path":"/blog/性能优化","title":"性能优化","children":[{"path":"/blog/性能优化/前端性能优化.md","title":"前端性能优化","text":"### 减少HTTP请求资源大小、次数\n\n1. 合并、压缩css和js文件。\n\n> 多个文件合并为一个。减少http请求次数以及减少请求资源的大小。\n\n2. 使用字体图标或者SVG代替传统png图\n\n> 字体图标和SVG是矢量图，放大不会变形，而且渲染速度快。\n\n3. 图片懒加载\n\n减少页面首屏渲染http的请求次数\n\n> 利用占位图\n\n4. 动画用css做，不要js(尽量)\n\n5. 使用雪碧图 CSS Sprite\n\n把较小的资源图片绘制在一张大图上\n\n> 利用background-position裁剪\n\n6. 静态资源使用cdn分发\n\n7. 把CSS放到顶部，把JS放到底部\n\n> 优先渲染页面\n\n### 代码优化\n\n1. js中减少闭包\n\n2. 减少DOM操作\n\n> 用react等库就不用考虑这个了\n\n3. css使用link而不是@import\n\n> import是同步，link是异步\n\n4. 动画使用requestAnimationFrame而不是setInterval\n\n5. 使用DOM 事件委托\n\n6. import()代码分割，懒加载\n\n> 看看react-loadable?\n\n## 移动H5前端性能优化\n\n在Mobile有三秒种演染完成首屏指标，首屏加载需3秒完成或使用Loading。\n\n基于网络平均338KB/s(2.71Mb/s),所以首屏资源不应超过1014KB。\n\n### 加载优化\n\n1. 合并CSS, JavaScript\n\n2. 合并小图片,使用Sprite图\n\n3. 缓存一切可缓存的资源\n\n4. 使用长Cache\n\n5. 使用外联式引用CSS, JavaScript\n\n6. 压缩HTML, CSS, JavaScript\n\n7. 启用GZip\n\n8. 使用首屏加载\n\n9. 使用按需加载\n\n10. 使用滚屏加载\n\n11. 通过Media Query加载\n\n12. 增加Loading进度条\n\n13. 减少Cookie\n\n14. 避免重定向\n\n15. 异步加载第三方资源\n\n### CSS优化\n\n1. CSS写在头部，JavaScript写在尾部或异步\n\n2. 避免图片和iFrame等的空src\n\n3. 尽量避免重设图片大小\n\n4. 图片尽量避免使用DataURL\n\n5. 尽量避免写在HTML标签中写Stye属性\n\n6. 避免CSS表达式\n\n7. 移除空的CSS规则\n\n8. 正确使用Display的属性\n\n9. 不滥用Float\n\n10. 不滥用Web字体\n\n11. 不声明过多的Font-size\n\n12. 值为0时不需要任何单位\n\n13. 标准化各种浏览器前缀\n\n14. 避免让选择符看起来像正则表达式\n\n### 图片优化\n\n1. 使用(CSS3, SVG, IconFont)代替图片\n\n2. 使用Srcset\n\n3. webP优于JPG\n\n4. PNG8优于GIF\n\n5. 首次加载不大于1014KB (基于3秒联通平均网速所能达到值)\n\n6. 图片不宽于640\n\n### 脚本优化\n\n1. 减少重绘和回流\n\n2. 缓存Dom选择与计算\n\n3. 缓存列表length\n\n4. 尽量使用事件代理,避免批量绑定事件\n\n5. 尽量使用ID选择器\n\n6. 使用touchstart, touchend代替click\n\n### 渲染优化\n\n1. HTML使用Viewport \n\n2. 减少Dom节点\n\n3. 尽量使用CSS3动画\n\n4. 合理使requestAnimationFrame动画代替setTimeout\n\n5. 适当使用Canvas动画\n\n6. Touchmove, Scroll 事件会导致多次渲染\n\n7. 使用(CSS3 transitions, CSS3 3D transforms, Opacity, Canvas, WebGL, Video)来触发GPU渲染\n"}]},{"path":"/blog/我的思考","title":"我的思考","children":[{"path":"/blog/我的思考/INTJ的自我救赎.md","title":"INTJ的自我救赎","text":"INTJer 通常喜欢指定计划，然后一股脑钻到自己的事情里雷打不动的执行。\n然而并没有想过计划失败会怎么办，因为过于的自信，经常制定一些眼高手低的计划，导致最后被突然的失败击倒，陷入强烈的自我否定。\n\n首先必须认识到自己能力和目标任务的匹配程度。\n\n> 待续...(咕咕咕)\n"},{"path":"/blog/我的思考/保持学习.md","title":"保持学习","text":"如果一段时间内不进步或者进步不明显，那就是倒退。\n知识的积累应该按照金字塔形式，基础扎实上层业务才能游刃有余。\n"},{"path":"/blog/我的思考/如何面对选择.md","title":"如何面对选择","text":"我一直相信一句话。只要一直朝着一个方向努力，就一定会成功。\n但是，人的精力是有限的，如果一个方面做的好（或者还没做好在投入努力），那么必然会有另一方面的下滑。\n所以，最好一开始就不要多方面去浪费精力。\n如果一开始没有走好，那接下来的路就需要自己权衡了，到底是舍弃，还是退而求其次。我相信大部分人都不忍心去选择舍弃。\n\n不管做怎样的选择，拥有一个坚定不移的信念才是最重要的。\n也许这只是一种无奈的自我安慰。但是，如果自己走到了最绝望的时候，任何一句安慰都是有用的\n\n希望拥有梦想和信念的人最终都能收获成功\n"},{"path":"/blog/我的思考/学习方法论.md","title":"学习方法论","text":"### 如何学习一个 Library？\n\n1. 先学会用。\n2. 实现一个 like 版本，总结最简核心思路。\n3. 看源代码，验证自己的思路。\n4. 寻找优化点。\n\n## 推广：\n\n### 如何认识一个事物？\n\n1. 先熟悉它的特征。\n2. 猜测它为什么会有这些特征。\n3. (验证自己的想法)。\n4. 改进自己的想法。\n\n如果对自己的想法比较自信的话，可以不用验证。\n最后一点非常重要，如果忽略掉了，那么第 2、3 点就变成了无用功。\n换句话说，如果一个事物形成的原理不会再发生改变，那么只需要做到第 1 点就够了。\n但是世界上还没有人敢说什么事物已经不会向前发展了。\n所以，请尽量做到第 4 点。\n"},{"path":"/blog/我的思考/对失败的思考.md","title":"对失败的思考","text":"一个人遭遇失败后，再度看待同类事物时，总是首先向失败的方向思考，事物越是有成功的倾向，越感到紧迫感。人总是希望远离能引起自己紧迫感的事物，这进一步导致了一个人在某些方面的外在表现是具有退缩和消极感的。在这个理论基础上，如果一个人说自己不喜欢或者不在意某些事情时，那么可以初步断定他曾经在这些事情上遇到过挫折，进而找到消极思想的根源。(以上推断纯属个人思考，请勿过分深究)\n"},{"path":"/blog/我的思考/计划优先级.md","title":"计划优先级","text":"注意。错的、复杂的、不确定的情况一定要放最后去考虑，永远是先考虑快的，简单的。\n这不是说不去考虑高难度的任务，而是它的优先级比较低。\n前提是，需要能够收集足够多的情况，以确定相对较高的平均标准。\n"},{"path":"/blog/我的思考/障.md","title":"障","text":"secret=92-30-15-15-0-8-92-30-9-6-15-6-92-30-15-15-0-9-92-30-0-0-10-92-30-4-14-5-0-92-30-8-9-12-2-92-30-7-6-8-4-92-30-3-0-0-1-92-30-5-9-1-6-92-30-5-4-1-1-92-30-7-6-8-4-92-30-3-0-0-1-92-30-8-1-14-10-92-30-6-3-10-7-92-30-5-2-9-11-92-30-4-14-0-13-92-30-8-13-11-3-92-30-7-6-8-4-92-30-4-14-11-10-92-30-4-14-0-13-92-30-8-9-8-1-92-30-8-15-13-11-92-30-6-7-6-5-92-30-15-15-0-12-92-30-8-11-15-7-92-30-8-1-14-10-92-30-8-9-12-9-92-30-9-0-0-0-92-30-5-1-15-10-92-30-15-15-0-12-92-30-8-15-13-9-92-30-7-11-12-7-92-30-6-5-8-7-92-30-7-10-14-0-92-30-5-3-14-15-92-30-8-0-15-13-92-30-4-15-1-10-92-30-5-15-1-5-92-30-8-13-7-7-92-30-5-15-12-3-92-30-7-4-0-6-92-30-4-14-0-13-92-30-9-0-0-2-92-30-3-0-0-2-92-30-0-0-10-92-30-8-15-13-9-92-30-7-11-12-7-92-30-6-5-8-7-92-30-7-10-14-0-92-30-7-5-2-8-92-30-6-7-6-5-92-30-6-3-12-15-92-30-8-15-15-0-92-30-9-14-13-1-92-30-6-6-9-7-92-30-7-6-8-4-92-30-6-2-1-1-92-30-3-0-0-2-92-30-5-11-15-9-92-30-4-15-6-0-92-30-6-12-10-1-92-30-6-7-0-9-92-30-6-1-0-15-92-30-4-14-4-9-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-4-14-0-0-92-30-15-15-0-9-92-30-0-0-10-92-30-5-9-8-2-92-30-6-7-9-12-92-30-6-2-12-5-92-30-5-15-12-3-92-30-8-1-14-10-92-30-5-13-15-1-92-30-7-6-8-4-92-30-8-10-0-0-92-30-8-11-11-10-92-30-4-15-1-10-92-30-5-15-7-1-92-30-5-4-12-13-92-30-5-2-2-11-92-30-4-14-11-10-92-30-5-15-12-3-92-30-6-0-12-5-92-30-15-15-0-12-92-30-5-3-14-15-92-30-4-14-14-5-92-30-5-12-1-13-92-30-8-11-13-5-92-30-9-0-0-0-92-30-4-14-0-0-92-30-6-11-6-5-92-30-5-3-13-1-92-30-8-10-0-0-92-30-6-2-5-3-92-30-6-13-8-8-92-30-8-15-13-9-92-30-7-9-12-13-92-30-9-8-7-14-92-30-8-6-5-1-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-4-14-8-12-92-30-15-15-0-9-92-30-0-0-10-92-30-7-6-15-8-92-30-4-14-9-2-92-30-4-15-9-13-92-30-8-13-5-6-92-30-15-15-0-12-92-30-5-3-12-13-92-30-5-4-1-1-92-30-5-3-13-1-92-30-5-12-5-5-92-30-3-0-0-2-92-30-6-2-4-13-92-30-8-0-15-13-92-30-7-10-3-3-92-30-5-11-9-10-92-30-5-11-5-8-92-30-5-7-2-8-92-30-3-0-0-2-92-30-0-0-10-92-30-6-10-2-1-92-30-4-14-15-15-92-30-5-4-0-12-92-30-5-3-1-6-92-30-4-15-1-10-92-30-5-11-15-12-92-30-8-1-15-4-92-30-6-11-12-1-92-30-7-0-6-13-92-30-3-0-0-2-92-30-0-0-10-92-30-4-15-4-6-92-30-6-6-2-15-92-30-0-0-2-14-92-30-0-0-2-14-92-30-0-0-2-14-92-30-6-11-12-1-92-30-7-0-6-13-92-30-4-14-0-13-92-30-4-14-5-15-92-30-5-15-8-8-92-30-5-15-0-0-92-30-5-15-12-3-92-30-4-14-4-8-92-30-0-0-10-92-30-15-15-0-8-92-30-4-14-0-9-92-30-15-15-0-9-92-30-0-0-10-92-30-2-0-1-12-92-30-4-15-6-0-92-30-5-15-8-8-92-30-5-1-7-3-92-30-5-15-12-3-92-30-6-2-1-1-92-30-5-4-1-7-92-30-2-0-1-13-92-30-0-0-10-92-30-2-0-1-12-92-30-0-0-2-14-92-30-0-0-2-14-92-30-0-0-2-14-92-30-2-0-1-13-92-30-0-0-10-92-30-6-7-9-12-92-30-7-1-3-6-92-30-8-15-13-8-92-30-6-6-2-15-92-30-8-8-10-11-92-30-5-2-2-9-92-30-7-5-2-8-92-30-4-14-8-6-92-30-5-4-6-2-92-30-0-0-10-92-30-5-3-14-15-92-30-6-6-2-15-92-30-6-2-1-1-92-30-5-13-15-2-92-30-7-14-12-15-92-30-6-12-10-1-92-30-6-7-0-9-92-30-5-2-2-9-92-30-7-5-2-8-92-30-4-14-15-7-92-30-5-0-3-12-92-30-4-14-8-6-92-30-0-0-10-92-30-15-15-0-8-92-30-5-6-13-11-92-30-15-15-0-9-92-30-0-0-10-92-30-6-0-15-3-92-30-8-9-8-1-92-30-5-11-8-8-92-30-6-2-10-4-92-30-8-1-14-10-92-30-5-13-15-1-92-30-5-5-9-12-92-30-6-11-2-2-92-30-7-6-8-4-92-30-4-14-1-12-92-30-8-9-7-15-92-30-15-15-0-12-92-30-6-2-4-0-92-30-4-14-14-5-92-30-6-2-1-1-92-30-6-2-4-13-92-30-8-0-15-13-92-30-5-7-5-10-92-30-6-3-0-1-92-30-5-2-3-0-92-30-7-3-11-0-92-30-5-7-2-8-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-4-14-9-4-92-30-15-15-0-9-92-30-0-0-10-92-30-6-2-1-1-92-30-15-15-0-12-92-30-0-0-4-9-92-30-0-0-4-14-92-30-0-0-5-4-92-30-0-0-4-10-92-30-15-15-0-12-92-30-0-0-3-8-92-30-0-0-3-1-92-30-0-0-2-0-92-30-0-0-3-4-92-30-0-0-3-6-92-30-0-0-2-0-92-30-0-0-3-7-92-30-0-0-3-5-92-30-0-0-2-0-92-30-0-0-3-1-92-30-0-0-3-0-92-30-0-0-3-0-92-30-15-15-0-12-92-30-4-14-5-13-92-30-5-7-8-11-92-30-4-14-11-10-92-30-6-8-3-12-92-30-0-0-2-0-92-30-0-0-3-5-92-30-0-0-2-0-92-30-5-3-15-7-92-30-3-0-0-2-92-30-0-0-10-92-30-5-7-2-8-92-30-5-0-5-10-92-30-9-8-9-8-92-30-4-14-4-11-92-30-5-2-4-13-92-30-15-15-0-12-92-30-5-12-3-1-92-30-5-13-15-2-92-30-7-14-12-15-92-30-7-3-1-12-92-30-5-2-3-0-92-30-4-14-8-6-92-30-7-14-13-3-92-30-6-7-9-12-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-5-1-6-13-92-30-15-15-0-9-92-30-0-0-10-92-30-5-9-9-6-92-30-6-8-10-6-92-30-3-0-0-2-92-30-5-5-9-12-92-30-6-11-2-2-92-30-4-14-0-10-92-30-4-15-6-0-92-30-4-14-0-13-92-30-6-6-2-15-92-30-6-5-14-0-92-30-7-15-1-8-92-30-6-5-14-0-92-30-6-5-4-5-92-30-3-0-0-2-92-30-0-0-10-92-30-6-2-1-1-92-30-4-14-5-15-92-30-6-0-15-3-92-30-8-9-8-1-92-30-5-0-12-15-92-30-4-15-6-0-92-30-4-14-0-0-92-30-6-8-3-7-92-30-15-15-0-12-92-30-6-7-0-9-92-30-5-3-14-15-92-30-4-14-14-5-92-30-6-12-3-8-92-30-8-15-13-12-92-30-5-11-8-8-92-30-6-2-10-4-92-30-7-6-8-4-92-30-4-14-11-10-92-30-3-0-0-2-92-30-0-0-10-92-30-6-2-1-1-92-30-4-14-5-15-92-30-5-0-12-15-92-30-4-15-6-0-92-30-4-14-0-0-92-30-6-8-3-7-92-30-8-8-10-11-92-30-8-15-15-7-92-30-8-3-2-11-92-30-5-6-15-0-92-30-6-0-13-1-92-30-15-15-0-12-92-30-7-5-2-8-92-30-7-6-7-13-92-30-6-9-7-12-92-30-5-2-5-1-92-30-8-1-14-10-92-30-5-12-3-13-92-30-8-9-14-3-92-30-5-1-11-3-92-30-4-14-0-0-92-30-5-2-0-7-92-30-7-0-14-6-92-30-6-0-7-12-92-30-3-0-0-2-92-30-0-0-10-92-30-6-2-1-1-92-30-4-14-5-15-92-30-5-7-2-8-92-30-4-14-0-13-92-30-5-0-5-12-92-30-7-6-8-4-92-30-4-15-14-14-92-30-8-8-4-12-92-30-15-15-0-12-92-30-4-14-0-13-92-30-6-5-10-13-92-30-5-7-3-0-92-30-6-3-13-0-92-30-5-3-4-7-92-30-8-1-14-10-92-30-5-13-15-1-92-30-3-0-0-2-92-30-4-14-14-5-92-30-6-7-0-9-92-30-8-0-15-13-92-30-5-2-9-11-92-30-5-11-8-8-92-30-6-2-10-4-92-30-8-15-13-9-92-30-9-1-12-12-92-30-15-15-0-12-92-30-4-14-14-5-92-30-9-7-6-2-92-30-5-11-15-9-92-30-6-6-15-4-92-30-5-15-3-10-92-30-7-6-8-4-92-30-6-5-4-12-92-30-4-14-11-10-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-4-14-0-3-92-30-15-15-0-9-92-30-0-0-10-92-30-6-2-1-1-92-30-4-14-14-5-92-30-4-14-3-10-92-30-6-2-1-1-92-30-5-3-14-10-92-30-6-6-2-15-92-30-6-7-0-0-92-30-8-15-13-1-92-30-5-15-12-3-92-30-6-0-12-5-92-30-4-14-0-13-92-30-5-9-7-13-92-30-3-0-0-2-92-30-5-6-13-14-92-30-6-0-15-3-92-30-4-14-8-6-92-30-4-14-0-0-92-30-4-14-0-11-92-30-15-15-0-12-92-30-6-2-1-1-92-30-9-10-13-8-92-30-4-14-0-0-92-30-7-6-8-4-92-30-6-5-15-6-92-30-5-0-1-9-92-30-4-14-5-15-92-30-9-6-7-7-92-30-5-1-6-5-92-30-6-2-9-1-92-30-9-0-12-1-92-30-3-0-0-2-92-30-4-14-0-13-92-30-5-11-15-9-92-30-15-15-0-12-92-30-6-5-7-4-92-30-4-14-2-10-92-30-9-10-13-8-92-30-4-14-2-13-92-30-9-0-15-13-92-30-6-6-2-15-92-30-8-15-13-9-92-30-4-14-2-10-92-30-7-0-7-0-92-30-8-2-7-2-92-30-7-6-8-4-92-30-7-2-11-6-92-30-6-0-0-1-92-30-3-0-0-2-92-30-6-2-1-1-92-30-4-14-5-15-92-30-6-6-15-14-92-30-7-10-13-9-92-30-5-7-2-8-92-30-7-3-14-13-92-30-7-14-10-7-92-30-7-6-8-4-92-30-9-8-7-6-92-30-7-0-11-9-92-30-15-15-0-12-92-30-5-3-14-15-92-30-5-9-2-9-92-30-5-9-1-6-92-30-6-7-0-9-92-30-5-9-2-9-92-30-9-8-8-4-92-30-6-13-4-11-92-30-5-2-3-0-92-30-4-14-8-6-92-30-7-3-11-0-92-30-5-7-2-8-92-30-15-15-0-12-92-30-5-3-9-15-92-30-6-7-6-5-92-30-6-2-1-1-92-30-5-3-14-10-92-30-6-6-2-15-92-30-4-14-0-0-92-30-5-8-0-6-92-30-5-14-9-15-92-30-7-2-6-9-92-30-4-14-2-13-92-30-7-6-8-4-92-30-6-6-6-14-92-30-9-0-1-10-92-30-5-7-8-3-92-30-5-7-3-14-92-30-8-0-0-12-92-30-5-13-15-2-92-30-3-0-0-2-92-30-5-11-15-9-92-30-6-7-2-10-92-30-7-7-14-5-92-30-7-6-8-4-92-30-3-0-0-1-92-30-4-14-0-13-92-30-5-3-14-15-92-30-6-3-10-7-92-30-7-6-8-4-92-30-4-14-8-11-92-30-7-2-6-9-92-30-15-15-0-12-92-30-6-2-1-1-92-30-5-11-11-3-92-30-6-0-1-5-92-30-6-7-8-1-92-30-4-14-8-6-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-5-1-6-11-92-30-15-15-0-9-92-30-0-0-10-92-30-6-2-1-1-92-30-5-15-8-8-92-30-9-1-12-13-92-30-5-3-14-3-92-30-3-0-0-2-92-30-6-2-1-1-92-30-5-1-7-3-92-30-6-12-14-8-92-30-7-6-8-4-92-30-4-14-1-12-92-30-8-9-7-15-92-30-7-14-12-15-92-30-5-14-3-8-92-30-5-7-3-0-92-30-8-11-10-9-92-30-6-2-1-1-92-30-4-14-0-9-92-30-8-9-12-2-92-30-5-13-2-9-92-30-6-14-8-3-92-30-3-0-0-2-92-30-6-2-1-1-92-30-7-14-12-15-92-30-5-14-3-8-92-30-5-11-15-9-92-30-5-2-2-11-92-30-4-14-11-10-92-30-4-14-0-13-92-30-6-14-14-1-92-30-15-15-0-12-92-30-4-15-4-6-92-30-5-11-15-9-92-30-5-2-2-11-92-30-4-14-11-10-92-30-7-6-8-4-92-30-6-2-4-0-92-30-6-7-0-9-92-30-6-6-11-4-92-30-5-2-9-11-92-30-8-8-4-12-92-30-4-14-3-10-92-30-9-0-15-13-92-30-5-3-14-10-92-30-6-6-2-15-92-30-8-1-1-1-92-30-6-13-7-7-92-30-4-14-2-13-92-30-7-6-8-4-92-30-4-14-0-0-92-30-5-2-3-9-92-30-9-0-10-3-92-30-3-0-0-2-92-30-5-6-14-0-92-30-4-14-3-10-92-30-7-14-12-15-92-30-5-14-3-8-92-30-5-3-8-11-92-30-6-2-9-1-92-30-8-15-13-9-92-30-7-9-12-13-92-30-6-0-12-5-92-30-7-14-14-10-92-30-15-15-0-12-92-30-5-11-15-12-92-30-8-1-15-4-92-30-6-2-1-1-92-30-5-14-7-6-92-30-6-12-10-1-92-30-6-7-0-9-92-30-4-14-12-0-92-30-4-14-4-8-92-30-8-8-6-8-92-30-6-0-12-5-92-30-7-14-13-9-92-30-4-15-6-0-92-30-7-7-0-11-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-4-14-5-13-92-30-15-15-0-9-92-30-0-0-10-92-30-6-2-1-1-92-30-7-14-12-15-92-30-5-14-3-8-92-30-5-15-3-10-92-30-8-12-0-3-92-30-5-3-14-10-92-30-8-9-8-1-92-30-6-7-0-9-92-30-5-2-10-10-92-30-5-2-9-11-92-30-7-6-8-4-92-30-8-15-12-7-92-30-7-10-0-11-92-30-5-12-3-1-92-30-5-9-1-15-92-30-4-14-8-6-92-30-3-0-0-2-92-30-4-15-4-6-92-30-6-6-2-15-92-30-15-15-0-12-92-30-4-15-4-6-92-30-6-6-2-15-92-30-4-14-3-10-92-30-4-14-12-0-92-30-4-14-4-8-92-30-6-2-1-1-92-30-6-0-3-11-92-30-6-6-2-15-92-30-5-15-9-7-92-30-4-14-0-13-92-30-5-2-3-0-92-30-6-0-15-3-92-30-8-9-8-1-92-30-7-6-8-4-92-30-7-14-13-3-92-30-6-7-5-15-92-30-5-4-6-2-92-30-15-15-1-15-92-30-6-2-1-1-92-30-4-14-0-13-92-30-6-0-15-3-92-30-8-15-13-9-92-30-4-14-4-8-92-30-7-7-0-11-92-30-9-1-12-13-92-30-7-14-13-3-92-30-6-7-9-12-92-30-5-3-14-15-92-30-6-6-2-15-92-30-6-12-10-1-92-30-6-7-0-9-92-30-7-5-2-8-92-30-3-0-0-2-92-30-0-0-10-92-30-6-2-1-1-92-30-5-9-7-13-92-30-5-0-12-15-92-30-7-5-1-15-92-30-6-7-6-5-92-30-5-12-3-1-92-30-6-6-2-15-92-30-4-14-0-0-92-30-4-14-2-10-92-30-6-0-11-2-92-30-8-9-12-2-92-30-6-13-8-8-92-30-6-7-8-1-92-30-5-11-6-4-92-30-7-10-12-11-92-30-7-6-8-4-92-30-4-14-11-10-92-30-3-0-0-2-92-30-4-14-12-14-92-30-6-2-1-1-92-30-8-14-10-11-92-30-4-14-0-10-92-30-6-2-7-14-92-30-4-14-0-13-92-30-5-1-15-10-92-30-4-14-15-11-92-30-4-15-5-5-92-30-9-6-3-3-92-30-5-1-4-9-92-30-7-6-8-4-92-30-4-14-1-12-92-30-8-9-7-15-92-30-3-0-0-2-92-30-0-0-10-92-30-5-3-12-13-92-30-5-9-0-13-92-30-7-6-8-4-92-30-8-1-14-10-92-30-6-2-1-1-92-30-6-0-0-0-92-30-7-5-9-1-92-30-15-15-0-12-92-30-6-2-1-1-92-30-5-3-14-10-92-30-6-7-0-9-92-30-4-14-0-13-92-30-5-0-5-12-92-30-5-7-3-0-92-30-6-3-13-0-92-30-5-3-4-7-92-30-8-1-14-10-92-30-5-13-15-1-92-30-15-15-0-12-92-30-6-2-4-13-92-30-8-0-15-13-92-30-4-15-13-13-92-30-6-3-0-1-92-30-5-15-12-3-92-30-6-6-7-10-92-30-7-6-8-4-92-30-7-10-3-3-92-30-5-11-9-10-92-30-3-0-0-2-92-30-5-9-8-2-92-30-6-7-9-12-92-30-4-14-0-13-92-30-8-0-15-13-92-30-8-0-13-12-92-30-5-1-15-10-92-30-15-15-0-12-92-30-9-0-10-3-92-30-5-3-14-10-92-30-6-7-0-9-92-30-4-14-0-0-92-30-6-7-6-1-92-30-8-13-14-15-92-30-3-0-0-2-92-30-0-0-10-92-30-8-15-13-9-92-30-4-14-2-10-92-30-4-14-1-6-92-30-7-5-4-12-92-30-15-15-0-12-92-30-9-7-5-14-92-30-9-14-13-1-92-30-5-3-7-3-92-30-7-6-7-13-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-5-3-4-1-92-30-15-15-0-9-92-30-0-0-10-92-30-5-3-14-10-92-30-8-9-8-1-92-30-6-7-0-9-92-30-4-14-2-4-92-30-4-14-11-10-92-30-5-3-12-10-92-30-4-14-14-5-92-30-4-14-0-10-92-30-15-15-0-12-92-30-5-12-3-1-92-30-4-15-1-10-92-30-6-7-0-9-92-30-4-14-0-13-92-30-5-14-7-3-92-30-7-11-4-9-92-30-0-0-10-92-30-5-3-14-10-92-30-6-7-0-9-92-30-6-7-4-0-92-30-5-1-4-9-92-30-6-2-4-0-92-30-6-7-0-9-92-30-4-14-11-10-92-30-6-2-4-13-92-30-8-0-15-13-92-30-5-9-7-13-92-30-8-13-7-7-92-30-6-7-6-5-92-30-0-0-10-92-30-5-9-8-2-92-30-6-7-9-12-92-30-6-2-1-1-92-30-6-6-2-15-92-30-4-14-0-10-92-30-5-14-1-13-92-30-15-15-0-12-92-30-6-2-1-1-92-30-8-9-8-1-92-30-6-2-8-10-92-30-4-14-11-10-92-30-7-12-7-11-92-30-3-0-6-14-92-30-6-0-12-5-92-30-6-1-1-15-92-30-9-6-6-4-92-30-6-3-8-9-92-30-0-0-10-92-30-8-15-13-9-92-30-4-14-2-10-92-30-4-14-1-6-92-30-7-5-4-12-92-30-15-15-0-12-92-30-9-7-5-14-92-30-9-14-13-1-92-30-5-3-7-3-92-30-7-6-7-13-92-30-0-0-10-92-30-15-15-0-8-92-30-5-3-4-1-92-30-4-14-0-0-92-30-15-15-0-9-92-30-0-0-10-92-30-7-9-3-14-92-30-4-14-10-4-92-30-5-9-2-7-92-30-9-0-14-8-92-30-5-2-0-6-92-30-9-0-15-13-92-30-6-6-2-15-92-30-6-7-0-9-92-30-5-11-11-3-92-30-7-6-8-4-92-30-15-15-0-12-92-30-5-9-7-13-92-30-5-9-7-13-92-30-4-15-13-13-92-30-6-2-10-4-92-30-8-1-14-10-92-30-5-13-15-1-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-5-3-4-1-92-30-4-14-8-12-92-30-15-15-0-9-92-30-0-0-10-92-30-5-5-4-10-92-30-0-0-2-14-92-30-0-0-2-14-92-30-6-2-1-1-92-30-5-3-12-8-92-30-6-3-8-9-92-30-8-15-13-11-92-30-8-1-14-10-92-30-5-13-15-1-92-30-7-6-8-4-92-30-6-0-2-10-92-30-5-7-0-8-92-30-5-11-5-0-92-30-9-1-12-12-92-30-4-14-8-6-92-30-0-0-10-92-30-5-9-7-13-92-30-9-6-11-14-92-30-5-3-13-7-92-30-0-0-2-14-92-30-0-0-2-14-92-30-0-0-10-92-30-5-3-8-11-92-30-6-2-9-1-92-30-4-15-4-15-92-30-15-15-0-12-92-30-6-1-6-2-92-30-6-1-6-2-92-30-6-13-8-8-92-30-5-3-1-6-92-30-6-3-8-9-92-30-5-4-2-7-92-30-0-0-10-92-30-6-6-2-15-92-30-6-2-1-1-92-30-7-6-8-4-92-30-9-5-14-14-92-30-9-8-9-8-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-5-3-4-1-92-30-4-14-0-9-92-30-15-15-0-9-92-30-0-0-10-92-30-6-2-1-1-92-30-7-14-12-15-92-30-5-14-3-8-92-30-5-2-2-0-92-30-6-3-8-9-92-30-8-1-14-10-92-30-5-13-15-1-92-30-7-6-8-4-92-30-6-0-15-3-92-30-6-12-13-5-92-30-3-0-0-2-92-30-8-15-12-7-92-30-5-3-11-11-92-30-7-6-8-4-92-30-6-2-1-1-92-30-5-11-9-14-92-30-5-7-2-8-92-30-6-6-2-15-92-30-5-9-2-10-92-30-5-3-14-15-92-30-6-0-1-5-92-30-4-14-8-6-92-30-3-0-0-2-92-30-8-11-14-5-92-30-6-11-7-11-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-5-3-4-1-92-30-5-6-13-11-92-30-15-15-0-9-92-30-0-0-10-92-30-5-4-2-12-92-30-8-11-15-4-92-30-0-0-2-0-92-30-0-0-6-9-92-30-0-0-6-14-92-30-0-0-7-4-92-30-0-0-6-10-92-30-0-0-2-0-92-30-9-0-15-13-92-30-5-15-8-8-92-30-6-2-1-0-92-30-5-2-9-15-92-30-3-0-0-2-92-30-9-0-10-3-92-30-5-9-7-13-92-30-4-14-8-6-92-30-15-15-0-12-92-30-6-2-1-1-92-30-4-14-0-13-92-30-6-6-2-15-92-30-3-0-0-2-92-30-6-2-1-1-92-30-6-6-2-15-92-30-5-14-9-15-92-30-7-2-6-9-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-5-3-4-1-92-30-4-14-9-4-92-30-15-15-0-9-92-30-0-0-10-92-30-5-11-8-3-92-30-5-15-8-8-92-30-7-15-8-14-92-30-5-9-7-13-92-30-3-0-0-2-92-30-5-11-8-3-92-30-6-12-3-8-92-30-8-15-13-12-92-30-4-14-0-13-92-30-5-12-5-14-92-30-4-14-8-14-92-30-6-2-1-1-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-5-3-4-1-92-30-5-1-6-13-92-30-15-15-0-9-92-30-0-0-10-92-30-5-9-8-2-92-30-6-7-9-12-92-30-6-2-1-1-92-30-5-7-2-8-92-30-4-14-8-12-92-30-6-11-2-1-92-30-5-1-4-3-92-30-15-15-0-12-92-30-6-2-1-1-92-30-4-14-0-0-92-30-5-11-9-10-92-30-6-6-2-15-92-30-4-14-2-10-92-30-7-5-12-5-92-30-5-10-0-7-92-30-5-14-9-15-92-30-7-2-6-9-92-30-3-0-0-2-92-30-6-12-10-1-92-30-9-5-1-9-92-30-15-15-0-12-92-30-6-2-1-1-92-30-5-5-9-12-92-30-6-11-2-2-92-30-4-15-6-0-92-30-15-15-0-12-92-30-4-15-6-0-92-30-8-15-12-7-92-30-6-7-6-5-92-30-15-15-0-12-92-30-8-11-10-9-92-30-6-2-1-1-92-30-6-7-4-0-92-30-4-14-8-6-92-30-4-15-6-0-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-5-3-4-1-92-30-4-14-0-3-92-30-15-15-0-9-92-30-0-0-10-92-30-6-2-1-1-92-30-7-14-12-8-92-30-4-14-8-14-92-30-7-6-15-8-92-30-4-15-14-1-92-30-4-14-8-6-92-30-15-15-0-12-92-30-4-14-0-13-92-30-7-11-10-1-92-30-6-0-0-14-92-30-4-14-4-8-92-30-5-2-10-10-92-30-5-2-9-11-92-30-9-0-15-13-92-30-4-14-0-13-92-30-4-15-1-10-92-30-6-7-0-9-92-30-5-9-7-13-92-30-7-6-8-4-92-30-7-14-13-3-92-30-6-7-9-12-92-30-3-0-0-2-92-30-0-0-10-92-30-8-15-13-9-92-30-7-9-12-13-92-30-4-14-11-10-92-30-9-0-0-2-92-30-5-4-0-8-92-30-0-0-2-0-92-30-0-0-7-10-92-30-0-0-7-3-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-5-3-4-1-92-30-4-14-5-13-92-30-15-15-0-9-92-30-0-0-10-92-30-6-13-3-11-92-30-7-7-4-0-92-30-7-6-8-4-92-30-6-1-0-15-92-30-4-14-4-9-92-30-5-12-3-1-92-30-6-6-2-15-92-30-6-2-8-10-92-30-9-6-6-4-92-30-6-2-1-1-92-30-4-14-14-5-92-30-5-9-1-6-92-30-7-6-8-4-92-30-4-14-11-10-92-30-6-7-4-0-92-30-6-3-8-9-92-30-3-0-0-2-92-30-8-9-8-1-92-30-4-14-4-8-92-30-6-2-8-10-92-30-6-2-1-1-92-30-6-7-4-0-92-30-6-3-8-9-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-4-14-8-12-92-30-5-3-4-1-92-30-15-15-0-9-92-30-0-0-10-92-30-6-2-1-1-92-30-7-7-1-15-92-30-6-0-7-6-92-30-5-15-12-3-92-30-3-0-0-2-92-30-4-14-0-9-92-30-5-3-14-5-92-30-8-11-13-13-92-30-4-14-0-13-92-30-7-9-11-11-92-30-2-0-1-12-92-30-6-2-1-1-92-30-2-0-1-13-92-30-15-15-0-12-92-30-6-0-3-11-92-30-6-6-2-15-92-30-6-0-15-3-92-30-7-7-4-0-92-30-8-1-14-10-92-30-5-13-15-1-92-30-7-6-8-4-92-30-5-14-9-15-92-30-7-2-6-9-92-30-3-0-0-2-92-30-5-2-3-0-92-30-4-14-8-6-92-30-7-9-3-14-92-30-4-15-1-10-92-30-4-14-0-10-92-30-4-14-0-0-92-30-5-11-9-10-92-30-6-6-2-15-92-30-4-14-2-10-92-30-7-9-7-8-92-30-5-11-11-3-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-4-14-8-12-92-30-5-3-4-1-92-30-4-14-0-0-92-30-15-15-0-9-92-30-0-0-10-92-30-8-15-13-9-92-30-4-14-2-10-92-30-5-12-0-15-92-30-5-14-9-15-92-30-7-2-6-9-92-30-5-3-12-8-92-30-5-15-0-0-92-30-5-15-12-3-92-30-4-14-8-6-92-30-15-15-0-12-92-30-7-14-13-9-92-30-5-11-8-3-92-30-7-7-0-11-92-30-7-7-0-11-92-30-8-1-15-4-92-30-9-0-12-1-92-30-7-5-6-10-92-30-15-15-0-12-92-30-8-11-10-9-92-30-5-11-8-3-92-30-9-6-11-14-92-30-8-15-12-7-92-30-4-14-0-0-92-30-4-14-0-11-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-4-14-8-12-92-30-5-3-4-1-92-30-4-14-8-12-92-30-15-15-0-9-92-30-0-0-10-92-30-5-15-0-0-92-30-5-15-12-3-92-30-6-7-0-9-92-30-7-5-2-8-92-30-7-6-8-4-92-30-8-11-13-13-92-30-15-15-0-12-92-30-6-2-1-1-92-30-8-0-15-13-92-30-7-11-1-1-92-30-6-11-7-11-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-4-14-8-12-92-30-5-3-4-1-92-30-4-14-0-9-92-30-15-15-0-9-92-30-0-0-10-92-30-6-13-3-11-92-30-7-7-4-0-92-30-7-6-8-4-92-30-6-1-0-15-92-30-4-14-4-9-92-30-5-12-3-1-92-30-6-6-2-15-92-30-4-14-3-10-92-30-4-14-8-6-92-30-5-2-1-11-92-30-9-0-2-0-92-30-6-11-7-11-92-30-4-14-10-1-92-30-3-0-0-2-92-30-7-3-11-0-92-30-5-7-2-8-92-30-15-15-0-1-92-30-7-10-12-11-92-30-5-2-3-11-92-30-15-15-0-1-92-30-9-10-6-12-92-30-4-14-0-10-92-30-15-15-0-1-92-30-0-0-10-92-30-15-15-0-8-92-30-4-14-8-12-92-30-5-3-4-1-92-30-5-6-13-11-92-30-15-15-0-9-92-30-0-0-10-92-30-6-11-7-11-92-30-4-14-10-1-92-30-15-15-0-12-92-30-6-6-2-15-92-30-6-2-1-1-92-30-5-4-2-12-92-30-8-15-12-7-92-30-6-7-0-0-92-30-6-13-6-10-92-30-6-15-2-11-92-30-7-6-8-4-92-30-4-14-8-11-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-4-14-8-12-92-30-5-3-4-1-92-30-4-14-9-4-92-30-15-15-0-9-92-30-0-0-10-92-30-6-2-1-1-92-30-7-6-8-4-92-30-4-14-0-9-92-30-8-9-12-2-92-30-5-13-15-2-92-30-7-14-12-15-92-30-6-11-6-10-92-30-5-2-3-0-92-30-4-14-8-6-92-30-6-5-14-0-92-30-5-3-14-15-92-30-6-5-5-1-92-30-8-3-6-15-92-30-7-6-8-4-92-30-5-7-3-0-92-30-6-11-6-5-92-30-3-0-0-2-92-30-5-13-15-2-92-30-7-14-12-15-92-30-4-14-0-13-92-30-9-0-0-2-92-30-5-4-0-8-92-30-6-13-3-11-92-30-7-7-4-0-92-30-4-14-8-6-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-4-14-8-12-92-30-5-3-4-1-92-30-5-1-6-13-92-30-15-15-0-9-92-30-0-0-10-92-30-6-2-1-1-92-30-5-7-2-8-92-30-4-14-0-13-92-30-5-0-5-12-92-30-5-7-3-0-92-30-6-4-6-7-92-30-6-11-12-1-92-30-6-2-1-1-92-30-7-6-8-4-92-30-5-15-12-3-92-30-6-6-7-10-92-30-3-0-0-2-92-30-4-14-3-10-92-30-4-14-12-0-92-30-4-14-4-8-92-30-8-15-13-8-92-30-8-0-15-13-92-30-6-13-3-11-92-30-5-2-3-0-92-30-7-3-11-0-92-30-5-7-2-8-92-30-5-4-6-2-92-30-3-0-0-2-92-30-6-2-1-1-92-30-6-7-0-9-92-30-5-11-11-6-92-30-4-14-11-10-92-30-15-15-0-12-92-30-6-2-1-1-92-30-4-14-3-10-92-30-4-14-8-6-92-30-4-14-0-13-92-30-8-11-10-9-92-30-4-14-13-6-92-30-4-14-14-12-92-30-8-11-10-8-92-30-5-3-8-12-92-30-6-2-1-1-92-30-15-15-0-12-92-30-6-2-1-1-92-30-7-7-9-2-92-30-4-14-8-6-92-30-5-15-8-8-92-30-5-9-1-10-92-30-7-12-13-15-92-30-7-12-13-5-92-30-7-6-8-4-92-30-4-14-1-12-92-30-8-9-7-15-92-30-3-0-0-2-92-30-4-14-13-6-92-30-4-14-14-12-92-30-7-7-0-11-92-30-8-13-7-7-92-30-6-7-6-5-92-30-8-15-13-8-92-30-7-2-3-1-92-30-6-2-1-1-92-30-3-0-0-2-92-30-8-9-8-1-92-30-4-14-0-13-92-30-7-1-3-6-92-30-6-2-1-1-92-30-6-5-14-9-92-30-5-12-3-1-92-30-6-7-0-9-92-30-6-11-7-11-92-30-7-6-8-4-92-30-7-4-0-6-92-30-7-5-3-1-92-30-4-14-8-6-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-4-14-8-12-92-30-5-3-4-1-92-30-4-14-0-3-92-30-15-15-0-9-92-30-0-0-10-92-30-4-15-6-0-92-30-4-14-0-13-92-30-8-9-8-1-92-30-6-11-7-11-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-4-14-8-12-92-30-5-3-4-1-92-30-5-1-6-11-92-30-15-15-0-9-92-30-0-0-10-92-30-6-11-7-11-92-30-4-14-10-1-92-30-6-6-2-15-92-30-9-0-10-3-92-30-4-14-4-8-92-30-7-15-8-14-92-30-5-9-7-13-92-30-3-0-0-2-92-30-3-0-0-2-92-30-4-14-3-10-92-30-4-14-12-0-92-30-4-14-4-8-92-30-4-14-0-13-92-30-8-0-15-13-92-30-7-14-13-9-92-30-6-2-1-1-92-30-5-4-6-2-92-30-15-15-1-15-92-30-0-0-10-92-30-15-15-0-8-92-30-4-14-8-12-92-30-5-3-4-1-92-30-4-14-5-13-92-30-15-15-0-9-92-30-0-0-10-92-30-8-12-0-1-92-30-6-7-6-5-92-30-5-9-3-8-92-30-5-9-3-8-92-30-6-2-1-1-92-30-15-15-1-15-92-30-8-15-12-7-92-30-6-7-6-5-92-30-7-2-3-1-92-30-6-2-1-1-92-30-5-5-4-10-92-30-15-15-0-1-92-30-15-15-0-1-92-30-6-12-10-1-92-30-6-7-0-9-92-30-6-6-2-15-92-30-5-4-2-7-92-30-3-0-0-2-92-30-5-9-7-13-92-30-7-6-8-4-92-30-6-2-1-1-92-30-6-6-0-14-92-30-7-6-7-13-92-30-4-14-8-6-92-30-15-15-0-12-92-30-6-2-1-1-92-30-8-15-13-9-92-30-5-12-3-1-92-30-5-3-11-11-92-30-6-11-7-11-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-4-14-0-9-92-30-5-3-4-1-92-30-15-15-0-9-92-30-0-0-10-92-30-4-14-11-10-92-30-9-0-15-13-92-30-4-15-1-10-92-30-6-11-7-11-92-30-4-14-10-1-92-30-15-15-0-12-92-30-8-15-13-9-92-30-4-14-2-10-92-30-8-11-11-14-92-30-5-11-9-10-92-30-4-14-0-13-92-30-9-5-1-9-92-30-15-15-0-12-92-30-6-3-3-10-92-30-5-1-6-12-92-30-5-14-7-3-92-30-7-6-8-4-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-4-14-0-9-92-30-5-3-4-1-92-30-4-14-0-0-92-30-15-15-0-9-92-30-0-0-10-92-30-6-2-1-1-92-30-9-6-8-15-92-30-6-5-15-6-92-30-5-3-14-15-92-30-4-14-14-5-92-30-5-3-11-11-92-30-6-11-7-11-92-30-15-15-0-12-92-30-8-15-13-9-92-30-6-6-2-15-92-30-6-2-1-1-92-30-7-6-8-4-92-30-6-7-4-3-92-30-5-2-2-9-92-30-15-15-0-12-92-30-7-7-1-15-92-30-6-8-13-2-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-4-14-0-9-92-30-5-3-4-1-92-30-4-14-8-12-92-30-15-15-0-9-92-30-0-0-10-92-30-6-2-1-1-92-30-6-11-13-4-92-30-8-15-8-3-92-30-6-4-12-5-92-30-9-5-7-15-92-30-5-0-5-10-92-30-8-11-10-1-92-30-5-2-1-2-92-30-3-0-0-2-92-30-6-11-13-4-92-30-5-9-8-2-92-30-4-14-12-0-92-30-4-14-4-8-92-30-6-5-15-6-92-30-9-5-15-4-92-30-4-14-12-0-92-30-4-14-4-8-92-30-5-7-3-0-92-30-7-0-11-9-92-30-5-4-8-12-92-30-4-14-12-0-92-30-4-14-4-8-92-30-4-14-11-10-92-30-4-14-0-0-92-30-8-13-7-7-92-30-0-0-2-0-92-30-0-0-7-10-92-30-0-0-7-3-92-30-0-0-2-0-92-30-4-14-0-0-92-30-7-12-7-11-92-30-7-6-8-4-92-30-3-0-0-2-92-30-8-0-0-12-92-30-4-14-1-4-92-30-4-14-12-14-92-30-4-14-0-13-92-30-5-9-3-1-92-30-7-14-10-6-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-4-14-0-9-92-30-5-3-4-1-92-30-4-14-0-9-92-30-15-15-0-9-92-30-0-0-10-92-30-5-9-2-7-92-30-5-11-11-6-92-30-8-9-8-1-92-30-5-7-5-10-92-30-6-3-0-1-92-30-4-14-0-11-92-30-5-3-11-11-92-30-3-0-0-2-92-30-4-14-0-13-92-30-8-9-8-1-92-30-6-11-7-11-92-30-3-0-0-2-92-30-6-2-1-1-92-30-5-13-15-2-92-30-7-14-12-15-92-30-8-15-13-9-92-30-4-14-4-8-92-30-9-6-11-14-92-30-8-15-12-7-92-30-4-14-8-6-92-30-15-15-0-12-92-30-5-12-3-1-92-30-8-11-10-9-92-30-4-15-6-0-92-30-4-14-14-12-92-30-4-14-5-15-92-30-9-6-11-14-92-30-8-15-12-7-92-30-4-14-0-0-92-30-4-14-0-11-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-4-14-0-9-92-30-5-3-4-1-92-30-5-6-13-11-92-30-15-15-0-9-92-30-0-0-10-92-30-6-2-1-1-92-30-8-15-13-8-92-30-8-0-15-13-92-30-7-7-0-11-92-30-5-2-3-0-92-30-6-6-0-14-92-30-5-9-2-9-92-30-7-6-8-4-92-30-5-9-2-10-92-30-9-6-3-3-92-30-5-4-1-7-92-30-15-15-1-15-92-30-0-0-10-92-30-15-15-0-8-92-30-4-14-0-9-92-30-5-3-4-1-92-30-4-14-9-4-92-30-15-15-0-9-92-30-0-0-10-92-30-8-15-13-9-92-30-5-3-14-15-92-30-6-0-1-6-92-30-7-6-8-4-92-30-6-5-8-7-92-30-5-11-5-7-92-30-15-15-0-1-92-30-8-15-13-9-92-30-7-14-13-13-92-30-6-7-1-11-92-30-7-6-8-4-92-30-5-8-15-0-92-30-9-7-15-3-92-30-15-15-0-1-92-30-6-2-1-1-92-30-5-9-7-13-92-30-5-1-7-4-92-30-5-9-4-11-92-30-5-4-4-0-92-30-15-15-0-1-92-30-0-0-10-92-30-15-15-0-8-92-30-4-14-0-9-92-30-5-3-4-1-92-30-5-1-6-13-92-30-15-15-0-9-92-30-0-0-10-92-30-4-14-0-13-92-30-8-9-8-1-92-30-6-11-7-11-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-4-14-0-9-92-30-5-3-4-1-92-30-4-14-0-3-92-30-15-15-0-9-92-30-0-0-10-92-30-6-5-14-0-92-30-5-12-3-13-92-30-7-6-8-4-92-30-6-14-3-4-92-30-6-7-1-11-92-30-3-0-0-2-92-30-6-5-14-0-92-30-5-12-3-13-92-30-5-7-3-0-92-30-7-13-2-2-92-30-5-3-13-6-92-30-15-15-0-12-92-30-5-11-11-3-92-30-6-0-1-5-92-30-5-9-3-1-92-30-5-3-11-11-92-30-3-0-0-2-92-30-6-7-0-9-92-30-5-15-9-7-92-30-5-2-3-0-92-30-5-15-12-5-92-30-7-1-3-6-92-30-4-15-1-10-92-30-6-7-0-9-92-30-5-9-3-1-92-30-5-3-11-11-92-30-15-15-0-12-92-30-5-3-14-15-92-30-9-0-10-3-92-30-6-6-2-15-92-30-5-9-7-13-92-30-4-14-0-13-92-30-5-11-11-9-92-30-6-6-1-3-92-30-6-2-4-13-92-30-5-15-9-7-92-30-5-2-3-0-92-30-7-6-8-4-92-30-5-4-4-0-92-30-15-15-0-1-92-30-4-14-3-10-92-30-4-14-12-0-92-30-4-14-4-8-92-30-4-15-6-0-92-30-8-0-15-13-92-30-8-15-13-9-92-30-4-14-4-8-92-30-8-15-7-11-92-30-6-7-7-14-92-30-6-11-14-11-92-30-6-5-14-0-92-30-8-13-1-15-92-30-7-15-6-10-92-30-5-7-3-0-92-30-7-9-11-11-92-30-5-15-0-0-92-30-6-2-1-1-92-30-15-15-1-15-92-30-8-8-4-12-92-30-4-14-8-6-92-30-15-15-0-12-92-30-4-14-14-5-92-30-5-4-0-14-92-30-4-14-12-0-92-30-4-14-4-8-92-30-9-0-15-13-92-30-4-14-0-13-92-30-8-9-8-1-92-30-5-9-7-13-92-30-4-14-8-6-92-30-3-0-0-2-92-30-8-15-13-9-92-30-6-8-3-7-92-30-6-7-0-0-92-30-5-9-7-13-92-30-15-15-0-12-92-30-6-5-14-2-92-30-7-1-3-6-92-30-5-11-11-3-92-30-6-0-1-5-92-30-5-9-3-1-92-30-5-3-11-11-92-30-7-14-13-9-92-30-8-1-14-10-92-30-5-13-15-1-92-30-5-14-2-6-92-30-6-7-6-5-92-30-9-6-11-14-92-30-5-3-13-7-92-30-9-0-10-3-92-30-5-12-3-1-92-30-5-1-8-13-92-30-4-14-5-15-92-30-4-14-0-13-92-30-8-9-8-1-92-30-7-13-2-2-92-30-5-3-13-6-92-30-5-9-7-13-92-30-4-14-8-6-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-4-14-0-9-92-30-5-3-4-1-92-30-5-1-6-11-92-30-15-15-0-9-92-30-0-0-10-92-30-5-9-8-2-92-30-6-7-9-12-92-30-8-11-15-11-92-30-5-2-3-0-92-30-8-15-13-9-92-30-9-1-12-12-92-30-6-1-1-15-92-30-8-9-12-9-92-30-6-0-7-6-92-30-5-15-12-3-92-30-15-15-0-12-92-30-8-11-15-7-92-30-4-14-3-14-92-30-6-2-10-5-92-30-6-2-1-1-92-30-3-0-0-2-92-30-6-2-1-1-92-30-4-14-5-15-92-30-6-1-1-15-92-30-8-9-12-9-92-30-6-2-1-1-92-30-6-0-7-6-92-30-5-15-12-3-92-30-7-6-8-4-92-30-4-14-0-13-92-30-8-8-4-12-92-30-3-0-0-2-92-30-15-15-0-8-92-30-8-15-13-9-92-30-5-3-14-5-92-30-8-11-13-13-92-30-6-6-2-15-92-30-4-14-0-13-92-30-6-6-2-15-92-30-5-12-3-1-92-30-6-3-3-10-92-30-6-0-7-6-92-30-5-15-12-3-92-30-7-6-8-4-92-30-15-15-1-15-92-30-0-0-10-92-30-15-15-0-8-92-30-4-14-0-9-92-30-5-3-4-1-92-30-4-14-5-13-92-30-15-15-0-9-92-30-0-0-10-92-30-5-1-12-6-92-30-5-9-0-7-92-30-5-1-8-13-92-30-8-8-6-5-92-30-5-1-14-0-92-30-9-0-14-8-92-30-8-1-15-4-92-30-9-0-12-1-92-30-7-5-6-10-92-30-15-15-0-12-92-30-7-7-0-11-92-30-7-7-0-11-92-30-8-0-15-13-92-30-4-14-0-13-92-30-8-0-15-13-92-30-5-15-7-11-92-30-5-14-9-5-92-30-6-4-6-7-92-30-6-11-12-1-92-30-6-2-1-1-92-30-3-0-0-2-92-30-8-11-15-4-92-30-4-14-0-13-92-30-5-11-9-10-92-30-8-15-13-8-92-30-8-0-15-13-92-30-6-2-1-0-92-30-5-2-9-15-92-30-0-0-2-0-92-30-0-0-7-10-92-30-0-0-7-3-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-5-6-13-11-92-30-5-3-4-1-92-30-15-15-0-9-92-30-0-0-10-92-30-8-11-10-8-92-30-5-3-8-12-92-30-7-7-0-11-92-30-5-2-3-0-92-30-5-2-2-11-92-30-4-14-11-10-92-30-5-15-0-0-92-30-5-15-12-3-92-30-3-0-0-2-92-30-4-15-6-0-92-30-4-14-14-12-92-30-8-0-15-13-92-30-8-15-13-9-92-30-4-14-4-8-92-30-5-15-0-0-92-30-5-15-12-3-92-30-6-6-2-15-92-30-6-7-0-9-92-30-4-14-12-0-92-30-4-14-4-8-92-30-7-9-13-8-92-30-8-11-12-0-92-30-5-4-1-7-92-30-15-15-1-15-92-30-15-15-0-1-92-30-15-15-0-1-92-30-6-5-5-9-92-30-6-5-5-9-92-30-6-2-1-1-92-30-5-4-2-7-92-30-15-15-0-1-92-30-15-15-0-1-92-30-5-7-2-8-92-30-7-14-11-15-92-30-7-11-4-9-92-30-15-15-0-1-92-30-15-15-0-1-92-30-0-0-10-92-30-15-15-0-8-92-30-5-6-13-11-92-30-5-3-4-1-92-30-4-14-0-0-92-30-15-15-0-9-92-30-0-0-10-92-30-4-15-6-0-92-30-6-6-2-15-92-30-4-14-0-13-92-30-6-6-2-15-92-30-5-15-8-8-92-30-6-0-15-3-92-30-7-7-14-5-92-30-9-0-5-3-92-30-4-14-3-10-92-30-4-14-12-0-92-30-4-14-4-8-92-30-6-2-1-1-92-30-8-15-13-9-92-30-4-14-4-8-92-30-4-14-2-7-92-30-15-15-1-15-92-30-5-6-14-0-92-30-4-14-3-10-92-30-4-15-6-0-92-30-4-14-0-13-92-30-7-7-14-5-92-30-9-0-5-3-92-30-6-2-1-1-92-30-5-3-13-1-92-30-7-5-1-15-92-30-4-14-8-6-92-30-4-14-12-0-92-30-4-14-4-8-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-5-6-13-11-92-30-5-3-4-1-92-30-4-14-8-12-92-30-15-15-0-9-92-30-0-0-10-92-30-6-2-1-1-92-30-5-9-2-9-92-30-7-5-1-15-92-30-5-12-3-1-92-30-6-6-2-15-92-30-6-0-11-2-92-30-8-9-12-2-92-30-7-6-8-4-92-30-5-5-4-10-92-30-3-0-0-2-92-30-4-15-6-0-92-30-5-3-14-15-92-30-4-14-14-5-92-30-8-11-10-4-92-30-4-14-3-10-92-30-15-15-0-12-92-30-6-2-1-1-92-30-6-7-0-9-92-30-7-12-11-14-92-30-7-9-5-14-92-30-7-5-12-5-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-5-6-13-11-92-30-5-3-4-1-92-30-4-14-0-9-92-30-15-15-0-9-92-30-0-0-10-92-30-4-15-13-13-92-30-6-3-0-1-92-30-6-13-8-8-92-30-6-7-8-1-92-30-6-7-0-0-92-30-5-9-7-13-92-30-4-14-8-6-92-30-3-0-0-2-92-30-6-2-1-1-92-30-5-11-11-3-92-30-6-0-1-5-92-30-4-14-0-0-92-30-9-10-13-8-92-30-5-1-7-4-92-30-7-14-13-9-92-30-5-15-13-8-92-30-4-14-8-6-92-30-4-14-4-11-92-30-5-2-4-13-92-30-6-6-2-15-92-30-6-0-0-14-92-30-4-14-4-8-92-30-5-4-14-13-92-30-7-6-8-4-92-30-3-0-0-2-92-30-5-2-2-11-92-30-6-0-15-3-92-30-8-11-10-9-92-30-6-2-1-1-92-30-5-1-8-13-92-30-5-4-14-13-92-30-7-11-2-12-92-30-4-14-8-12-92-30-6-11-2-1-92-30-3-0-0-2-92-30-4-15-6-0-92-30-8-11-11-0-92-30-4-15-4-15-92-30-4-14-8-6-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-5-6-13-11-92-30-5-3-4-1-92-30-5-6-13-11-92-30-15-15-0-9-92-30-0-0-10-92-30-6-0-15-3-92-30-5-3-13-1-92-30-6-6-0-14-92-30-4-14-0-0-92-30-7-9-12-13-92-30-6-11-6-6-92-30-5-6-6-8-92-30-15-15-0-12-92-30-8-0-15-13-92-30-6-2-8-10-92-30-5-7-3-0-92-30-7-4-0-3-92-30-7-0-11-8-92-30-8-8-12-2-92-30-7-6-8-4-92-30-9-0-10-3-92-30-7-9-12-13-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-5-6-13-11-92-30-5-3-4-1-92-30-4-14-9-4-92-30-15-15-0-9-92-30-0-0-10-92-30-6-2-1-1-92-30-8-9-8-1-92-30-6-2-8-10-92-30-6-6-2-8-92-30-5-9-2-9-92-30-5-3-13-1-92-30-7-5-1-15-92-30-7-6-8-4-92-30-4-14-0-0-92-30-5-2-0-7-92-30-5-15-13-8-92-30-6-3-8-9-92-30-15-15-0-12-92-30-8-15-13-9-92-30-6-8-3-7-92-30-5-12-3-1-92-30-6-12-10-1-92-30-6-7-0-9-92-30-8-13-1-15-92-30-7-15-6-10-92-30-6-1-1-15-92-30-3-0-0-2-92-30-6-11-12-15-92-30-4-14-0-0-92-30-5-9-2-9-92-30-6-5-14-9-92-30-4-14-0-10-92-30-9-1-9-2-92-30-6-7-6-5-92-30-15-15-0-12-92-30-4-14-12-14-92-30-6-2-1-1-92-30-6-6-2-15-92-30-5-7-8-3-92-30-5-7-3-14-92-30-5-15-0-0-92-30-5-9-12-11-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-5-6-13-11-92-30-5-3-4-1-92-30-5-1-6-13-92-30-15-15-0-9-92-30-0-0-10-92-30-6-2-1-1-92-30-6-7-0-9-92-30-5-15-3-10-92-30-8-15-14-11-92-30-7-5-12-7-92-30-3-0-0-2-92-30-6-11-6-3-92-30-5-9-8-2-92-30-4-15-6-0-92-30-4-15-1-10-92-30-7-7-0-11-92-30-5-2-3-0-92-30-6-2-1-1-92-30-6-0-3-11-92-30-6-6-2-15-92-30-7-14-13-9-92-30-4-15-6-0-92-30-7-6-8-4-92-30-6-0-15-3-92-30-6-12-13-5-92-30-9-15-1-3-92-30-6-3-8-12-92-30-3-0-0-2-92-30-5-15-5-3-92-30-7-1-3-6-92-30-5-1-8-5-92-30-5-11-11-9-92-30-6-2-1-1-92-30-7-7-0-11-92-30-8-15-12-7-92-30-4-14-8-6-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-5-6-13-11-92-30-5-3-4-1-92-30-4-14-0-3-92-30-15-15-0-9-92-30-0-0-10-92-30-5-11-11-3-92-30-6-0-1-5-92-30-8-8-10-11-92-30-6-2-9-11-92-30-5-15-0-3-92-30-8-8-10-11-92-30-5-11-6-4-92-30-7-10-12-11-92-30-9-0-10-3-92-30-4-14-4-8-92-30-5-14-9-4-92-30-8-11-14-5-92-30-4-14-12-14-92-30-4-14-0-0-92-30-5-15-0-0-92-30-5-9-12-11-92-30-5-12-3-1-92-30-4-14-0-13-92-30-8-9-8-1-92-30-8-7-8-13-92-30-5-1-6-5-92-30-3-0-0-2-92-30-8-15-13-8-92-30-6-6-2-15-92-30-6-0-15-3-92-30-7-6-8-4-92-30-6-7-0-9-92-30-7-0-11-9-92-30-5-9-1-10-92-30-15-15-0-12-92-30-8-7-8-13-92-30-5-1-6-5-92-30-4-14-0-0-92-30-5-2-10-3-92-30-8-13-2-8-92-30-4-14-11-10-92-30-7-15-10-4-92-30-8-15-13-9-92-30-7-9-12-13-92-30-6-1-1-10-92-30-8-8-2-2-92-30-7-6-8-4-92-30-8-8-4-12-92-30-4-14-3-10-92-30-15-15-1-15-92-30-5-1-7-6-92-30-5-11-9-14-92-30-5-1-6-8-92-30-6-7-4-0-92-30-6-3-8-9-92-30-5-12-3-1-92-30-5-9-7-13-92-30-4-14-8-6-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-5-6-13-11-92-30-5-3-4-1-92-30-5-1-6-11-92-30-15-15-0-9-92-30-0-0-10-92-30-6-2-1-1-92-30-5-7-2-8-92-30-8-1-14-10-92-30-5-5-14-8-92-30-3-0-0-2-92-30-8-1-14-10-92-30-5-10-3-1-92-30-8-1-14-10-92-30-4-14-5-0-92-30-7-6-8-4-92-30-5-14-9-15-92-30-7-2-6-9-92-30-3-0-0-2-92-30-6-2-1-1-92-30-6-2-8-10-92-30-8-1-14-10-92-30-5-13-15-1-92-30-6-6-11-4-92-30-9-7-3-2-92-30-5-7-2-8-92-30-8-15-13-9-92-30-9-1-12-12-92-30-15-15-0-12-92-30-5-13-15-2-92-30-7-14-12-15-92-30-6-5-14-0-92-30-6-12-13-5-92-30-6-3-3-13-92-30-5-6-13-14-92-30-4-14-8-6-92-30-5-4-2-7-92-30-15-15-0-1-92-30-5-13-15-2-92-30-7-14-12-15-92-30-6-2-1-0-92-30-4-14-3-10-92-30-6-0-15-9-92-30-4-14-11-10-92-30-8-11-10-8-92-30-5-3-8-12-92-30-7-6-8-4-92-30-4-14-11-10-92-30-4-14-8-6-92-30-5-4-2-7-92-30-15-15-0-1-92-30-8-15-13-9-92-30-4-14-2-10-92-30-5-12-0-15-92-30-5-14-9-15-92-30-7-2-6-9-92-30-7-6-8-4-92-30-5-15-12-3-92-30-9-1-12-12-92-30-5-13-15-2-92-30-7-14-12-15-92-30-9-14-13-1-92-30-6-6-9-7-92-30-7-6-8-4-92-30-4-14-0-13-92-30-8-8-4-12-92-30-4-14-8-6-92-30-5-4-6-2-92-30-15-15-0-1-92-30-8-11-14-5-92-30-6-7-4-0-92-30-6-3-8-9-92-30-4-14-8-6-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-5-6-13-11-92-30-5-3-4-1-92-30-4-14-5-13-92-30-15-15-0-9-92-30-0-0-10-92-30-6-2-1-1-92-30-6-6-2-15-92-30-4-14-2-10-92-30-5-2-2-9-92-30-5-13-15-2-92-30-4-14-3-11-92-30-4-14-4-9-92-30-8-0-0-5-92-30-3-0-0-2-92-30-6-2-1-1-92-30-5-0-5-10-92-30-7-6-8-4-92-30-4-14-15-11-92-30-4-15-5-5-92-30-4-14-8-11-92-30-6-0-12-5-92-30-9-0-15-13-92-30-6-6-2-15-92-30-4-14-3-10-92-30-4-14-8-6-92-30-6-2-1-1-92-30-5-9-7-13-92-30-3-0-0-2-92-30-5-4-0-12-92-30-6-5-15-6-92-30-15-15-0-12-92-30-5-0-5-10-92-30-7-6-8-4-92-30-4-14-15-11-92-30-4-15-5-5-92-30-4-14-8-11-92-30-4-14-5-15-92-30-9-0-15-13-92-30-6-6-2-15-92-30-4-14-3-10-92-30-4-14-8-6-92-30-6-4-6-7-92-30-6-11-12-1-92-30-6-2-1-1-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-4-14-9-4-92-30-5-3-4-1-92-30-15-15-0-9-92-30-0-0-10-92-30-5-4-8-12-92-30-5-2-2-11-92-30-4-14-11-10-92-30-7-6-15-8-92-30-5-9-0-4-92-30-4-14-4-5-92-30-4-14-8-6-92-30-15-15-0-12-92-30-5-12-3-1-92-30-4-15-1-10-92-30-6-1-1-15-92-30-8-9-12-9-92-30-8-1-14-10-92-30-5-13-15-1-92-30-5-3-7-3-92-30-5-12-0-6-92-30-8-8-10-11-92-30-8-11-10-8-92-30-5-3-8-12-92-30-3-0-0-2-92-30-7-1-3-6-92-30-5-4-0-14-92-30-6-0-15-3-92-30-5-2-9-14-92-30-6-12-13-5-92-30-9-0-0-3-92-30-7-9-11-11-92-30-3-0-0-2-92-30-8-15-13-9-92-30-7-9-12-13-92-30-5-9-3-1-92-30-6-3-10-7-92-30-6-1-1-15-92-30-8-11-10-9-92-30-6-2-1-1-92-30-6-1-1-15-92-30-5-2-3-0-92-30-5-11-11-3-92-30-6-0-1-5-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-4-14-9-4-92-30-5-3-4-1-92-30-4-14-0-0-92-30-15-15-0-9-92-30-0-0-10-92-30-4-15-6-0-92-30-4-14-3-10-92-30-4-14-12-0-92-30-4-14-4-8-92-30-5-7-5-10-92-30-6-3-0-1-92-30-8-11-15-11-92-30-5-2-3-0-92-30-8-15-13-9-92-30-9-1-12-12-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-4-14-9-4-92-30-5-3-4-1-92-30-4-14-8-12-92-30-15-15-0-9-92-30-0-0-10-92-30-8-13-1-15-92-30-8-0-15-13-92-30-9-1-12-15-92-30-5-0-5-12-92-30-6-11-6-2-92-30-15-15-0-1-92-30-15-15-0-1-92-30-5-14-0-12-92-30-6-7-1-11-92-30-8-0-15-13-92-30-5-0-5-12-92-30-4-14-0-11-92-30-6-7-6-5-92-30-5-2-2-11-92-30-5-3-12-13-92-30-5-15-3-9-92-30-4-14-8-6-92-30-15-15-0-1-92-30-6-2-1-1-92-30-6-6-2-15-92-30-5-15-8-8-92-30-5-14-9-15-92-30-7-2-6-9-92-30-15-15-0-12-92-30-5-3-14-15-92-30-6-6-2-15-92-30-5-1-8-13-92-30-5-9-1-10-92-30-7-6-8-4-92-30-5-3-13-1-92-30-6-12-12-4-92-30-4-14-5-15-92-30-6-5-14-0-92-30-6-12-13-5-92-30-6-5-3-9-92-30-5-3-13-8-92-30-15-15-0-1-92-30-15-15-0-8-92-30-4-15-6-0-92-30-8-11-15-4-92-30-7-6-8-4-92-30-5-1-8-13-92-30-5-9-7-13-92-30-5-3-12-8-92-30-6-7-0-9-92-30-4-14-12-0-92-30-4-14-4-8-92-30-7-5-2-8-92-30-5-4-6-2-92-30-15-15-0-9-92-30-6-2-1-1-92-30-8-9-8-1-92-30-6-3-1-1-92-30-6-2-1-8-92-30-8-1-14-10-92-30-5-13-15-1-92-30-15-15-0-1-92-30-6-2-1-1-92-30-6-6-2-15-92-30-5-14-9-15-92-30-7-2-6-9-92-30-5-3-12-8-92-30-6-0-0-14-92-30-4-14-4-8-92-30-6-8-3-7-92-30-15-15-1-15-92-30-8-0-15-13-92-30-6-2-5-3-92-30-8-13-2-5-92-30-5-9-2-7-92-30-9-0-14-8-92-30-5-2-0-6-92-30-4-14-11-10-92-30-5-12-3-1-92-30-5-3-14-15-92-30-4-14-14-5-92-30-4-14-8-6-92-30-3-0-0-2-92-30-6-2-1-1-92-30-9-7-0-0-92-30-8-9-8-1-92-30-7-5-2-8-92-30-8-8-4-12-92-30-5-2-10-8-92-30-8-11-12-1-92-30-6-6-0-14-92-30-8-15-13-9-92-30-4-14-0-0-92-30-7-0-11-9-92-30-3-0-0-2-92-30-4-15-4-6-92-30-6-6-2-15-92-30-6-12-14-8-92-30-6-1-0-15-92-30-4-14-0-13-92-30-8-9-8-1-92-30-8-15-12-7-92-30-5-2-0-6-92-30-5-1-7-3-92-30-6-12-14-8-92-30-7-14-13-3-92-30-6-7-9-12-92-30-15-15-0-12-92-30-8-15-13-9-92-30-6-6-2-15-92-30-6-7-0-0-92-30-5-4-0-14-92-30-7-6-8-4-92-30-5-15-14-0-92-30-5-4-4-10-92-30-3-0-0-2-92-30-0-0-10-92-30-15-15-0-8-92-30-4-14-9-4-92-30-5-3-4-1-92-30-4-14-0-9-92-30-15-15-0-9-92-30-0-0-10-92-30-4-14-14-5-92-30-4-14-0-10-92-30-9-0-15-13-92-30-6-6-2-15-92-30-8-0-14-1-92-30-8-11-13-13-92-30-15-15-0-12-92-30-4-14-0-13-92-30-8-9-8-1-92-30-5-7-2-8-92-30-6-1-0-15-92-30-3-0-0-2-92-30-5-9-2-7-92-30-9-0-14-8-92-30-5-2-0-6-92-30-6-3-0-7-92-30-7-3-11-0-92-30-5-11-9-14-92-30-5-4-6-8-92-30-5-6-15-4-92-30-4-14-11-10-92-30-7-15-10-4-92-30-15-15-0-12-92-30-4-14-0-14-92-30-6-11-6-3-92-30-5-7-2-8-92-30-7-7-0-11-92-30-7-6-8-4-92-30-4-15-6-0-92-30-6-5-14-0-92-30-5-1-7-3-92-30-3-0-0-2-92-30-6-2-1-1-92-30-6-2-8-10-92-30-6-2-1-1-92-30-7-6-8-4-92-30-6-0-15-3-92-30-6-12-13-5-92-30-5-1-9-9-92-30-5-7-2-8-92-30-8-15-13-9-92-30-9-1-12-12-92-30-15-15-0-12-92-30-5-12-3-1-92-30-4-14-0-13-92-30-6-12-6-1-92-30-6-7-13-3-92-30-5-9-2-7-92-30-5-11-11-6-92-30-7-6-8-4-92-30-6-5-15-6-92-30-9-5-15-4-92-30-7-14-11-15-92-30-4-14-8-6-92-30-3-0-0-2-92-30-5-14-0-12-92-30-6-7-1-11-92-30-4-15-6-0-92-30-4-14-14-12-92-30-5-15-12-3-92-30-6-6-7-10-92-30-8-15-13-8-92-30-7-11-9-7-92-30-6-2-1-0-92-30-7-1-9-15-92-30-3-0-0-2-92-30-6-2-1-1-92-30-8-15-13-8-92-30-5-9-7-13-92-30-3-0-0-2-92-30-6-7-0-9-92-30-6-0-12-5-92-30-7-14-14-10-92-30-5-9-8-2-92-30-6-7-9-12-92-30-4-14-0-13-92-30-6-0-15-3-92-30-8-11-15-4-92-30-5-1-15-10-92-30-6-7-6-5-92-30-5-3-14-15-92-30-4-14-14-5-92-30-5-1-9-9-92-30-4-14-0-11-92-30-6-7-6-5-92-30-15-15-0-12-92-30-6-7-0-0-92-30-5-9-7-13-92-30-4-14-0-13-92-30-8-9-8-1-92-30-5-3-8-11-92-30-6-2-9-1-92-30-5-15-12-3-92-30-9-1-12-12-92-30-3-0-0-2-92-30-0-0-10\n"}]},{"path":"/blog/数据结构算法","title":"数据结构算法","children":[{"path":"/blog/数据结构算法/base64算法.md","title":"base64算法","text":"base64 是一种用 64 个字符（1 字节 = 8bit）来表示任意 8bit 位的二进制数据的方法。\nbase64 一共只有 2 的 6 次方 64 个字符（6bit），而实际上 1 bytes = 8bit\n将二进制数据每 6bit 位替换成一个 base64 字符\n\n> 转自https://zhuanlan.zhihu.com/p/51407418\n\n```js\nfunction base64encode(text) {\n  let code = \"\"\n  let base64Code =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n  let res = \"\"\n\n  for (let i of text) {\n    let char = i.charCodeAt().toString(2)\n    // 将 toString 前面省略的0补上，补够8位二进制\n    for (let a = 0; a <= 8 - char.length; a++) {\n      char = 0 + char\n    }\n    code += char\n  }\n  // 不足 24 bit (也就是 3 bytes) 的情况进行特殊处理\n  // 只有 1 字节的时候\n  if (code.length % 24 === 8) {\n    // 补齐到 2*6 = 12 bit\n    code += \"0000\"\n    // 剩余缺失的 2 个 base64 字符用等号代替\n    res += \"==\"\n  }\n  // 只有 2 字节的时候\n  if (code.length % 24 === 16) {\n    // 补齐到 3 * 6 = 18 bit\n    code += \"00\"\n    // 剩余缺失的 1 个 base64 字符用等号代替\n    res += \"=\"\n  }\n\n  let encode = \"\"\n  for (let i = 0; i < code.length; i += 6) {\n    let item = code.slice(i, i + 6)\n    encode += base64Code[parseInt(item, 2)]\n  }\n\n  return encode + res\n}\n\nconsole.log(base64encode(\"this is a example\")) // dGhpcyBpcyBhIGV4YW1wbGU=\n```\n"},{"path":"/blog/数据结构算法/排序算法.md","title":"排序算法","text":"### 冒泡排序 O(N^2)\n\n> 它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从 A 到 Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。\n\n```ts\nexport const sortB = (args: number[]) => {\n  for (let i = 0; i < args.length; i++) {\n    // 关键点，j < args.length - (1 + i)\n    // 每一轮比较完毕，最后一个元素肯定是最大值，所以做后一个可以不比较，即每循环一次，比较次数减一\n    for (let j = 0; j < args.length - (1 + i); j++) {\n      // 每一趟都是比较相邻两个数\n      if (args[j] > args[j + 1]) {\n        const temp = args[j]\n        args[j] = args[j + 1]\n        args[j + 1] = temp\n      }\n    }\n  }\n  return args\n}\n```\n\n### 快速排序 O(nlogn)\n\n> 通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。\n\n```ts\nexport function sortQuick(arr: number[]): number[] {\n  // 终止条件，被拆分为一个元素\n  if (arr.length <= 1) return arr\n\n  // 找到中间元素索引\n  const index = Math.floor(arr.length / 2)\n  // 中间元素值\n  const stand = arr[index]\n  // 去掉中间元素\n  arr.splice(index, 1)\n\n  const left = []\n  const right = []\n  // 以中间元素为基准，小的值放在左边，大的放右边\n  arr.forEach(v => (v < stand ? left.push(v) : right.push(v)))\n\n  // 连接好left、中间元素和right，递归\n  // 注意此处为二分法，left会不断拆分成左中右\n  return sortQuick(left).concat(stand, sortQuick(right))\n}\n```\n\n### 选择排序 O(N^2)\n\n> 从头至尾扫描序列，找出最小的一个元素，和第一个元素交换，接着从剩下的元素中继续这种选择和交换方式，最终得到一个有序序列。\n\n```ts\nexport function sortSelect(arr: number[]) {\n  const len = arr.length\n  for (let i = 0; i < len; i++) {\n    let index = i\n    for (let j = i + 1; j < len; j++) {\n      // 每一轮比较选出最小值索引\n      if (arr[j] < arr[i]) {\n        index = j\n      }\n    }\n    const temp = arr[i]\n    arr[i] = arr[index]\n    arr[index] = temp\n  }\n  return arr\n}\n```\n"}]},{"path":"/blog/浏览器API(BOM)","title":"浏览器API(BOM)","children":[{"path":"/blog/浏览器API(BOM)/MutationObserver.md","title":"MutationObserver","text":"监视DOM元素变动。\n\n> DOM3 Events规范的一部分\n\n### 实现 Microtask\n\n```ts\nexport interface Microtask extends MutationCallback {}\n\nexport function microtask(task: Microtask) {\n  // 构造函数参数是一个function类型\n  const observer = new MutationObserver(task)\n\n  // 创建一个测试dom节点\n  const element = document.createTextNode('')\n\n  // 监听dom节点，\n  observer.observe(element, {\n    characterData: true\n  })\n\n  // 修改dom节点，触发MutationCallback\n  element.data = ''\n}\n```\n\n"},{"path":"/blog/浏览器API(BOM)/requestAnimationFrame.md","title":"requestAnimationFrame","text":"下次重绘之前调用指定的回调函数。\n\n> 回调函数每秒执行60次\n\n用于动画更新。\n\n动画不要使用setInterval！它不是严格的时间间隔触发。它是每隔一段时间将回调放入宏任务执行栈中。如果当前执行栈被阻塞，则会影响回调间隔。"},{"path":"/blog/浏览器API(BOM)/requestIdleCallback方法.md","title":"requestIdleCallback方法","text":"## 简介\n\n这个 API 是 BOM API 之一，即 window.requestIdleCallback，由浏览器实现。在 Node.js 上没有此 API 的实现。\n\n它会在浏览器空闲时期调用注册的函数，即 JS 引擎的空闲时期。\n\n函数签名(由于还处于提案阶段，Typescript 并没有给出函数的声明，所以需要自己 declare 声明函数的签名)\n\n```typescript\ndeclare interface IdleDeadline {\n  readonly didTimeout: boolean;\n  timeRemaining(): number; // 时间片中剩余时间(0 <= timeRemained < 50)\n}\n\ndeclare type IdleOptions = {\n  timeout: number;\n};\n\ndeclare type IdleCallback = (deadline: IdleDeadline) => void;\n\ndeclare function requestIdleCallback(callback: IdleCallback): number;\n\ndeclare function requestIdleCallback(\n  callback: IdleCallback,\n  options: IdleOptions\n): number;\n```\n\n浏览器将时间以每 50ms 切成片，每个时间片内会执行 JS 线程。如果有空余时间，会执行 IdleCallback，并传入一个 deadline 对象，用于获取剩余空闲时间。\n\n"}]},{"path":"/blog/浏览器基础","title":"浏览器基础","children":[{"path":"/blog/浏览器基础/从输入URL到页面渲染.md","title":"从输入URL到页面渲染","text":"1. 用户输入url地址，从DNS解析IP地址\n\n2. 浏览器向服务器发送http请求，如果服务器段返回以301之类的重定向，浏览器根据相应头中的location再次发送请求\n\n3. 服务器端接受请求，处理请求生成html代码，返回给浏览器，这时的html页面代码可能是经过压缩的\n\n4. 浏览器接收服务器响应结果，如果有压缩则首先进行解压处理，紧接着就是页面解析渲染\n\n### 解析渲染流程：\n\n1. 解析HTML\n2. 构建DOM树\n3. DOM树与CSS样式进行附着构造呈现树\n4. 布局\n5. 绘制"},{"path":"/blog/浏览器基础/浏览器内核.md","title":"浏览器内核","text":"浏览器内核有两部分：渲染引擎、JS引擎。\n\n> 渲染引擎对HTML文档进行解析并将其显示在页面上\n\n### 主流渲染引擎\n\nFireFox：Gecko\n\nIE：Trident\n\n> 2015年微软推出自己新的浏览器edge,使用edge引擎\n\nChrome\\Safari\\Opera：webkit引擎\n\n> Opera早期使用Presto引擎\n\n> 13年Chrome和Opera开始使用Blink引擎  \n\n### 主流 JS 引擎\n\n老版本IE：Jscript引擎\n\nIE9之后：Chakra引擎\n\n> edge：Chakra引擎\n\nFireFox：monkey系列引擎\n\nSafari：SquirrelFish系列引擎\n\nOpera：Carakan引擎\n\nChrome：V8引擎\n\n> Node.js：V8引擎"}]},{"path":"/blog/练习","title":"练习","children":[{"path":"/blog/练习/来测试一下？.md","title":"来测试一下？","text":"### Web 前端基础知识 100 问\n\n1. React 生命周期\n2. webpack 原理\n3. css 清除浮动\n4. css 左右定宽中间自适应\n5. 事件代理\n6. 闭包\n7. 继承方法有哪些，各有什么优势\n8. 选择排序，各排序复杂度\n9. xss csrf\n10. 前端性能优化\n11. http 缓存机制\n12. 个人长处和短处\n13. css 选择器优先级\n14. html 语义化\n15. 块级和行内有哪些\n16. display 值有哪些各什么特点\n17. box sizing 值有哪些\n18. 怎么判断数据类型，instanceof\n19. 阻止冒泡，阻止默认行为\n20. http header 内容\n21. 垃圾回收机制\n22. 两个页面通信\n23. 介绍 less\n24. 原型链和原型\n25. 说说 rollup\n26. vue 数据双向绑定\n27. redux 和 react redux\n28. 几种 http 状态码\n29. 跨域方式\n30. 几种 css 伪类\n31. css 常见布局\n32. 伪数组\n33. 移动端了解\n34. html5 新特性\n35. url 到渲染一系列\n36. 常用的图片格式\n37. new 原理\n38. 静态变量怎么实现\n39. 左栏定宽右栏自适应\n40. 反转链表\n41. css position 各种特点\n42. amd 和 cmd 理解\n43. 实现一个观察者模式\n44. 生成器用法\n45. es6 继承和 es5 不同\n46. 宏任务和微任务知道么\n47. 虚拟 dom 原理\n48. 双向绑定怎么实现\n49. css 动画怎么实现\n50. react redux 的 connect 函数做了什么，它怎么传的 store\n51. 怎么判断一个空对象\n52. Object 常用方法\n53. websocket 原理\n54. tcp 三次握手四次挥手\n55. React state 更新机制\n56. React fiber 机制\n57. 纯 css 开关按钮\n58. 原生 ajax\n59. 最得意的 github 项目\n60. restful 接口\n61. 受控组件和非受控组件\n62. css 旋转三角形\n63. js 正则判断手机号\n64. react 是哪种架构\n65. flex 属性都说下\n66. 原型链对象构造函数之间关系\n67. dom2 dom3 标准\n68. dom 事件绑定几种方式\n69. 项目中用到的技术栈，遇到头疼点，怎么解决 https 和 http 区别是什么\n70. webpack 多入口怎么配置，怎么分割\n71. 按需加载实践过吗\n72. 协商缓存和强制缓存\n73. dom 事件里 target 和 currentTarget 区别\n74. react context 的理解\n75. margin 重叠\n76. passive event\n77. 浮动原理\n78. js 基本类型和复杂类型\n79. 闭包 iife 里的 this\n80. 浏览器并行下载数量\n81. 图片资源异步加载\n82. jwt 优缺点\n83. redux 解决了什么\n84. 回调函数 promise async 区别\n85. setState 之后的生命周期\n86. xss 怎么防范，完成一次 csrf 攻击步骤\n87. css3 圆形头像\n88. seo\n89. ifc 和 bfc\n90. 双飞翼和圣杯\n91. 水平垂直居中 4 个以上并各有什么限制\n92. web worker 和 websocket 用途\n93. h5 新增的语义化标签\n94. css 优先级和权重\n95. css 实现响应式\n96. addEventListener 和 onclick 有什么区别\n97. 说几个 es6 特性\n98. new 和 Object.create 区别\n99. BOM 和 DOM 基础方法例如取 url port origin 协议\n100. 前端路由原理\n101. 后端能否收到 hash 部分\n102. 怎么触发回流重绘怎么避免\n103. call bind apply 怎么实现\n104. 怎么实现继承\n105. get 和 post 区别\n106. 深浅拷贝，序列化\n107. 实现 promise\n108. 闭包特性用途缺点\n109. let const var 声明提升是什么\n110. 生成器迭代器\n111. symbol 理解\n112. Set 数据结构\n113. 解构\n114. commonjs 和 es6 模块有什么区别\n115. 动态路由\n116. js 并发模型\n117. js 的 iterator 和 iteratable 是什么，有哪些内置的 iterator\n118. css 会阻塞 dom 树渲染和解析么\n119. autocomplete 输入框实现\n120. restful 常用接口有哪些，各有什么特点\n121. 浏览器后退重复 post 怎么解决\n122. raf 和 ric 区别\n123. html 语义化理解\n124. html5 之前有语义化的标签\n125. ul ol dl 三种列表标签的适用场景\n126. cookie localStorage sessionStorage 三者区别和应用场景\n127. jwt 理解\n128. 分片上传\n129. fetch 和 ajax 区别是什么\n130. 浏览器打开一个页面前端缓存了哪些东西\n131. 快速排序有几种\n132. 新的事件流和老的事件流\n133. css will-change 作用\n134. dns 是哪一层协议\n135. webassembly 知道么\n136. options 除了返回 200 响应还有什么办法\n137. 怎么判断两个矩形相交\n"}]}]},"JHome":{"title":"saber2pr","infor":"魂魄妖梦al、web前端"},"JAbout":{"contents":["一个98年在北方出生的INTJ处女座蓝孩子。","在一所离家2小时列车距离的普通高校就读。","曾经在一场脸红的冒险中失败导致现在变得没有感情。","认为yooo梦是世界上最帅最吼看的人。","现在认为机器拥有感情，愿意使用js或者c与之交流。","有生之年想要去一次秋叶原。(如果有钱的话)"],"audio":{"info":"听首音乐放松下~","src":"https://music.163.com/song/media/outer/url?id=513336178.mp3","name":"Blackout - (ハルトマンの妖怪少女).mp3"}},"JLinks":{"owns":[{"name":"github","href":"https://github.com/Saber2pr","message":"全球最大程(jiao)序(you)员社区"},{"name":"bilibili","href":"https://space.bilibili.com/71959910/#/","message":"动漫废宅网qwq"},{"name":"掘金","href":"https://juejin.im/user/5d5f7e0c5188256ec01d80f4","message":"大概每周一篇Hello World(咕咕咕)"},{"name":"知呼","href":"https://www.zhihu.com/people/hun-po-yao-meng-15/activities","message":"欢迎分享你刚编的故事("},{"name":"网易云","href":"https://music.163.com/#/user/home?id=412481832","message":"推是谁？[doge]"},{"name":"csdn","href":"https://blog.csdn.net/u011607490","message":"专业IT社区?"}],"friends":[{"name":"Iriasu","href":"https://tsuinosora.moe"}]},"JProject":[{"name":"@saber2pr/react","href":"https://github.com/Saber2pr/react","content":"React-Like in Typescript."},{"name":"@saber2pr/ioc","href":"https://github.com/Saber2pr/saber-ioc","content":"Injector for Typescript IOC."},{"name":"@saber2pr/reflect","href":"https://github.com/Saber2pr/-saber2pr-reflect","content":"Typescript Reflector."},{"name":"@saber2pr/request","href":"https://github.com/Saber2pr/-saber2pr-request","content":"HTTP Request Library."},{"name":"@saber2pr/fp","href":"https://github.com/Saber2pr/fp","content":"Functional programing in async | sync | lazy."},{"name":"leetcode","href":"https://github.com/Saber2pr/leetcode","content":"My leetcode progress."}],"lastDate":"2019-9-17 15:42:53"}