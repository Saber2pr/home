[
  {
    "name": "saber2pr的窝",
    "content": "你说既视感？错觉！\n为什么会有这个Page？大概我想记录自己的心得但穷于购买server service。\n为什么要搞一些闪瞎眼的Animation？？如果没有过渡你可能想马上关掉这个呆掉的Page。\n这个page上面大概有些什么值得我看的东西？如果你对二刺猿感兴趣我建议你点击`链接`->`bilibili`离开这里。\n技术栈：React + Typescript + Less + saber-router + @saber2pr/redux + @saber2pr/react-code\n开发工具：ubuntu + vscode + git + nodejs + firefox",
    "href": "/blog/hello"
  },
  {
    "name": "reflect-metadata中HashMap巨大Object的读取速度优化",
    "content": "HashMap原理比较复杂，不是这篇文章重点。(其实是本菜鸡不懂(\n\nreflect-metadata中实现了HashMap的polyfill，需要能快速读取数据，而js的Object当属性很多的时候性能并不好，不然就不会有Map了。然而reflect-metadata中HashMap用的是Dictionary，利用了一个非常hack的方法。\nHashMap\n```ts\ntype HashMap<V> = Record<string, V>\n\nconst HashMap = {\n  // create an obj into dictionary mode (a.k.a. \"slow\" mode on v8)\n  create: <V>() => MakeDictionary(Object.create(null) as HashMap<V>),\n\n  has: <V>(map: HashMap<V>, key: string | number | symbol) =>\n    Object.prototype.hasOwnProperty.call(map, key),\n\n  get: <V>(map: HashMap<V>, key: string | number | symbol): V | undefined =>\n    Object.prototype.hasOwnProperty.call(map, key) ? map[key as string | number] : undefined\n}\n```\n好像有点简单啊，除了有个MakeDictionary函数\n在reflect-metadata源码中最后有一个MakeDictionary函数，来看看这个神奇的函数\nMakeDictionary\n```ts\n// uses a heuristic used by v8 and chakra to force an obj into dictionary mode.\nfunction MakeDictionary<T>(obj: T): T {\n  ;(<any>obj).__ = undefined\n  delete (<any>obj).__\n  return obj\n}\n```\n它给obj添加了__属性，值为undefined，然后又删了，注释解释说这可以启发v8或者査克拉引擎将Object转换到dictionary mode（？？），可以大幅提升Object属性读取的速度？\n\n下面来测试一下（Node环境）\n先写一个fill函数，用来填充属性\n```ts\nfunction fillSomething(obj: Object, size: number = 100000) {\n  while (size--) obj[size] = Math.random()\n}\n```\n测试一下读取速度\n```ts\n// 普通obj\nconst obj = {}\n// 填充100000个随机属性\nfillSomething(obj)\n\nconsole.time('obj')\nconsole.log(obj['5555'])\nconsole.timeEnd('obj') // obj 2.813ms\n\n\n// 创建一个hashMap\nconst hashMap = HashMap.create()\n// 填充100000个随机属性\nfillSomething(hashMap)\n\nconsole.time('hashMap')\nconsole.log(HashMap.get(hashMap, '5555'))\nconsole.timeEnd('hashMap') // hashMap 0.398ms\n```\n足足快了30多倍？\n真假？。。其实把上面两个time顺序颠倒也不是这么回事，但出自rbuckton大神之手应该不是随便写的\n\n所以以后遇到巨大Object的时候不妨用此方法优化一下试试。",
    "href": "/blog/objToDic"
  },
  {
    "name": "一行代码实现koa中间件",
    "content": "本质就是把下一层的async函数包装一层后传给上一层await调用，和递归差不多。\n```ts\nconst process = (...jobs) => jobs.reduceRight((next, job) => async () => await job(ctx, next), () => Promise.resolve())\n```\n\n测试\n```ts\nasync function job1 (ctx, next) {\n  console.log(ctx.name, '1');\n  await next();\n  console.log(ctx.name, '5');\n}\n\nasync function job2 (ctx, next) {\n  console.log(ctx.name, '2');\n  await next();\n  console.log(ctx.name, '4');\n}\n\nasync function job3 (ctx) {\n  console.log(ctx.name, '3');\n}\n\nconst ctx = { name: 'koa' }\n\nconst process = (...jobs) => jobs.reduceRight((next, job) => async () => await job(ctx, next), null)\n\nprocess(job1, job2, job3)() // koa 1, koa 2, koa 3, koa 4, koa 5\n```\n",
    "href": "/blog/saber-koa"
  },
  {
    "name": "使用reflect-metadata反射实现Typescript-IOC及依赖注入",
    "content": "1. 首先说明要干什么。\n\n实现一个存放类的容器，并能按照类之间依赖关系自动构建实例。\n\n2. 核心原理：\n\n利用Reflect-metadata获取构造函数中的参数类型(design:paramtypes)。\n\n利用Reflect-metadata在目标对象上定义和获取元数据。\n\n先举个例子：\n```ts\nclass Service {\n  constructor() {}\n}\n\nclass Controller {\n  constructor(private Service: Service) {}\n}\n```\n一个Service类，一个Controller类，其中Controller类依赖于Service类。\n利用Reflect可以轻松获取Controller类构造函数中的paramtypes。\n\n实现@Injectable\nInjectable函数返回一个类装饰器，利用反射获取被装饰类的构造函数的参数类型。\n\n先举个栗子\n```ts\nconst enum DESIGN {\n  PARAMTYPES = 'design:paramtypes'\n}\n\nfunction Injectable(): ClassDecorator {\n  return target => {\n    // 获取被装饰类的构造函数的参数类型\n    const ctorParams: any[] = Reflect.getMetadata(DESIGN.PARAMTYPES, target)\n    console.log(ctorParams)\n  }\n}\n```\n利用设计键获取到参数列表：\n```ts\nclass Service {\n  constructor() {}\n}\n\n@Injectable() // [ Service() ]\nclass Controller {\n  constructor(private Service: Service) {}\n}\n```\n@Injectable\n```ts\nexport function Injectable(id?: PropertyKey): ClassDecorator {\n  return target => {\n    // 索引键值默认为target.name\n    const token = id || target.name\n\n    // 如果token已存在则抛出Error\n    if (Reflect.hasMetadata(token, MetaStore)) {\n      throw new Error(`id:[${String(token)}] is existed!`)\n    } else {\n      Reflect.defineMetadata(token, target, MetaStore)\n    }\n  }\n}\n```\nInjectable提供了可选项id?，用来避免命名冲突。\n这样只要被Injectable()装饰过的类都会被缓存到MetaStore中。\n\n实现@Inject\n读写target身上的元数据，用于注入依赖信息\n```ts\n// target身上的元数据类型\nexport interface DepMeta {\n  id: PropertyKey\n  index: number\n}\n\nexport function Inject(id: PropertyKey): ParameterDecorator {\n  return (target, _, index) => {\n    // 获取到target身上的DepMeta数组，如果没有就创建一个新的\n    const depMeta = Reflect.getMetadata<Array<DepMeta>>(CUSTOM.META, target) || []\n    // push一个DepMeta，id和index\n    depMeta.push({ id, index })\n    // 再把DepMeta数组保存回target\n    Reflect.defineMetadata(CUSTOM.META, depMeta, target)\n  }\n}\n```\nindex即参数在函数(构造函数)arguments数组中的下标，id为Injectable-token\n例如：\n```ts\n@Injectable() // 缓存到MetaStore, id: 'Service'.\nclass Service {\n  constructor() {}\n}\n\ninterface IService {}\n\nclass Controller {\n  // inject注解，请求依赖为id- 'Service', 位置为index- 0\n  constructor(@Inject('Service') private Service: IService) {}\n}\n```\n实现Injector函数（核心）\n从入口开始构建整个依赖树，并生成根实例\n```ts\ntype Constructor<T = any> = { new (...args: Array<any>): T }\n\nexport function Injector(Target: Constructor): any {\n  // 如果是静态类或singleton，直接返回\n  if (Reflect.hasMetadata(CUSTOM.STATIC, Target)) return Target\n\n  // 获取Target构造函数的参数列表\n  const deps = Reflect.getMetadata<Array<Constructor>>(DESIGN.PARAMTYPES, Target) || []\n\n  // 获取target身上DepMeta数组\n  const tags = Reflect.getMetadata<DepMeta[]>(CUSTOM.META, Target) || []\n  \n  // 遍历DepMetas\n  tags.forEach(tag => {\n    // 如果MetaStore中注册了tag.id\n    if (Reflect.hasMetadata(tag.id, MetaStore)) {\n      // 按index将Injectable插入deps中\n      deps[tag.index] = Reflect.getMetadata(tag.id, MetaStore)\n    } else {\n      // Inject请求的Injectable没有在MetaStore中找到\n      throw new Error(`injected dep:${String(tag.id)} not found`)\n    }\n  })\n  // 递归构建,当deps为空时结束\n  const instances = deps.map(Injector)\n\n  // 注入依赖，生成实例\n  return new Target(...instances)\n}\n```\nDemo\n```ts\n@Injectable()\nclass Service {\n  public getUser() {\n    return 'saber!'\n  }\n}\n\nclass Controller {\n  public constructor(@Inject('Service') private Service: Service) {}\n\n  public test() {\n    console.log(this.Service.getUser())\n  }\n}\n\nconst app = Injector(Controller)\n\napp.test() // 'saber!\n```",
    "href": "/blog/saber-ioc"
  },
  {
    "name": "reflect-metadata实现及其原理",
    "content": "最近研究了一下reflect机理，基本算是实现了所有的api，也通过了全部的测试用例，所以想写一篇文章记录下来。\n\nps: 这篇文章最先发在我的知呼上：https://zhuanlan.zhihu.com/p/65239993\n\nReflect Metadata 是 ES7 的一个提案，它主要用来在声明的时候添加和读取元数据。Typescript使用反射需要安装一个依赖reflect-metadata.\n\nTypescript拥有完整的面向对象支持，依赖注入技术(DI)已经在Angular、Nest等框架中大规模使用了，就像这样\n```ts\nclass Service {}\n\nclass Controller {\n  constructor(private Service: Service) {}\n}\n```\nIOC框架会获取到Controller所依赖的类，并注入一个实例或类本身，这其中获取依赖类型就会利用到Reflect。\n\n利用元数据设计键(Design-time type annotations)来获取依赖类型\n```ts\nfunction Injectable(): ClassDecorator {\n  return target => {\n    const metadata = Reflect.getMetadata('design:paramtypes', target)\n    console.log(metadata)\n  }\n}\n\nclass Service {\n  constructor() {}\n}\n\n@Injectable() // 输出 [ Service() ]\nclass Controller {\n  constructor(private Service: Service) {}\n}\n```\n这里需要利用装饰器来获取。这里也许你会有疑问，元数据需要先defineMetadata然后在getMetadata获取，这里为什么可以直接获取?\n\n答案就是如果tsconfig开启了emitDecoratorMetadata为true，编译器会发出设计元数据信息。\n\n来看下ts编译后的js (已开启emitDecoratorMetadata)\n```ts\n// 判断一下Reflect上是否有metadata函数，并赋给__metadata\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nvar Service = /** @class */ (function () {\n    function Service() {\n    }\n    return Service;\n}());\n\nvar Controller = /** @class */ (function () {\n    function Controller(Service) {\n        this.Service = Service;\n    }\n    Controller = __decorate([\n        Injectable(),\n        // 注意这里，使用design-paramtypes键定义了元数据，值是[Service]\n        __metadata(\"design:paramtypes\", [Service])\n    ], Controller);\n    return Controller;\n}());\n\nfunction Injectable() {\n    return function (target) {\n        Reflect.getMetadata('design:paramtypes', target);\n    };\n}\n```\n开启了emitDecoratorMetadata编译器会自动生成Design-time type annotations。\n\n通过前面的实例，容易发现，Reflect内部应该会维护一个Map，而且应该是WeakMap，\n\n果不其然，在reflect-metadata这个库内部使用了WeakMap，而且居然还自带了Polyfill(不仅实现WeakMap，还有HashMap...)\n[[Metadata]] internal slot\nhttps://github.com/rbuckton/reflect-metadata/blob/master/Reflect.ts#L685\nnaive WeakMap shim\nhttps://github.com/rbuckton/reflect-metadata/blob/master/Reflect.ts#L1725\n\n下面开始实现。\n\n实现 Reflect.defineMetadata\n首先创建一个WeakMap，它将负责维护所有类和类实例的元数据，以及解决自动回收问题。\n```ts\nconst Metadata = new WeakMap<Object, Map<PropertyKey, MetadataMap>>()\n```\n这是一个高维的Map，对于每个Object也就是类或者类实例，它都关联一个Map。这个Map里又关联了属性key和属性所对应的Map，所以又是一个高维的Map。所以这个Metadata就是一个3维的Map。\n```ts\nexport function defineMetadata(\n  metadataKey: MetadataKey,\n  metadataValue: MetadataValue,\n  target: Object,\n  propertyKey: PropertyKey = DEFAULTKAY \n) {\n  // 判断target类型，因为target将作为WeakMap的键，必须是对象类型\n  if (typeof target !== 'object' && typeof target !== 'function') {\n    throw new TypeError()\n  }\n  \n  // 如果传入propertyKey，要求类型为string或symbol\n  if (propertyKey && !['string', 'symbol'].includes(typeof propertyKey)) {\n    throw new TypeError()\n  }\n\n  // 从Metadata中获取target关联的Map，若没有就创建一个新的Map\n  const targetMetadata =\n    Metadata.get(target) || new Map<PropertyKey, MetadataMap>()\n\n  // 将targetMetadata再保存回Metadata中\n  Metadata.set(target, targetMetadata)\n\n  // 从targetMetadata中获取propertyKey关联的Map，若没有就创建一个新的Map\n  const metadataMap: MetadataMap = targetMetadata.get(propertyKey) || new Map()\n\n  // 将metadataMap再保存回targetMetadata中\n  targetMetadata.set(propertyKey, metadataMap)\n\n  // 设置元数据到metadataMap，键为metadataKey，值metadataValue\n  metadataMap.set(metadataKey, metadataValue)\n}\n```\n\n实现Reflect.getMetadata\n这个api会依赖getMetadataMap、getOwnMetadataMap。所以先倒着来实现\n\n1. getOwnMetadataMap\n```ts\nexport function getOwnMetadataMap(\n  target: Object,\n  propertyKey: PropertyKey = DEFAULTKAY\n) {\n  // 判断target类型，因为target将作为WeakMap的键，必须是对象类型\n  if (typeof target !== 'object' && typeof target !== 'function') {\n    throw new TypeError()\n  }\n\n  // 从Metadata中获取target关联的Map，如果没有就返回undefined\n  const targetMetadata = Metadata.get(target)\n  if (!targetMetadata) return\n\n  // 从targetMetadata中获取propertyKey关联的Map，如果没有就返回undefined\n  const metadataMap = targetMetadata.get(propertyKey)\n  if (!metadataMap) return\n\n  // 返回metadataMap\n  return metadataMap\n}\n```\n\n2. getMetadataMap\n获取target及其原型上的元数据Map，对于同一个propertyKey，自身的metadataMap覆盖原型的metadataMap\n```ts\nexport function getMetadataMap(\n  target: Object,\n  propertyKey: PropertyKey = DEFAULTKAY\n) {\n  // 如果自身有了propertyKey对应的map\n  if (Boolean(getOwnMetadataMap(target, propertyKey))) {\n    return getOwnMetadataMap(target, propertyKey)\n  }\n\n  // 去原型上找propertyKey对应的map，如果没有就返回undefined\n  const targetMetadata = Metadata.get(Object.getPrototypeOf(target))\n  if (!targetMetadata) return\n\n  // 从targetMetadata中获取propertyKey关联的Map，如果没有就返回undefined\n  const metadataMap = targetMetadata.get(propertyKey)\n  if (!metadataMap) return\n  \n  // 返回metadataMap\n  return metadataMap\n}\n```\n\n实现getMetadata\n利用getMetadataMap拿到target关联的metadataMap，然后根据metadataKey获取对应的metadataValue\n```ts\nexport function getMetadata<T>(\n  metadataKey: MetadataKey,\n  target: Object,\n  propertyKey?: PropertyKey\n): T {\n  // 根据propertyKey获取target的metadataMap，如果没有就返回undefined\n  const metadataMap = getMetadataMap(target, propertyKey)\n  if (!metadataMap) return\n\n  // 返回metadataKey对应的metadataValue\n  return metadataMap.get(metadataKey)\n}\n```\n同样的还有getOwnMetadata，只需要考虑getOwnMetadataMap就可以了\n\n实现Reflect.getMetadataKeys\n用来获取target身上的所有元数据键\n\n它会依赖getOwnMetadataKeys，所以先实现getOwnMetadataKeys\n\n实现getOwnMetadataKeys\n获取target自身的所有元数据键\n```ts\nexport function getOwnMetadataKeys(\n  target: Object,\n  propertyKey?: PropertyKey\n): MetadataKey[] {\n  // 获取target身上与propertyKey关联的metadataMap，若没有返回空数组\n  const metadataMap = getOwnMetadataMap(target, propertyKey)\n  if (!metadataMap) return []\n\n  // metadataMap转为数组并返回\n  return Array.from(metadataMap.keys())\n}\n```\n\n实现getMetadataKeys\n获取自身的metadataKeys，获取原型的metadataKeys，合并后返回\n```ts\nexport function getMetadataKeys(\n  target: Object,\n  propertyKey?: PropertyKey\n): MetadataKey[] {\n  // 获取target自身与propertyKey关联的metadataKeys\n  const ownKeys = getOwnMetadataKeys(target, propertyKey)\n\n  // 获取target原型与propertyKey关联的metadataKeys\n  const protoKeys = getOwnMetadataKeys(\n    Object.getPrototypeOf(target),\n    propertyKey\n  )\n\n  // 返回结果\n  return [...ownKeys, ...protoKeys]\n}\n```\n\n实现Reflect.hasMetadata\n用来判断target上是否有对应的metadataKey\n注意是判断有无key，而不是有无value，所以不能等价Boolean(getMetadata)，因为metadataValue可以是null和undefined等值。测试用例对这里做了大量的test。\n```ts\nexport function hasMetadata(\n  metadataKey: MetadataKey,\n  target: Object,\n  propertyKey?: PropertyKey\n) {\n  const metadataKeys = getMetadataKeys(target, propertyKey)\n  return metadataKeys.includes(metadataKey)\n}\n```\n这个很简单，没什么好说的\n\n同样还有hasOwnMetadata，利用getOwnMetadataKeys就ok\n\n实现Reflect.deleteMetadata\n```ts\nexport function deleteMetadata(\n  metadataKey: MetadataKey,\n  target: Object,\n  propertyKey?: PropertyKey\n) {\n  const metadataMap = getOwnMetadataMap(target, propertyKey)\n  if (!metadataMap) return false\n\n  return metadataMap.delete(metadataKey)\n}\n```\n\n实现Reflect.decorate\n这个可以从测试用例上获取思路\n\n```ts\n// reflect-decorate.test.ts\n\nit('DecoratorCorrectTargetInPipelineForFunctionOverload', () => {\n  let sent: Function[] = []\n  let A = function A(): void {}\n  let B = function B(): void {}\n  let decorators = [\n    (target: Function): any => {\n      sent.push(target)\n      return undefined\n    },\n    (target: Function): any => {\n      sent.push(target)\n      return undefined\n    },\n    (target: Function): any => {\n      sent.push(target)\n      return A\n    },\n    (target: Function): any => {\n      sent.push(target)\n      return B\n    }\n  ]\n  let target = function(): void {}\n  Reflect.decorate(decorators, target)\n  expect(sent).toEqual([target, B, A, A])\n})\n```\n\n测试中给出的decorators是4个箭头函数的数组，把target参数push到sent里，然后返回一个结果\n要求是Reflect.decorate执行后，sent是[target, B, A, A]\n再结合测试用例的name分析，看到了管道(Pipeline)，那应该会想到reduce而且是reduceRight。\ntarget就是initialValue，decorators就是reducers。\n\n\ndecorate\n有点类型redux的样子，target就是state，decorators就是reducers\n```ts\nexport function decorate(\n  decorators: (PropertyDecorator | MethodDecorator)[],\n  target: Object | Function,\n  propertyKey?: string | symbol,\n  attributes?: PropertyDescriptor\n): PropertyDescriptor {\n\n  // 如果decorators是空数组则抛出TypeError\n  if (0 === decorators.length) {\n    throw new TypeError()\n  }\n\n  // target作为initialValue，遍历decorators，将上一个decorator的结果作为target传给下一个decorator\n  return decorators.reduceRight(\n    (target, decorator) => decorator(target, propertyKey, attributes) || target,\n    <any>target\n  )\n}\n```\n\n确定Reflect的type以及混入原生Reflect\n为了避免类型冲突，首先需要给原生Reflect 的type起个别名，就叫IReflect 吧\n```ts\nexport type IReflect = typeof Reflect\nexport const reflect = Reflect\n```\n然后混入 Reflector\n```ts\nexport const Reflect: typeof Reflector & IReflect=Object.assign(reflect, Reflector)\n```\n因为原生Reflect对象的属性不可枚举，所以只能往原生reflect合并\n\nps: 之前我写的IOC框架依赖的reflect-metadata也换成了现在实现的这个版本，demo也能跑起来，感觉还不错。\nSaber2pr/saber-ioc\nhttps://github.com/Saber2pr/saber-ioc\n\nGithub\n@saber2pr/reflect\nhttps://github.com/Saber2pr/-saber2pr-reflect",
    "href": "/blog/saber-reflect"
  },
  {
    "name": "HTTP跨域之OPTIONS请求",
    "content": "前几天在写一个前后端交互的项目，遇到个问题：Header无法发送Authorization字段。\n\n我明明用RESTClient发POST测试得好好的。。(后来知道OPTIONS请求是浏览器自动发的，RESTClient要手动发)\n\n后端API鉴权采用类jwt的方式，为什么说类jwt呢，因为我不是按标准格式编码的，直接利用JSON.stringify来序列化json数据（当然token属性我已经私钥加密了）。前端从localStorage里拿到了jwt，放请求头Authorization字段里，firefox抓包发现请求头没带上jwt，请求变成了OPTIONS请求。\n\n1. 什么是OPTIONS请求？\nOPTIONS请求又称预检请求，就是在正式请求服务端API前的一个\"打招呼、询问\"。\n\n2. 为什么需要OPTIONS请求？\n前端带了特殊的请求头去访问后端，就会触发OPTIONS请求，会先询问后端是否支持该请求头字段(对应响应头Access-Control-Allow-Headers)，以及后端是否支持该请求方法(对应响应头Access-Control-Allow-Methods)。\n\n3. 那这样每次不得发两次请求？\nOPTIONS请求可以被缓存(对应响应头Access-Control-Max-Age)，在缓存过期前，不会再发OPTIONS请求询问。",
    "href": "/blog/http-request-options"
  },
  {
    "name": "前端history路由实现",
    "content": "本质就是，一个观察者模式的实现。组件监听浏览器url的变化，作出匹配和响应。但是，路由有一点是观察者模式无法做到的，那就是当用户点击浏览器前进和后退键时，观察者不能察觉到这种行为。所以需要借助几个原生的api来填补这个缺点。那就是onpopstate事件。浏览器点击前进和后退键时会发射这个事件，所以我们可以监听这个事件，在事件回调里调用观察者dispatch来衔接。\n```ts\nwindow.onpopstate = event => {\n  // 调用事件处理函数\n  gotoRoute(__routes, event.state)\n}\n```\n__routes对象是我们事先注册的路由，类型如下：\n```ts\nexport interface Routes {\n  [url: string]: string | (() => void)\n}\n```\ngotoRoute函数可以找到__routes对象中对应的路由分支，并执行注册的监听器。\n```ts\nconst gotoRoute = (routes: Routes, start: string): void => {\n  let current = routes[start]\n  if (typeof current === 'undefined') RouteException(start)\n  let url: string\n  while (typeof current === 'string') {\n    const next = routes[current]\n    if (next) {\n      url = current\n      current = next\n    } else {\n      RouteException(current)\n    }\n  }\n  __currentHref = url || start\n  current()\n}\n```\n__currentHref会把当前的url记录下来以供组件拉取。\n除此之外，我们还需要提供手动触发路由的函数\n```ts\nexport function push(url: string) {\n  // 将url显示到浏览器地址栏上，并把url记录到state中备用。\n  window.history.pushState(url, null, url)\n  url in __routes ? gotoRoute(__routes, url) : RouteException(url)\n}\n```\n路由注册函数useRoutes\n```ts\nexport function useRoutes(\n  arg1: Routes | string,\n  arg2?: string | (() => void)\n): UnUseRoutes {\n  if (typeof arg1 === 'string') {\n    arg1 in __routes || (__routes[arg1] = arg2)\n    return () => arg1 in __routes && delete __routes[arg1]\n  } else {\n    Object.keys(arg1).forEach(\n      key => key in __routes || (__routes[key] = arg1[key])\n    )\n    return () =>\n      Object.keys(arg1).forEach(key => key in __routes && delete __routes[key])\n  }\n}\n```\n最后需要注意，在函数组件中注册路由监听器必须在useEffect中进行，关于useEffect此处不多讲了。\n\nsaber-router项目地址\nhttps://github.com/Saber2pr/saber-router\n",
    "href": "/blog/use-router"
  }
]
