{"path":"/blog","title":"blog","children":[{"path":"/blog/BOM","title":"BOM","children":[{"path":"/blog/BOM/MutationObserver.md","title":"MutationObserver","text":"监视DOM元素变动。\r\n\r\n> DOM3 Events规范的一部分\r\n\r\n### 实现 Microtask\r\n\r\n```ts\r\nexport interface Microtask extends MutationCallback {}\r\n\r\nexport function microtask(task: Microtask) {\r\n  // 构造函数参数是一个function类型\r\n  const observer = new MutationObserver(task)\r\n\r\n  // 创建一个测试dom节点\r\n  const element = document.createTextNode('')\r\n\r\n  // 监听dom节点，\r\n  observer.observe(element, {\r\n    characterData: true\r\n  })\r\n\r\n  // 修改dom节点，触发MutationCallback\r\n  element.data = ''\r\n}\r\n```\r\n\r\n"},{"path":"/blog/BOM/requestAnimationFrame.md","title":"requestAnimationFrame","text":"下次重绘之前调用指定的回调函数。\r\n\r\n> 回调函数每秒执行60次\r\n\r\n用于动画更新。\r\n\r\n动画不要使用setInterval！它不是严格的时间间隔触发。它是每隔一段时间将回调放入宏任务执行栈中。如果当前执行栈被阻塞，则会影响回调间隔。"},{"path":"/blog/BOM/requestIdleCallback方法.md","title":"requestIdleCallback方法","text":"## 简介\r\n\r\n这个 API 是 BOM API 之一，即 window.requestIdleCallback，由浏览器实现。在 Node.js 上没有此 API 的实现。\r\n\r\n它会在浏览器空闲时期调用注册的函数，即 JS 引擎的空闲时期。\r\n\r\n函数签名(由于还处于提案阶段，Typescript 并没有给出函数的声明，所以需要自己 declare 声明函数的签名)\r\n\r\n```typescript\r\ndeclare interface IdleDeadline {\r\n  readonly didTimeout: boolean;\r\n  timeRemaining(): number; // 时间片中剩余时间(0 <= timeRemained < 50)\r\n}\r\n\r\ndeclare type IdleOptions = {\r\n  timeout: number;\r\n};\r\n\r\ndeclare type IdleCallback = (deadline: IdleDeadline) => void;\r\n\r\ndeclare function requestIdleCallback(callback: IdleCallback): number;\r\n\r\ndeclare function requestIdleCallback(\r\n  callback: IdleCallback,\r\n  options: IdleOptions\r\n): number;\r\n```\r\n\r\n浏览器将时间以每 50ms 切成片，每个时间片内会执行 JS 线程。如果有空余时间，会执行 IdleCallback，并传入一个 deadline 对象，用于获取剩余空闲时间。\r\n\r\n"}]},{"path":"/blog/css","title":"css","children":[{"path":"/blog/css/flex.md","title":"flex","text":"# 容器属性(父元素)\r\n\r\n## flex-direction\r\n\r\n定义 flex 布局的主轴方向(默认 row)\r\n\r\n```css\r\n.container {\r\n  flex-direction: row | row-reverse | column | column-reverse;\r\n}\r\n```\r\n\r\n## flex-wrap\r\n\r\n默认情况下，flex 布局容器会把子元素排在同一行，设置 flex-wrap 可以决定是否允许溢出换行。\r\n\r\n```css\r\n.container {\r\n  flex-wrap: nowrap | wrap | wrap-reverse;\r\n}\r\n```\r\n\r\n## justify-content\r\n\r\n定义子元素沿主轴方向的对齐方式\r\n\r\n```css\r\n.container {\r\n  justify-content: flex-start | flex-end | center | space-between | space-around;\r\n}\r\n```\r\n\r\n#### flex-start\r\n\r\n默认值，贴主轴起点。\r\n\r\n#### flex-end\r\n\r\n贴主轴终点。\r\n\r\n#### center\r\n\r\n沿主轴方向居中。\r\n\r\n#### space-between\r\n\r\n贴主轴两端，第一个子元素在主轴起点，最后一个子元素在主轴终点。\r\n\r\n#### space-around\r\n\r\n沿主轴子元素之间均匀分布。\r\n\r\n> 要注意的是子元素看起来间隙是不均匀的，第一个子元素和最后一个子元素离父元素的边缘有一个单位的间隙，但两个子元素之间有两个单位的间隙，因为每个子元素的两侧都有一个单位的间隙。\r\n\r\n## align-items\r\n\r\n定义了子元素在交叉轴方向的对齐方向\r\n\r\n```css\r\n.container {\r\n  align-items: flex-start | flex-end | center | baseline | stretch;\r\n}\r\n```\r\n\r\n## align-content\r\n\r\n> 类似于 justify-content\r\n\r\n> 当只有一行的时候，该属性并不起作用。\r\n\r\n```css\r\n.container {\r\n  align-content: flex-start | flex-end | center | space-between | space-around |\r\n    stretch;\r\n}\r\n```\r\n\r\n# 子元素属性\r\n\r\n## order\r\n\r\n默认情况下，子元素按照代码书写的先后顺序布局，但 order 属性可以更改子元素排列顺序。\r\n\r\n```css\r\n.item {\r\n  order: 0;\r\n}\r\n```\r\n\r\n## flex-grow\r\n\r\n决定在空间允许的情况下，子元素如何按照比例分配可用剩余空间。\r\n\r\n如果设定为 1，则父元素中的剩余空间会分给子元素。\r\n\r\n如果设定为 2，则在分配剩余空间时该子元素将获得其他元素二倍的空间。\r\n\r\n> 默认值为 0，即使有剩余空间，子元素也不会放大。\r\n\r\n```css\r\n.item {\r\n  flex-grow: 1;\r\n}\r\n```\r\n\r\n## flex-shrink\r\n\r\n当空间不足时子元素的缩小比例。\r\n\r\n## align-self\r\n\r\n> 可以覆盖父元素中 align-items 所设置的对齐方式\r\n\r\n```css\r\n.item {\r\n  align-self: auto | flex-start | flex-end | center | baseline | stretch;\r\n}\r\n```\r\n\r\n> float,clear 和 vertical-align 对 flex 子元素无效。\r\n"},{"path":"/blog/css/三角形.md","title":"三角形","text":"当元素宽高为 0 时，上下左右边框就会变成三角形\r\n\r\n分 3 种情况：\r\n\r\n1.  只设置两个边框时，会出现两个对角直角三角形\r\n2.  设置三个边框时，对称的两个会变成对角直角三角\r\n3.  设置四个边框时，是四个对心三角形\r\n\r\n向上的等腰三角形\r\n\r\n```css\r\n.triangle {\r\n  width: 0;\r\n  height: 0;\r\n  /* transparent为透明色彩，左右透明，下面部分就是朝上的三角形 */\r\n  border-left: 50px solid transparent;\r\n  border-right: 50px solid transparent;\r\n  border-bottom: 50px solid aqua;\r\n}\r\n```\r\n\r\n四个对心三角形\r\n\r\n```css\r\n.triangle0 {\r\n  width: 0;\r\n  height: 0;\r\n  border-left: 50px solid #ffae00;\r\n  border-right: 50px solid #ff00d4;\r\n  border-top: 50px solid #00ffff;\r\n  border-bottom: 50px solid #ff0062;\r\n}\r\n```\r\n\r\n左上角三角形\r\n\r\n```css\r\n.triangle1 {\r\n  width: 0;\r\n  height: 0;\r\n  border-right: 50px solid transparent;\r\n  border-top: 50px solid aqua;\r\n}\r\n```\r\n"},{"path":"/blog/css/垂直居中.md","title":"垂直居中","text":"## table + vertical-align\r\n\r\n> 基于基线(四线三行)\r\n\r\n```css\r\n.parent {\r\n  display: table;\r\n}\r\n\r\n.child {\r\n  display: table-cell;\r\n  vertical-align: middle;\r\n}\r\n```\r\n\r\n## transform\r\n\r\n```css\r\n.parent {\r\n  position: relative;\r\n}\r\n\r\n.child {\r\n  position: absolute;\r\n  top: 50%; /* absolute定位参照物是父容器 */\r\n  transform: translateY(-50%); /*translate的参照物是自身 */\r\n}\r\n```\r\n\r\n> 如果子元素宽度知道，也可以把 translateY 换成 margin-top 负边距(偏移自身一半)\r\n\r\n## align-items:center\r\n\r\nflex 容器\r\n\r\n> 不兼容 IE10 以下\r\n\r\n```css\r\n.parent {\r\n  display: flex;\r\n  align-items: center;\r\n}\r\n\r\n/*或者*/\r\n.child {\r\n  align-self: center;\r\n}\r\n```\r\n\r\n## line-height\r\n\r\n子元素行高设置为父元素高度\r\n\r\n```css\r\n.parent {\r\n  height: 100px;\r\n}\r\n\r\n.child {\r\n  line-height: 100px;\r\n}\r\n```\r\n"},{"path":"/blog/css/水平垂直居中.md","title":"水平垂直居中","text":"## text-align + (table + vertical-align)\r\n\r\n```css\r\n.parent {\r\n  text-align: center;\r\n  display: table;\r\n}\r\n\r\n.child {\r\n  display: table-cell;\r\n  vertical-align: middle;\r\n  /* 文本恢复左对齐 */\r\n  text-align: left;\r\n}\r\n```\r\n\r\n## transform\r\n\r\n```css\r\n.parent {\r\n  position: relative;\r\n}\r\n\r\n.child {\r\n  position: absolute;\r\n  /*absolute定位参照物是父容器*/\r\n  left: 50%;\r\n  top: 50%;\r\n  /*translate的参照物是自身*/\r\n  transform: translate(-50%, -50%);\r\n}\r\n```\r\n\r\n> 如果子元素宽度知道，也可以把 translate 换成 (margin-left + margin-top) 负边距(偏移自身一半)\r\n\r\n## justify-content + align-items\r\n\r\nflex 容器\r\n\r\n> 不兼容 IE10 以下\r\n\r\n```css\r\n.parent {\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n}\r\n```\r\n"},{"path":"/blog/css/水平居中.md","title":"水平居中","text":"## text-align: center\r\n\r\n在块级父容器中，让行内元素(或者类行内元素)居中，只需使用 text-align: center，\r\n\r\n> 类行内元素: inline/inline-block/inline-table/inline/flex\r\n\r\n```css\r\n.parent {\r\n  text-align: center;\r\n}\r\n\r\n.child {\r\n  display: inline-block;\r\n  /* 文本会继承child类的居中，需要取消文本居中 */\r\n  text-align: left;\r\n}\r\n```\r\n\r\n当子节点中出现多个行内元素的时候，每个子节点之间会有缝隙，这不是 bug，因为文本文字之间就需要缝隙。\r\n\r\n#### 去除办法\r\n\r\n1. 在父元素(容器)中设置 font-size: 0 可以去除缝隙\r\n\r\n```css\r\n.parent {\r\n  font-size: 0;\r\n}\r\n.chilc {\r\n  /* 注意子元素恢复 */\r\n  font-size: 16px;\r\n}\r\n```\r\n\r\n2. 使用 letter-spacing 或者 word-spacing\r\n\r\n## margin:0 auto\r\n\r\n子元素需要为块级元素，但需要设置 width。\r\n\r\n> table 元素 width 由内容决定\r\n\r\n```css\r\n.child {\r\n  display: table;\r\n  margin: 0 auto;\r\n}\r\n```\r\n\r\n## transform\r\n\r\n子绝父相\r\n\r\n> absolute 元素 width 由内容决定\r\n\r\n```css\r\n.parent {\r\n  position: relative;\r\n}\r\n\r\n.child {\r\n  position: absolute;\r\n  left: 50%; /*absolute定位参照物是父容器*/\r\n  transform: translateX(-50%); /*百分比的参照物是自身*/\r\n}\r\n```\r\n\r\n> 如果子元素宽度知道，也可以把 translateX 换成 margin-left 负边距(偏移自身一半)\r\n\r\n## justify-content:center;\r\n\r\nflex 容器\r\n\r\n> 不兼容 IE10 以下\r\n\r\n```css\r\n.parent {\r\n  display: flex;\r\n  justify-content: center;\r\n}\r\n```\r\n"},{"path":"/blog/css/盒子模型.md","title":"盒子模型","text":"# 标准(w3c)盒模型\r\n\r\nwidth = content (元素宽度 = 内容宽度)\r\n\r\n> 以 content 为边界\r\n\r\n> 内容宽度不变，向外扩展\r\n\r\n```css\r\n.contentBox {\r\n  background-color: aquamarine;\r\n  width: 100px;\r\n  height: 100px;\r\n  box-sizing: content-box;\r\n  border: 10px solid blue;\r\n  padding: 20px;\r\n  margin: 20px;\r\n}\r\n```\r\n\r\n所以.contentBox 元素的宽度为 100px\r\n\r\n# 怪异(IE)盒模型\r\n\r\nwidth = content + padding + border (元素宽度 = 内容宽度 + 内边距宽度 + 边框宽)\r\n\r\n> 以 border 为边界\r\n\r\n> 设置 padding 和 border 会挤压内容\r\n\r\n```css\r\n.borderBox {\r\n  background-color: yellowgreen;\r\n  width: 100px;\r\n  height: 100px;\r\n  box-sizing: border-box;\r\n  border: 10px solid blue;\r\n  padding: 20px;\r\n  margin: 20px;\r\n}\r\n```\r\n\r\n所以.borderBox 元素的宽度为 100px + 20px + 10px = 130px\r\n"}]},{"path":"/blog/git","title":"git","children":[{"path":"/blog/git/branch.md","title":"branch","text":"如果不是fork流，那就是几个人共用一个local repository。\r\n\r\n然后不同的人在不同的branch上commit，最后合并到master分支。\r\n出现冲突使用merge或者rebase。\r\n\r\nmerge即字面意思合并，rebase就是重置初始提交。merge会保留被merge branch上的commits，而rebase不会。rebase就是将commits取消掉然后合并成一个commit。\r\n\r\n### rebase\r\n\r\n例如\r\n\r\n```bash\r\ngit rebase master\r\n```\r\n\r\n这行命令会将当前分支的commits取消掉变成patches，然后更新为master分支，最后再把patches应用过来，生成一个commit。\r\n\r\n### cherry-pick\r\n\r\n复制指定commit到当前branch\r\n\r\n```bash\r\ngit cherry-pick <hash>\r\n\r\ngit cherry-pick <hash1>..<hash2>\r\n```\r\n\r\n"},{"path":"/blog/git/checkout.md","title":"checkout","text":"checkout是git最常用最重要的命令之一。\r\n\r\n### 切换分支\r\n\r\n```bash\r\ngit checkout <branch-name>\r\n```\r\n\r\n> 切换到一个新分支 git checkout -b <branch-name>\r\n\r\n### 文件回退\r\n\r\n> git log得到hash提交历史\r\n\r\n```bash\r\ngit checkout <hash> <file>\r\n```\r\n\r\n> 放弃未提交的所有修改 git checkout .\r\n"},{"path":"/blog/git/github与git.md","title":"github与git","text":"1. github即remote repository，是local repository的一个远程镜像。\r\n2. 本地git提交后，local repository会超前于remote repository，需要执行git push更新远程仓库。\r\n3. 如果是多人开发，远程仓库很有可能超前于本地分支，导致无法push本地到远程。需要先执行git pull，将远程的新内容更新到本地，再push。\r\n> 如果有冲突需要取舍。\r\n\r\n4. github上的贡献方式一般为 fork -> clone -> commit -> test -> push -> open pull request.\r\n\r\n> 一般的就这样可以了。\r\n"},{"path":"/blog/git/log.md","title":"log","text":"```bash\r\ngit log\r\n\r\ngit reflog\r\n```\r\nreflog可以看到被reset的commit。"}]},{"path":"/blog/http","title":"http","children":[{"path":"/blog/http/HTTP跨域之OPTIONS请求.md","title":"HTTP跨域之OPTIONS请求","text":"前几天在写一个前后端交互的项目，遇到个问题：Header 无法发送 Authorization 字段。\r\n\r\n我明明用 RESTClient 发 POST 测试得好好的。。(后来知道 OPTIONS 请求是浏览器自动发的，RESTClient 要手动发)\r\n\r\n后端 API 鉴权采用类 jwt 的方式，为什么说类 jwt 呢，因为我不是按标准格式编码的，直接利用 JSON.stringify 来序列化 json 数据（当然 token 属性我已经私钥加密了）。前端从 localStorage 里拿到了 jwt，放请求头 Authorization 字段里，firefox 抓包发现请求头没带上 jwt，请求变成了 OPTIONS 请求。\r\n\r\n1. 什么是 OPTIONS 请求？\r\n\r\nOPTIONS 请求又称预检请求，就是在正式请求服务端 API 前的一个\"打招呼、询问\"。\r\n\r\n2. 为什么需要 OPTIONS 请求？\r\n\r\n前端带了特殊的请求头去访问后端，就会触发 OPTIONS 请求，会先询问后端是否支持该请求头字段(对应响应头 Access-Control-Allow-Headers)，以及后端是否支持该请求方法(对应响应头 Access-Control-Allow-Methods)。\r\n\r\n3. 那这样每次不得发两次请求？\r\n\r\nOPTIONS 请求可以被缓存(对应响应头 Access-Control-Max-Age)，在缓存过期前，不会再发 OPTIONS 请求询问。\r\n"},{"path":"/blog/http/基本概念.md","title":"基本概念","text":"# 概念\r\n\r\nHTTP 是面向事务的应用层协议，全称为 HyperText Transfer Protocol，即为超文本传输协议，是互联网应用最为广泛的一种网络协议，所有的 www 文件都必须遵守这个标准。\r\n\r\n# 特性\r\n\r\nHTTP 是无连接无状态的\r\nHTTP 一般构建于 TCP/IP 协议(传输层)之上，默认端口号是 80\r\nHTTP 可以分为两个部分，即请求和响应。\r\n\r\n# 请求\r\n\r\n由 3 个部分构成，分别是：状态行，请求头(Request Header)，请求正文。\r\n\r\nHTTP 定义了在与服务器交互的不同方式，最常用的方法有 4 种，分别是 GET，POST，PUT， DELETE。\r\n\r\n> URL 全称为资源描述符，可以这么认为：一个 URL 地址，对应着一个网络上的资源，而 HTTP 中的 GET，POST，PUT，DELETE 就对应着对这个资源的查询，修改，增添，删除 4 个操作。\r\n\r\n### GET 请求和 POST 请求的区别\r\n\r\n1. 请求参数位置不同，GET 请求对应的参数放在 URL 中，而 POST 请求对应的参数放在 HTTP 请求主体中。\r\n\r\n> 但是这只是一种约定，GET 请求中出现 Body 也是被允许的。\r\n\r\n2. 虽然 HTTP 协议的 RFC 规范 并没有详细规定 URL 的最大字符长度限制，但实际上，在浏览器或者服务器中总会存在限制的，这就导致了 GET 请求中参数数量是有限的。\r\n\r\n3. 处于安全考虑，在一些涉及安全的请求比如：登录请求需要用 POST 提交表单，而 GET 请求一般用来获取静态资源。\r\n\r\n4. GET、POST 请求都可以被缓存，但 GET 请求可以被收藏为书签， POST 不可以。\r\n\r\n5. GET 请求的参数在 URL 中，因此绝不能用 GET 请求传输敏感数据。POST 请求数据则写在 HTTP 的请求头中，安全性略高于 GET 请求。\r\n\r\n> 只是略高\r\n\r\n# 响应\r\n\r\n由三个部分构成。分别是：状态行，响应头(Response Header)，响应正文\r\n\r\n#### HTTP 状态码\r\n\r\n1xx : 表示请求已经接受了，继续处理。\r\n2xx : 表示请求已经处理掉了。\r\n3xx : 重定向。\r\n4xx : 一般表示客户端有错误，请求无法实现。\r\n5xx : 一般为服务器端的错误。\r\n\r\n常见的状态码：\r\n200 OK 客户端请求成功。\r\n301 Moved Permanently 请求永久重定向。\r\n302 Moved Temporarily 请求临时重定向。\r\n304 Not Modified 文件未修改，可以直接使用缓存的文件。\r\n400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。\r\n401 Unauthorized 请求未经授权，无法访问。\r\n403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因。\r\n404 Not Found 请求的资源不存在，比如输入了错误的 URL。500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。\r\n503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。\r\n\r\n# OSI 7层模型\r\n\r\n1. 应用层：与其它计算机进行通讯的一个应用，例如HTTP、FTP等。\r\n2. 表示层：定义数据格式及加密。例如二进制或ASCII格式。\r\n3. 会话层：定义了如何开始、控制和结束一个会话。例如SQL。\r\n4. 传输层：对输入进行复用、排序。例如TCP、UDP。\r\n5. 网络层：对端到端的包传输进行定义，标识所有结点的逻辑地址。例如IP。\r\n6. 数据链路层：定义了在单个链路上如何传输数据，与被讨论的介质有关。\r\n7. 物理层：有关传输介质的特性。"}]},{"path":"/blog/javascript","title":"javascript","children":[{"path":"/blog/javascript/async & await原理.md","title":"async & await原理","text":"# es5 生成器 generator\r\n\r\n> yield 会保存执行位置，外部调用 next 回到 yield 处往下执行\r\n\r\n```js\r\nfunction* generator() {\r\n  const next1 = yield 1\r\n  console.log(next1)\r\n\r\n  const next2 = yield 2\r\n  console.log(next2)\r\n\r\n  const next3 = yield 3\r\n  console.log(next3)\r\n}\r\nconst iterator = generator()\r\nconsole.log(iterator.next()) // 第一次调用返回第一次yield的值，后续每调用一次向后迭代一次\r\nconsole.log(iterator.next())\r\nconsole.log(iterator.next())\r\nconsole.log(iterator.next()) // done true 意思是后面没有yield了，迭代结束\r\n// next函数可接受一个值，会覆盖生成器中yield左边的值\r\n```\r\n\r\n# async 实现\r\n\r\n```js\r\nfunction async(generator) {\r\n  // 调用生成器生成迭代器\r\n  const iterator = generator()\r\n\r\n  return function next(onfulfilled) {\r\n    // 迭代一次\r\n    const result = iterator.next(onfulfilled)\r\n    // 如果yield完成，则返回\r\n    if (result.done) return\r\n    // 注册下一次迭代到promise回调中\r\n    // 如果yield的值不是promise，则包装为Promise.resolve\r\n    result.value.then\r\n      ? result.value.then(onfulfilled => next(onfulfilled))\r\n      : Promise.resolve(result.value).then(onfulfilled => next(onfulfilled))\r\n  }\r\n}\r\n\r\nconst delay = (time, value) =>\r\n  new Promise(res => setTimeout(() => res(value), time))\r\n\r\nasync(function*() {\r\n  const first = yield 1\r\n  console.log(first)\r\n\r\n  const second = yield delay(1000, 2) // 阻塞2秒\r\n  console.log(second)\r\n\r\n  const third = yield 3\r\n  console.log(third)\r\n})()\r\n```\r\n"},{"path":"/blog/javascript/base64算法.md","title":"base64算法","text":"base64 是一种用 64 个字符（1 字节 = 8bit）来表示任意 8bit 位的二进制数据的方法。\r\nbase64 一共只有 2 的 6 次方 64 个字符（6bit），而实际上 1 bytes = 8bit\r\n将二进制数据每 6bit 位替换成一个 base64 字符\r\n\r\n> 转自https://zhuanlan.zhihu.com/p/51407418\r\n\r\n```js\r\nfunction base64encode(text) {\r\n  let code = \"\"\r\n  let base64Code =\r\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\r\n  let res = \"\"\r\n\r\n  for (let i of text) {\r\n    let char = i.charCodeAt().toString(2)\r\n    // 将 toString 前面省略的0补上，补够8位二进制\r\n    for (let a = 0; a <= 8 - char.length; a++) {\r\n      char = 0 + char\r\n    }\r\n    code += char\r\n  }\r\n  // 不足 24 bit (也就是 3 bytes) 的情况进行特殊处理\r\n  // 只有 1 字节的时候\r\n  if (code.length % 24 === 8) {\r\n    // 补齐到 2*6 = 12 bit\r\n    code += \"0000\"\r\n    // 剩余缺失的 2 个 base64 字符用等号代替\r\n    res += \"==\"\r\n  }\r\n  // 只有 2 字节的时候\r\n  if (code.length % 24 === 16) {\r\n    // 补齐到 3 * 6 = 18 bit\r\n    code += \"00\"\r\n    // 剩余缺失的 1 个 base64 字符用等号代替\r\n    res += \"=\"\r\n  }\r\n\r\n  let encode = \"\"\r\n  for (let i = 0; i < code.length; i += 6) {\r\n    let item = code.slice(i, i + 6)\r\n    encode += base64Code[parseInt(item, 2)]\r\n  }\r\n\r\n  return encode + res\r\n}\r\n\r\nconsole.log(base64encode(\"this is a example\")) // dGhpcyBpcyBhIGV4YW1wbGU=\r\n```\r\n"},{"path":"/blog/javascript/bind call apply和原理.md","title":"bind call apply和原理","text":"# 作用域\r\n\r\n```js\r\n// 对象作用域\r\nconst objContext = {\r\n  value: 1,\r\n  getValue(v1, v2) {\r\n    if (v1 && v2) return v1 + v2 + this.value\r\n    return this.value\r\n  }\r\n}\r\n// 获取对象作用域内的函数\r\nconst method = objContext.getValue\r\n\r\n// 函数作用域下（父作用域不能访问子作用域！）\r\nconsole.log(method()) // undefined\r\n\r\n// 手动转移（绑定、指定）执行上下文到objContext上下文中\r\nconsole.log(method.apply(objContext)) // 1\r\nconsole.log(method.call(objContext)) // 1\r\nconsole.log(method.bind(objContext)()) // 1\r\n```\r\n\r\n# 实现 call\r\n\r\n```js\r\nFunction.prototype.myCall = function(thisArg, ...argArray) {\r\n  // Symbol是es6增加的第六个基本类型，对于对象属性就是uuid\r\n  const id = Symbol()\r\n  // 获取要指定的上下文\r\n  context = thisArg || window\r\n  // 将当前函数链接到指定的上下文中\r\n  context[id] = this\r\n  // 当前函数在context上下文中执行\r\n  const result = context[id](...argArray)\r\n  // 移除context中已执行的当前函数\r\n  delete context[id]\r\n  // 返回结果\r\n  return result\r\n}\r\n```\r\n\r\n# 实现 bind\r\n\r\n```js\r\nFunction.prototype.myBind = function(thisArg, ...argArray) {\r\n  return () => this.myCall(thisArg, ...argArray)\r\n}\r\n```\r\n\r\n# 实现 apply\r\n\r\n```js\r\nFunction.prototype.myApply = function(thisArg, argArray = []) {\r\n  return this.myCall(thisArg, ...argArray)\r\n}\r\n```\r\n\r\n```js\r\nconsole.log(Math.max.myCall(null, ...[1, 2, 3])) // 3\r\n\r\nconsole.log(method.myApply(objContext, [1, 2])) // 4\r\nconsole.log(method.myCall(objContext, 1, 2)) // 4\r\nconsole.log(method.myBind(objContext, 1, 2)()) // 4\r\n\r\nconsole.log(objContext)\r\n```\r\n\r\n# 总结一下\r\n\r\n核心就是 call 的实现。其实 apply 和 bind 实现任意一个就好了。\r\nmethod.call(thisArg, ...items)\r\n一个函数内部如果不读取上下文的话，call 不 call 没区别。\r\n原因就是 js 函数执行的上下文和声明时所处的上下文并不总是相同，也就是 this 是个动态变化的值\r\n所以为了避免函数内调用 this 时发生错误，一般用 call 绑定到声明时所处的上下文\r\n所以 call 需要做的：\r\n\r\n1.  由于在 call 函数内，this 本身就是函数，所以直接把 this 赋给 context 的属性就完成了绑定\r\n2.  在 context 内声明一个新的函数值指向 this，然后用对象作用域调用这个新的函数\r\n    其实就是利用了`obj[method]`这种方法实现的绑定，给 obj 内新建一个函数指向当前，然后执行，obj 作为上下文去调用自己的属性\r\n"},{"path":"/blog/javascript/es6","title":"es6","children":[{"path":"/blog/javascript/es6/promise原理.md","title":"promise原理","text":"promise本质是Monad，用于在纯函数中处理副作用。\r\n\r\n> 在Node.js上常用来处理callback-hell。其实是利用了promise暴露的executor。\r\n\r\nMonad依赖系统实现的微任务队列，用于在纯函数执行后执行副作用。\r\n\r\n# 微任务\r\n\r\n```ts\r\nexport interface Microtask extends MutationCallback {}\r\n\r\nexport function microtask(task: Microtask) {\r\n  if (\r\n    typeof process !== 'undefined' &&\r\n    typeof process.nextTick === 'function'\r\n  ) {\r\n    process.nextTick(task)\r\n  } else {\r\n    const observer = new MutationObserver(task)\r\n    const element = document.createTextNode('')\r\n    observer.observe(element, {\r\n      characterData: true\r\n    })\r\n    element.data = ''\r\n  }\r\n}\r\n```\r\n\r\n> 兼容Node.js和Browser环境\r\n\r\n# Promise实现\r\n\r\n### 类型定义\r\n\r\n```ts\r\nexport type Resolve<T> = (value?: T) => any\r\nexport type Reject<T> = (reason?: T) => any\r\n\r\nexport type Executor<T> = (resolve: Resolve<T>, reject: Reject<T>) => void\r\nexport type Catch<T> = (onRejected: Reject<T>) => any\r\n\r\nexport type Then<T> = (\r\n  onfulfilled?: Resolve<T>,\r\n  onrejected?: Reject<T>\r\n) => Promise<T>\r\n\r\nexport type Status = 'pending' | 'resolved' | 'rejected'\r\n```\r\n\r\n### 实现\r\n\r\n```ts\r\nexport class Promise<T> {\r\n  public constructor(executor: Executor<T>) {\r\n    try {\r\n      // 构造函数同步执行\r\n      executor(this.resolve, this.reject)\r\n    } catch (error) {\r\n      this.reject(error)\r\n    }\r\n  }\r\n  private status: Status = 'pending'\r\n  private data = undefined\r\n  private onResolvedCallback: Array<Resolve<T>> = []\r\n  private onRejectedCallback: Array<Reject<T>> = []\r\n\r\n  // microtask中处理then注册的Callbacks\r\n  private resolve: Resolve<T> = value => microtask(() => {\r\n    if (this.status === 'pending') {\r\n      this.status = 'resolved'\r\n      this.data = value\r\n      this.onResolvedCallback.forEach(resolve => resolve(value))\r\n    }\r\n  })\r\n  private reject: Reject<T> = reason => microtask(() => {\r\n    if (this.status === 'pending') {\r\n      this.status = 'rejected'\r\n      this.data = reason\r\n      this.onRejectedCallback.forEach(reject => reject(reason))\r\n    }\r\n  })\r\n\r\n  // 下文实现then\r\n}\r\n\r\nexport namespace Promise {\r\n  export function resolve<T>(value?: T) {\r\n    return new Promise<T>(resolve => resolve(value))\r\n  }\r\n\r\n  export function reject<T>(reason?: T) {\r\n    return new Promise<T>((_, reject) => reject(reason))\r\n  }\r\n}\r\n```\r\n\r\n### then实现\r\n\r\n将普通值类型提升为Promise类型\r\n\r\nes6实现中，将>>=操作和lift操作在if中分情况合并了。\r\n\r\n```ts\r\nexport class Promise<T> {\r\n  public then: Then<T> = (\r\n    onfulfilled = value => value,\r\n    onrejected = reason => {\r\n      throw reason\r\n    }\r\n  ) => {\r\n    // then返回新的Promise\r\n    return new Promise((resolve, reject) => {\r\n      if (this.status === 'resolved') {\r\n        try {\r\n          // 执行onfulfilled，然后将普通值提升为Promise类型\r\n          // 下文都是这个步骤\r\n          const p = onfulfilled(this.data)\r\n          if (p instanceof Promise) {\r\n            p.then(resolve, reject)\r\n          } else {\r\n            // 提升为Promise类型\r\n            resolve(p)\r\n          }\r\n        } catch (error) {\r\n          reject(error)\r\n        }\r\n      }\r\n\r\n      if (this.status === 'rejected') {\r\n        try {\r\n          const p = onrejected(this.data)\r\n          if (p instanceof Promise) {\r\n            p.then(resolve, reject)\r\n          } else {\r\n            reject(this.data)\r\n          }\r\n        } catch (error) {\r\n          reject(error)\r\n        }\r\n      }\r\n\r\n      if (this.status === 'pending') {\r\n        this.onResolvedCallback.push(() => {\r\n          try {\r\n            const p = onfulfilled(this.data)\r\n            if (p instanceof Promise) {\r\n              p.then(resolve, reject)\r\n            } else {\r\n              resolve(p)\r\n            }\r\n          } catch (error) {\r\n            reject(error)\r\n          }\r\n        })\r\n\r\n        this.onRejectedCallback.push(() => {\r\n          try {\r\n            const p = onrejected(this.data)\r\n            if (p instanceof Promise) {\r\n              p.then(resolve, reject)\r\n            } else {\r\n              reject(this.data)\r\n            }\r\n          } catch (error) {\r\n            reject(error)\r\n          }\r\n        })\r\n      }\r\n    })\r\n  }\r\n\r\n  // 注册一个onRejected到callbacks\r\n  public catch = (onRejected: Reject<T>) => {\r\n    return this.then(null, onRejected)\r\n  }\r\n}\r\n```\r\n\r\n至于async/await那就真的是语法糖了。就是haskell中的do block。\r\n\r\nes6中可以利用yield和promise实现。"}]},{"path":"/blog/javascript/fiber遍历.md","title":"fiber遍历","text":"# 虚拟 dom 构造函数\r\n\r\n```js\r\nfunction VDom(props, children) {\r\n  this.props = props\r\n  this.children = children\r\n}\r\n```\r\n\r\n# Fiber 构造函数\r\n\r\n```js\r\nfunction Fiber(instance, parent, child, sibling) {\r\n  this.instance = instance\r\n  this.parent = parent\r\n  this.child = child\r\n  this.sibling = sibling\r\n}\r\n```\r\n\r\n# Link\r\n\r\n> 链接 fiber 实例 vdom 的 children 为单向链表，并返回第一个子节点，若 fiber 实例 vdom 没有 children，则返回 null\r\n\r\n```js\r\nfunction link(fiber) {\r\n  if (!fiber.instance.children) return null\r\n  return (fiber.child = fiber.instance.children.reduceRight(\r\n    (sibling, current) => new Fiber(current, fiber, null, sibling),\r\n    null\r\n  ))\r\n}\r\n```\r\n\r\n# Fiber 迭代算法\r\n\r\n> 深度优先遍历\r\n\r\n```js\r\nfunction next(fiber) {\r\n  const child = link(fiber)\r\n  if (child) return child\r\n  let current = fiber\r\n  while (current) {\r\n    if (current.sibling) return current.sibling\r\n    current = current.parent\r\n  }\r\n}\r\n/**\r\n * 循环迭代\r\n * @param {Fiber} fiber\r\n * @param {(fiber:Fiber) => void} callback\r\n */\r\nfunction loop(fiber, callback) {\r\n  let current = fiber\r\n  while (current) {\r\n    callback(current)\r\n    current = next(current)\r\n  }\r\n}\r\n```\r\n\r\n```js\r\n// 虚拟dom树\r\nconst root = new VDom({ value: 1 }, [\r\n  new VDom({ value: 2 }, [new VDom({ value: 4 })]),\r\n  new VDom({ value: 3 }, [new VDom({ value: 5 })])\r\n])\r\n\r\n// 虚拟dom树转为fiber链表，开始遍历\r\nloop(new Fiber(root), fiber => console.log(fiber.instance.props))\r\n\r\nlet __current = new Fiber(root)\r\n// 使用浏览器调度API-requestIdleCallback\r\nfunction work(dline) {\r\n  console.log(__current.instance.props, dline.timeRemaining())\r\n  __current = next(__current)\r\n  if (__current) requestIdleCallback(work)\r\n}\r\n\r\nrequestIdleCallback(work)\r\n```\r\n"},{"path":"/blog/javascript/HTML特殊字符转义.md","title":"HTML特殊字符转义","text":"# 利用正则转义\r\n\r\n正则对象(全局 g)的 exec 方法可用来迭代搜索字符串，并把匹配到的位置记录到 lastIndex 属性\r\n\r\n1. 利用 split 把字符串拆解成字符序列\r\n2. 根据匹配到的 index 修改序列对应元素\r\n3. 利用 join 反序列为字符串\r\n\r\n```js\r\nconst element = `<script>hello</script>`\r\n\r\nconst transform0 = element => {\r\n  // 得到字符序列\r\n  const words = element.split(\"\")\r\n  const reg = /<|>/g\r\n  let res = reg.exec(element)\r\n  while (res) {\r\n    // 匹配到的位置会被记录到lastIndex属性，由于是从1开始，所以要-1\r\n    const index = reg.lastIndex - 1\r\n    // 修改序列对应元素\r\n    words.splice(index, 1, element.charCodeAt(index))\r\n    // 迭代搜索下一个位置\r\n    res = reg.exec(element)\r\n  }\r\n  return words.join(\"\")\r\n}\r\n\r\nconsole.log(transform0(element))\r\n```\r\n\r\n# 利用 dom innerText 转义\r\n\r\n```js\r\n// innerText输入,innerHTML输出\r\nconst transform1 = element => {\r\n  const dom = document.createElement(\"span\")\r\n  dom.innerText = element\r\n  return dom.innerHTML\r\n}\r\n\r\nconsole.log(transform1(element))\r\n```\r\n"},{"path":"/blog/javascript/JSONP跨域.md","title":"JSONP跨域","text":"```js\r\n/**\r\n * @param {string} url\r\n */\r\nconst jsonp = url =>\r\n  new Promise((resolve, reject) => {\r\n    // 创建标签\r\n    const script = document.createElement(\"script\")\r\n    // 设置回调名\r\n    const callbackId = `jsonp_${Date.now()}`\r\n    // 拼接请求的url，异步请求在这里，判断是否已经有参数\r\n    script.src = url.includes(\"?\")\r\n      ? `${url}&callback=${callbackId}`\r\n      : `${url}?callback=${callbackId}`\r\n    // 设置读取返回结果的回调函数, 必须设置在window上\r\n    window[callbackId] = result => {\r\n      // 释放内存\r\n      delete window[callbackId]\r\n      document.body.removeChild(script)\r\n      // 结果\r\n      result ? resolve(result) : reject(\"404\")\r\n    }\r\n    script.addEventListener(\"error\", () => reject(\"script create fail\"))\r\n    // 发出请求\r\n    document.body.appendChild(script)\r\n  })\r\n\r\njsonp(\"http://localhost:3005/jsonp?name=saber2pr&age=21\").then(console.log)\r\n```\r\n"},{"path":"/blog/javascript/koa中间件机制.md","title":"koa中间件机制","text":"```js\r\nasync function job1(ctx, next) {\r\n  console.log(ctx.name, \"1\")\r\n  await next()\r\n  console.log(ctx.name, \"5\")\r\n}\r\n\r\nasync function job2(ctx, next) {\r\n  console.log(ctx.name, \"2\")\r\n  await next()\r\n  console.log(ctx.name, \"4\")\r\n}\r\n\r\nasync function job3(ctx) {\r\n  console.log(ctx.name, \"3\")\r\n}\r\n\r\nconst ctx = { name: \"koa\" }\r\n```\r\n\r\n原理就是把下一个 promise 传给上一个\r\n\r\n```javascript\r\nconst process = (...jobs) =>\r\n  jobs.reduceRight((next, job) => async () => await job(ctx, next), null)\r\n\r\nprocess(job1, job2, job3)() // koa 1, koa 2, koa 3, koa 4, koa 5\r\n```\r\n"},{"path":"/blog/javascript/vdom渲染.md","title":"vdom渲染","text":"# 虚拟 dom 构造函数\r\n\r\n```js\r\nfunction VDom(type, props, children) {\r\n  this.type = type\r\n  this.props = props\r\n  this.children = children\r\n}\r\n\r\nfunction h(type, props, children = []) {\r\n  return new VDom(type, props, children)\r\n}\r\n\r\nconst tree = h(\"div\", {}, [h(\"p\", { innerText: \"hello\" })])\r\n```\r\n\r\n# 渲染函数\r\n\r\n```js\r\nfunction renderDom(vdom, container) {\r\n  const dom = document.createElement(vdom.type)\r\n  Object.entries(vdom.props).forEach(([k, v]) => (dom[k] = v))\r\n  container.append(dom)\r\n  vdom.children && vdom.children.forEach(child => renderDom(child, dom))\r\n}\r\n\r\nrenderDom(tree, document.getElementById(\"root\"))\r\n```\r\n\r\n# 迭代器遍历\r\n\r\n```js\r\nfunction* toIterable(vdom, stack = [vdom]) {\r\n  while (stack.length) {\r\n    const node = stack.pop()\r\n    node.children && stack.push(...node.children)\r\n    yield node\r\n  }\r\n}\r\nconsole.log(Array.from(toIterable(tree)))\r\n```\r\n"},{"path":"/blog/javascript/事件捕获冒泡.md","title":"事件捕获冒泡","text":"```javascript\r\n/**\r\n * lisen\r\n * @param {string[]} ids\r\n * @param {boolean} isCatch\r\n */\r\nconst lisen = (ids, isCatch) =>\r\n  ids.forEach(id =>\r\n    document\r\n      .getElementById(id)\r\n      .addEventListener(\"click\", () => alert(id), isCatch)\r\n  )\r\n\r\n// BubbleEvent\r\nlisen([\"root_b\", \"first_b\", \"second_b\", \"target_b\"], false)\r\n\r\n// CatchEvent\r\nlisen([\"root_c\", \"first_c\", \"second_c\", \"target_c\"], true)\r\n```\r\n\r\n关于 addEventListener 的第三个参数 options\r\n如果是 boolean 值，则 false 为冒泡事件，true 为捕获事件，默认为冒泡\r\n如果是一个对象，即一个指定有关 listener 属性的可选参数对象。可用的选项如下：\r\n\r\n1. capture: Boolean，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发。\r\n\r\n2. once: Boolean，表示 listener 在添加之后最多只调用一次。如果是 true， listener 会在其被调用之后自动移除。\r\n\r\n3. passive: Boolean，设置为 true 时，表示 listener 永远不会调用 preventDefault()。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。如果一个事件不需要 preventDefault，直接设置 passive true 可以起到优化作用。\r\n"},{"path":"/blog/javascript/作用域和闭包.md","title":"作用域和闭包","text":"```js\r\nif (1) {\r\n  // var变量声明预编译提升到上一层，或者说if没有块级\r\n  var val = 233\r\n}\r\n\r\ntry {\r\n  console.log(val) // 233\r\n} catch (error) {\r\n  console.error(error)\r\n}\r\n\r\nif (1) {\r\n  try {\r\n    console.log(_val) // 没有初始化，即暂定死区。改成var声明会输出undefined，var默认初始化为undefined\r\n  } catch (error) {\r\n    console.log(error)\r\n  }\r\n  // let块作用域\r\n  let _val = 344\r\n}\r\n\r\ntry {\r\n  console.log(_val) // _val is not defined，因为_val在块作用域内(子作用域)\r\n} catch (error) {\r\n  console.error(error)\r\n}\r\n\r\n// 函数作用域也是块级\r\nfunction Block() {\r\n  // 函数封闭作用域\r\n  var _val_0 = 344\r\n}\r\n\r\ntry {\r\n  console.log(_val_0) // _val_0 is not defined\r\n} catch (error) {\r\n  console.error(error)\r\n}\r\n\r\nconst People = (function() {\r\n  // iife闭包环境\r\n\r\n  // 被闭包的变量，所有实例共享\r\n  var _age = 21\r\n\r\n  function People(name) {\r\n    this.name = name\r\n  }\r\n\r\n  People.prototype.getAge = function() {\r\n    return _age\r\n  }\r\n\r\n  People.prototype.addAge = function() {\r\n    _age++\r\n  }\r\n\r\n  return People\r\n})()\r\n\r\nconst me = new People(\"saber2pr\")\r\nme.addAge()\r\nconsole.log(me.getAge()) // 22\r\n\r\nconst saber = new People(\"saber\")\r\nsaber.addAge()\r\nconsole.log(saber.getAge()) // 23\r\n```\r\n\r\njs 里存在 3 种作用域\r\n\r\n1. 全局作用域\r\n2. 函数作用域\r\n3. 对象作用域\r\n   每个作用域里的 var 声明都会提升到该作用域顶层\r\n   子作用域声明覆盖父作用域\r\n"},{"path":"/blog/javascript/原型链.md","title":"原型链","text":"```js\r\n// 实例的构造函数\r\nfunction Cat() {}\r\n// 实例\r\nconst cat = new Cat()\r\n\r\n// 实例的原型就是构造函数的prototype\r\nconsole.log(cat.__proto__ === Cat.prototype)\r\n\r\n// 实例构造函数的原型就是构造函数的原型\r\nconsole.log(Cat.__proto__ === Function.prototype)\r\n\r\n// 构造函数的原型的构造函数就是自己\r\nconsole.log(Cat.prototype.constructor === Cat)\r\n\r\n// 构造函数的原型的原型就是Object构造函数的原型\r\nconsole.log(Function.prototype.__proto__ === Object.prototype)\r\nconsole.log(Array.prototype.__proto__ === Object.prototype)\r\nconsole.log(Date.prototype.__proto__ === Object.prototype)\r\nconsole.log(Error.prototype.__proto__ === Object.prototype)\r\n// 这些对象的构造函数就是Object\r\nconsole.log(JSON.__proto__ === Object.prototype)\r\nconsole.log(Reflect.__proto__ === Object.prototype)\r\n\r\n// 实例的原型的构造函数就是实例的构造函数\r\nconsole.log(Cat.prototype.constructor === Cat)\r\n\r\n// 实例原型的原型就是Object构造函数的prototype\r\nconsole.log(Cat.prototype.__proto__ === Object.prototype)\r\n\r\n// Object实例的原型的原型是null\r\nconsole.log(Object.prototype.__proto__ === null)\r\n\r\n// __proto__链：cat实例 -> Cat原型 -> Object原型 -> null\r\nconsole.log(cat.__proto__.__proto__.__proto__ === null)\r\n\r\n// Function和Object的关系\r\n// 所有的函数对象的原型都是Function的prototype，Object也是个函数对象\r\nconsole.log(Object.__proto__ === Function.prototype)\r\n// 那Function的原型是? [native code]\r\nconsole.log(Function.__proto__)\r\n// 应该是Function.prototype\r\nconsole.log(Function.__proto__ === Function.prototype)\r\n```\r\n\r\n## `__proto__` 的作用\r\n\r\n当读取实例属性时，先在实例身上找，找不到就去`__proto__`上找，`__proto__`就是一条连接实例和实例原型的链条，\r\n当然实例原型也有自己的原型。\r\n顺着`__proto__`一直向上找会找到 Object.prototype，再往上就是 null\r\n\r\n## prototype 的作用\r\n\r\n获得构造函数的原型，用于给原型添加方法和属性\r\n\r\n## constructor 的作用\r\n\r\n在 prototype 上有一个 constructor 属性，指向构造函数。\r\n即 constructor.prototype.constructor === constructor\r\n如果 prototype 被改变，则 constructor 指向也改变\r\n\r\n# 总结一下\r\n\r\n1. 构造函数和原型之间通过 constructor.prototype.constructor === constructor ，双向连接\r\n2. 实例通过`__proto__`一直向原型方向找（constructor.prototype），向上找到 Object.prototype，再上就是 null\r\n3. prototype 就是原型，`__proto__`就是原型链，`__proto__`把实例和一系列的 prototype 连起来\r\n4. 构造函数的 prototype 就是原型\r\n5. 实例的`__proto__`指向自己构造函数的 prototype，而自己构造函数的原型（包括所有函数的原型）都是 Function.prototype\r\n   (甚至 Function 自己的原型也指向 Function.prototype)\r\n6. 对象实例的原型最终指向 Object.prototype(再向上为 null)，函数的原型指向 Function.prototype\r\n"},{"path":"/blog/javascript/双向绑定.md","title":"双向绑定","text":"## Object.defineProperty\r\n\r\n```js\r\n/**\r\n * bind\r\n * @param {object} target\r\n * @param {object} model\r\n * @param {object} map\r\n */\r\nconst bind = (target, model, map) =>\r\n  Object.keys(map || target).forEach(key =>\r\n    Object.defineProperty(target, key, {\r\n      set(value) {\r\n        const mkey = map ? map[key] : key\r\n        model[mkey] = value\r\n      },\r\n      get() {\r\n        const mkey = map ? map[key] : key\r\n        return model[mkey]\r\n      }\r\n    })\r\n  )\r\n\r\nwindow.__alternate = {}\r\nconst p = document.getElementById(\"p\")\r\n\r\nbind(__alternate, p, {\r\n  value: \"innerHTML\"\r\n})\r\n```\r\n\r\n## Proxy\r\n\r\n```js\r\n/**\r\n * bind\r\n * @param {object} model\r\n * @param {object} map\r\n */\r\nconst bind = (model, map) =>\r\n  new Proxy(map || model, {\r\n    get(_, key) {\r\n      const mkey = map ? map[key] : key\r\n      return Reflect.get(model, mkey)\r\n    },\r\n    set(_, key, value) {\r\n      const mkey = map ? map[key] : key\r\n      return Reflect.set(model, mkey, value)\r\n    }\r\n  })\r\n\r\nwindow.__alternate = bind(document.getElementById(\"p\"), {\r\n  value: \"innerHTML\"\r\n})\r\n```\r\n"},{"path":"/blog/javascript/可迭代对象(iterable).md","title":"可迭代对象(iterable)","text":"# 可迭代对象(iterable)\r\n\r\n可迭代对象(iterable)就是部署有 Symbol.iterator 的对象\r\n\r\n使用 for-of 遍历时会自动获取迭代器的返回值\r\n\r\n```js\r\nconst obj = {\r\n  [Symbol.iterator]: function*() {\r\n    for (let i = 9; i > 0; i--) yield i\r\n  }\r\n}\r\n\r\nfor (let i of obj) {\r\n  console.log(i)\r\n}\r\n```\r\n\r\n# 判断一个对象是否是可遍历对象\r\n\r\n> 就是看有没有部署 Symbol.iterator 接口，该属性是 function 类型\r\n\r\n```js\r\nfunction isIterable(obj) {\r\n  return typeof obj[Symbol.iterator] === \"function\"\r\n}\r\n```\r\n\r\n# js 内置 iterable\r\n\r\nString、Array、Map、Set、arguments 和其他伪数组、generator\r\n\r\n> 注意 WeakMap 和 WeakSet 不是 iterable\r\n\r\n```js\r\nconsole.log(isIterable(\"\")) // true\r\nconsole.log(isIterable([])) // true\r\nconsole.log(isIterable(new Map())) // true\r\nconsole.log(isIterable(new WeakMap())) // false\r\nconsole.log(isIterable(new Set())) // true\r\nconsole.log(isIterable(new WeakSet())) // false\r\nconsole.log(isIterable(arguments)) // true\r\nconsole.log(isIterable(document.getElementsByTagName(\"script\"))) // true\r\nconsole.log(isIterable((function*() {})())) // true\r\n```\r\n"},{"path":"/blog/javascript/封装一个ajax.md","title":"封装一个ajax","text":"```js\r\n/**\r\n * @param {string} url\r\n * @param {string} method\r\n * @param {object} params\r\n * @returns\r\n */\r\nfunction request(url, method = \"GET\", params = null) {\r\n  return new Promise((resolve, reject) => {\r\n    const xhr = new XMLHttpRequest()\r\n    xhr.open(method, url)\r\n    xhr.addEventListener(\"readystatechange\", () => {\r\n      if (xhr.readyState === 4) {\r\n        if (xhr.status === 200) {\r\n          resolve(xhr.responseText)\r\n        } else {\r\n          reject({\r\n            code: xhr.status,\r\n            response: xhr.response\r\n          })\r\n        }\r\n      }\r\n    })\r\n    setTimeout(() => reject(\"timeout:1000\"), 1000)\r\n    xhr.send(JSON.stringify(params))\r\n  })\r\n}\r\n\r\nrequest(\"http://localhost:3005/user/?name=saber&age=21\").then(console.log)\r\nrequest(\"http://localhost:3005/user/\", \"POST\", {\r\n  name: \"saber\",\r\n  age: 233\r\n}).then(console.log)\r\n\r\nrequest(\"http://localhost:30051/user/?name=saber&age=21\").then(console.log)\r\nrequest(\"http://localhost:30051/user/\", \"POST\", {\r\n  name: \"saber\",\r\n  age: 233\r\n}).then(console.log)\r\n```\r\n\r\n# onreadystatechange\r\n\r\n每当 readyState 属性改变时，就会调用该函数\r\n\r\n### readyState\r\n\r\n0. 请求未初始化\r\n1. 服务器连接已建立\r\n1. 请求已接收\r\n1. 请求处理中\r\n1. 请求已完成，且响应已就绪\r\n\r\n### status http 状态码\r\n\r\n1xx: 请求正在处理\r\n2xx: 请求处理完毕\r\n3xx: 重定向\r\n4xx: 浏览器端（客户端）错误\r\n5xx: 服务器内部错误\r\n"},{"path":"/blog/javascript/数组克隆&数组 ES6 API实现.md","title":"数组克隆&数组 ES6 API实现","text":"# 判断一个对象是不是数组\r\n\r\n```js\r\nconst isArray0 = obj => Array.isArray(obj)\r\nconst isArray1 = obj => Object.prototype.toString.call(obj) === \"[object Array]\"\r\nconsole.log(isArray0([]))\r\nconsole.log(\r\n  isArray0({\r\n    0: \"value\",\r\n    length: 1\r\n  })\r\n)\r\nconsole.log(isArray1([]))\r\nconsole.log(\r\n  isArray1({\r\n    0: \"value\",\r\n    length: 1\r\n  })\r\n)\r\nconsole.log(isArray0(arguments))\r\nconsole.log(isArray1(arguments))\r\nconsole.log(isArray0(document.getElementsByClassName(\"\")))\r\nconsole.log(isArray1(document.getElementsByClassName(\"\")))\r\nconsole.log(isArray0(document.getElementsByTagName(\"div\")))\r\nconsole.log(isArray1(document.getElementsByTagName(\"div\")))\r\nconsole.log(\r\n  Array.from({\r\n    0: \"value\",\r\n    length: 1\r\n  })\r\n)\r\nconsole.log(\r\n  isArray0(\r\n    Array.from({\r\n      0: \"value\",\r\n      length: 1\r\n    })\r\n  )\r\n)\r\nconsole.log(\r\n  isArray1(\r\n    Array.from({\r\n      0: \"value\",\r\n      length: 1\r\n    })\r\n  )\r\n)\r\n```\r\n\r\n# es5 方法实现拷贝\r\n\r\n```js\r\n// for遍历基本类型，注意for of是取数组元素，for in是取对象属性\r\nconst clone0 = arr => {\r\n  const result = []\r\n  for (let item of arr) {\r\n    result.push(item)\r\n  }\r\n  return result\r\n}\r\n\r\nconst arr0 = [1, 2, 3]\r\nconst newArr0 = clone0(arr0)\r\narr0[2] = 233\r\nconsole.log(newArr0)\r\n\r\n/// slice是纯函数，用来截取指定区间的内容\r\nconst arr1 = [1, 2, 3]\r\nconst newArr1 = arr1.slice()\r\narr1[2] = 233\r\nconsole.log(newArr1)\r\n\r\n// concat也是纯函数\r\nconst arr2 = [1, 2, 3]\r\nconst newArr2 = Array.prototype.concat(arr2)\r\narr2[2] = 233\r\nconsole.log(newArr2)\r\n```\r\n\r\n# es6 方法实现拷贝\r\n\r\n```js\r\nconst arr3 = [1, 2, 3]\r\nconst newArr3 = Object.assign([], arr3)\r\narr3[2] = 233\r\nconsole.log(newArr3)\r\n\r\nconst arr4 = [1, 2, 3]\r\nconst newArr4 = [...arr4]\r\narr4[2] = 233\r\nconsole.log(newArr4)\r\n\r\nconst arr5 = [1, 2, 3]\r\nconst newArr5 = arr5.map(i => i)\r\narr5[2] = 233\r\nconsole.log(newArr5)\r\n\r\nconst arr6 = [1, 2, 3]\r\nconst newArr6 = arr6.reduce((out, cur) => {\r\n  out.push(cur)\r\n  return out\r\n}, [])\r\narr6[2] = 233\r\nconsole.log(newArr6)\r\n\r\nconst arr7 = [1, 2, 3]\r\nconst newArr7 = arr7.filter(_ => 1)\r\narr7[2] = 233\r\nconsole.log(newArr7)\r\n```\r\n\r\n# API 实现\r\n\r\n### map\r\n\r\n```js\r\nArray.prototype.myMap = function(callbackfn, thisArg) {\r\n  const newArr = []\r\n  for (let i = 0; i < this.length; i++) {\r\n    newArr.push(callbackfn.call(thisArg, this[i], i, this))\r\n  }\r\n  return newArr\r\n}\r\nconsole.log([1, 2, 3].myMap(i => i * i))\r\n```\r\n\r\n### reduce\r\n\r\n> 为什么原生的 reduce 没有 thisArg??\r\n\r\n```js\r\nArray.prototype.myReduce = function(callbackfn, initialValue = null) {\r\n  for (let i = 0; i < this.length; i++) {\r\n    initialValue = callbackfn(initialValue, this[i], i, this)\r\n    // initialValue = callbackfn.call(thisArg, initialValue, this[i], i, this)\r\n  }\r\n  return initialValue\r\n}\r\nconsole.log([1, 2, 3].myReduce((pre, cur) => pre + cur))\r\n```\r\n\r\n### filter\r\n\r\n```js\r\nArray.prototype.myFilter = function(callbackfn, thisArg) {\r\n  const newArr = []\r\n  for (let i = 0; i < this.length; i++) {\r\n    callbackfn.call(thisArg, this[i], i, this) && newArr.push(this[i])\r\n  }\r\n  return newArr\r\n}\r\nconsole.log([1, 2, 3].myFilter(i => i >= 2))\r\n```\r\n\r\n## 对象作用域\r\n\r\n```js\r\nconst obj = {\r\n  value: 2,\r\n  testFilter() {\r\n    // function函数作用域，上下文随调用时的作用域决定\r\n    return [1, 2, 3].myFilter(function(i) {\r\n      return i >= this.value\r\n    }, this)\r\n  },\r\n  testReduce() {\r\n    return [1, 2, 3].myReduce((pre, cur) => pre + this.value + cur, 0)\r\n  }\r\n}\r\nconsole.log(obj.testFilter())\r\nconsole.log(obj.testReduce())\r\n```\r\n"},{"path":"/blog/javascript/深拷贝.md","title":"深拷贝","text":"```js\r\nconst clone = value => {\r\n  if (typeof value !== \"object\") return value\r\n  // 遍历每个属性，执行clone，并把返回值添加到新对象对应属性上\r\n  return Object.keys(value).reduce(\r\n    (out, key) =>\r\n      Object.assign(out, {\r\n        [key]: clone(value[key])\r\n      }),\r\n    {}\r\n  )\r\n}\r\n\r\nconst obj = {\r\n  name: \"saber\",\r\n  age: 21,\r\n  like: [\"js\", \"ts\"]\r\n}\r\n\r\nconst newObj = clone(obj)\r\nconsole.log(obj, newObj)\r\nobj.age = 233\r\nobj.like.push(\"vv\")\r\nconsole.log(obj, newObj)\r\n```\r\n\r\n# 补充\r\n\r\n深拷贝遇到循环引用会无限递归导致堆栈溢出\r\nlodash 却可以实现循环引用的拷贝，它的原理：\r\n利用了 stack，每次访问一个属性后，把值存入 stack 中，如果 stack 中已经存在，说明发生了循环引用，则直接返回。\r\n即遇到循环引用的属性，就浅拷贝\r\n"},{"path":"/blog/javascript/矩形相交.md","title":"矩形相交","text":"# 测试相交元素\r\n\r\n```js\r\n/**\r\n * `请确保两个元素在同一个父元素下`\r\n * @param {HTMLElement} element1\r\n * @param {HTMLElement} element2\r\n * @param {Function} onEnter\r\n * @param {Function} onOut\r\n */\r\nconst testEnter = (element1, element2, onEnter, onOut) => {\r\n  // clientWidth表示内容宽，包含内边距\r\n  const width1 = element1.clientWidth\r\n  const height1 = element1.clientHeight\r\n  const width2 = element2.clientWidth\r\n  const height2 = element2.clientHeight\r\n  // offsetLeft表示相对父元素左边的距离\r\n  const x1 = element1.offsetLeft\r\n  const y1 = element1.offsetTop\r\n  const x2 = element2.offsetLeft\r\n  const y2 = element2.offsetTop\r\n\r\n  // 坐标区间测试\r\n  if (\r\n    x1 > x2 - width1 &&\r\n    x1 < x2 + width2 &&\r\n    y1 > y2 - height1 &&\r\n    y1 < y2 + height2\r\n  ) {\r\n    onEnter && onEnter()\r\n  } else {\r\n    onOut && onOut()\r\n  }\r\n}\r\n```\r\n"},{"path":"/blog/javascript/类和继承.md","title":"类和继承","text":"```js\r\n// 首先定义父类\r\nfunction Animal(name) {\r\n  // 构造函数中都是实例的属性，不同实例不共享\r\n  this.name = name || \"Animal\"\r\n  this.getName = function() {\r\n    return this.name\r\n  }\r\n}\r\n\r\n// 原型上的属性，不同实例会共享此属性，不能多继承\r\nAnimal.prototype.age = 233\r\n```\r\n\r\n# 原型链继承\r\n\r\n> 实例上找不到属性会去`__proto__`原型上找\r\n\r\n```js\r\nfunction Dog(name) {\r\n  this.name = name\r\n}\r\n// 设置原型为Animal实例，这会导致所有实例共享以下属性\r\nDog.prototype = new Animal(\"Dog\")\r\n```\r\n\r\n# 构造函数继承\r\n\r\n劫持父类的构造方法来初始化子类属性，多继承就多 call 几个\r\n\r\n> 只能继承构造属性，不能继承原型属性\r\n> 不能实现函数复用，每个子例都会拷贝一份\r\n> 实例不是父类实例，调用 instanceof(父类)会输出 false\r\n\r\n```js\r\nfunction Cat(name) {\r\n  Animal.call(this, name)\r\n}\r\n```\r\n\r\n# 实例继承\r\n\r\n> 为父类实例添加属性后返回。类似工厂函数。\r\n\r\n> 实例是父类实例，不是子类实例，不能多继承\r\n\r\n```js\r\nfunction Pig(name) {\r\n  const instance = new Animal(name)\r\n  return instance\r\n}\r\n```\r\n\r\n# 拷贝继承\r\n\r\n> 效率低，不可访问不可枚举方法\r\n\r\n```js\r\nfunction Chick(name) {\r\n  const instance = new Animal(name)\r\n  Object.assign(Chick.prototype, instance)\r\n}\r\n```\r\n\r\n# 组合继承\r\n\r\n> 即构造继承 + 原型继承\r\n\r\n```js\r\nfunction Cow(name) {\r\n  Animal.call(this, name)\r\n}\r\n// 调用了两次构造函数！(子类优先级高，屏蔽父类属性)\r\nCow.prototype = new Animal()\r\n// 上面重写了prototype！所以一定记得修复丢失的constructor\r\nCow.prototype.constructor = Cow\r\n```\r\n\r\n# 寄生组合继承\r\n\r\n> 思路是，去掉第二次构造函数调用\r\n\r\n```js\r\nfunction Horse(name) {\r\n  Animal.call(this, name)\r\n}\r\n// Horse.prototype = Object.create(Animal.prototype)\r\n// 修复因重写prototype丢失的constructor\r\nHorse.prototype.constructor = Horse\r\n;(function() {\r\n  // 用一个空的构造函数替换掉父类构造函数就行了\r\n  const Super = function() {}\r\n  Super.prototype = Animal.prototype\r\n  Horse.prototype = new Super()\r\n})()\r\n```\r\n\r\n# 实现私有、静态属性\r\n\r\n```js\r\nconst People = (function(_super) {\r\n  // 但是，请注意，这个私有的变量会被所有实例共享！！\r\n  // 所以typescript没有选择这种私有方式\r\n  const _name = \"this is private\"\r\n\r\n  function People(age) {\r\n    // 继承构造函数\r\n    _super.call(this)\r\n    this.age = age\r\n    this.getName = function() {\r\n      // 获取私有属性\r\n      return _name\r\n    }\r\n  }\r\n\r\n  // Object.create可以不依赖构造函数，直接使用原型生成一个实例\r\n  // 等价于用一个空的构造函数替换原型的构造函数再new\r\n  // 继承原型属性\r\n  // People.prototype = Object.create(_super.prototype)\r\n  People.prototype = Object_create(_super.prototype)\r\n  // 上面重写了原型，修复构造函数指向\r\n  People.prototype.constructor = People\r\n  // 静态属性\r\n  People.id = \"233\"\r\n\r\n  return People\r\n})(Base)\r\n\r\nfunction Base() {\r\n  this.type = \"base\"\r\n}\r\n\r\nBase.prototype.getType = function() {\r\n  return this.type\r\n}\r\n\r\nconst p = New(People)(21)\r\n\r\nconsole.log(p)\r\n// instanceof判断右边构造函数的prototype原型是否在左边实例的__proto__原型链上\r\nconsole.log(p instanceof Base) // true\r\nconsole.log(p instanceof People) // true\r\n```\r\n\r\n# Object.create 实现\r\n\r\n```js\r\nfunction Object_create(prototype) {\r\n  // 替换构造函数法\r\n  // const ctor = function () {}\r\n  // ctor.prototype = prototype\r\n  // return new ctor()\r\n  // 跳过构造函数法，直接绑定原型(原型链指向原型)\r\n  const obj = {\r\n    __proto__: prototype\r\n  }\r\n  return obj\r\n}\r\n```\r\n\r\n# new 实现\r\n\r\n> new 是用来执行函数的，只不过顺便绑定了原型。\r\n> 所以手动实现：\r\n\r\n1. 新对象绑定原型`__proto__`\r\n2. 执行构造函数(注意上下文)\r\n3. 返回新对象\r\n\r\n```js\r\n/**\r\n * @param {Function} constructor\r\n * @returns\r\n */\r\nfunction New(constructor) {\r\n  // return function () {\r\n  //   const obj = Object.create(constructor.prototype)\r\n  //   constructor.apply(obj, arguments)\r\n  //   return obj\r\n  // }\r\n  return function() {\r\n    var obj = {\r\n      __proto__: constructor.prototype\r\n    }\r\n    constructor.apply(obj, arguments)\r\n    return obj\r\n  }\r\n}\r\n```\r\n"},{"path":"/blog/javascript/节流防抖.md","title":"节流防抖","text":"# 节流\r\n\r\n```js\r\nconst throttle = (callback, delta = 500, metaKey = \"__$$count\") => {\r\n  const next = () => Reflect.set(throttle, metaKey, Date.now() + delta)\r\n  Reflect.has(throttle, metaKey) || next()\r\n  if (Date.now() > Reflect.get(throttle, metaKey)) {\r\n    next()\r\n    callback()\r\n  }\r\n}\r\n```\r\n\r\n# 防抖\r\n\r\n```js\r\nexport const debounce = (callback: Function, delta = 300) => {\r\n  clearTimeout(callback[\"throttle\"])\r\n  callback[\"throttle\"] = setTimeout(callback, delta)\r\n}\r\n```\r\n"},{"path":"/blog/javascript/进入视口范围检测.md","title":"进入视口范围检测","text":"```js\r\n/**\r\n * 进入视口范围检测\r\n *\r\n * @param {HTMLElement} element\r\n * @param {VoidFunction} onEnter\r\n * @param {VoidFunction} onOut\r\n * @param {number} [deltaTop=0]\r\n * @param {number} [deltaBottom=0]\r\n */\r\nfunction testClientRect(\r\n  element,\r\n  onEnter,\r\n  onOut,\r\n  deltaTop = 0,\r\n  deltaBottom = 0\r\n) {\r\n  const rect = element.getBoundingClientRect()\r\n  // 坐标区间检测\r\n  if (\r\n    rect.y < window.innerHeight + deltaTop &&\r\n    rect.y > -rect.height + deltaBottom\r\n  ) {\r\n    onEnter && onEnter()\r\n  } else {\r\n    onOut && onOut()\r\n  }\r\n}\r\n```\r\n"}]},{"path":"/blog/node","title":"node","children":[{"path":"/blog/node/utils","title":"utils","children":[{"path":"/blog/node/utils/promisify.md","title":"promisify","text":"# promisify\r\n\r\n快速将 callback style 的 API 转为 Promise style.\r\n\r\n```js\r\nimport { promisify } from \"util\"\r\nimport { readdir, readFile, stat, exists, mkdir, writeFile } from \"fs\"\r\n\r\nexport const ReadDir = promisify(readdir)\r\nexport const ReadFile = promisify(readFile)\r\nexport const Stat = promisify(stat)\r\nexport const Exists = promisify(exists)\r\nexport const MkDir = promisify(mkdir)\r\nexport const WriteFile = promisify(writeFile)\r\n```\r\n\r\n## 原理\r\n\r\n> 简化版，一个参数。\r\n\r\n```ts\r\nconst promiseify = <Arg, CB extends (err: Error, result: any) => any>(\r\n  method: (arg: Arg, callback: CB) => void\r\n) => (arg: Arg) =>\r\n  new Promise<Parameters<CB>[\"1\"]>((resolve, reject) => {\r\n    const callback = (err: Error, result: any) =>\r\n      err ? reject(err) : resolve.call(this, result)\r\n    try {\r\n      method.apply(null, [arg, callback])\r\n    } catch (err) {\r\n      reject(err)\r\n    }\r\n  })\r\n```\r\n\r\n将(args, callback) => void 中 callback 重写，在 callback 中执行 promise 的 executor。\r\n\r\ntypescript 类型中对 Arg 类型只能枚举，原因是 rest 参数只能作为最后一个参数。(看一下 node 的 types 声明)\r\n(同样的难题在 reselect 库中也发生)\r\n\r\n> c++可变长模板参数也是如此。\r\n"}]}]},{"path":"/blog/react","title":"react","children":[{"path":"/blog/react/React-Fiber实现.md","title":"React-Fiber实现","text":"## 前言\r\n\r\ngithub 上添加 react-like 标签的项目有 20 个左右，几乎所有的项目都是使用 Javascript 编码。\r\n难以搞清楚一个对象的具体结构，就比如 Fiber 对象，上面有很多属性，有些是指针域，有些是对象，有些是数组，有些必选有些可选。。。\r\n如果不对数据结构进行合理建模的话，很难掌握对象的属性变动，也难以分析潜在的 bug，更不用说优化、重构之类的了。\r\n\r\n下面是来自某个项目的一段 JS 代码\r\n\r\n```javascript\r\nlet oldFiber,\r\n  newFiber,\r\n  element,\r\n  instance = workInProgress.stateNode;\r\nlet newState = Object.assign(\r\n  instance.state || {},\r\n  instance._partialState || {}\r\n);\r\nlet oldProps = instance.props;\r\nlet newProps = workInProgress.props;\r\nconst getDerivedStateFromProps = instance.constructor.getDerivedStateFromProps;\r\n```\r\n\r\n从这段代码中可以大致了解到 Fiber 拥有 stateNode、props 属性，Fiber.stateNode 上有 state、partialState、props 属性同时它还是个构造函数的原型（不难看出 Fiber.stateNode 应该是个 es6 class 对象）。\r\n\r\n是不是开始感到混乱了...\r\n\r\n不是说 Javascript 代码不好，相反 JS 代码相对简洁，但是作为 Typescript 的忠实粉丝，我决定还是使用 TS 来重写一遍，顺便加深对 Fiber Reconcile 过程的理解。\r\n"},{"path":"/blog/react/reconciler实现","title":"reconciler实现","children":[{"path":"/blog/react/reconciler实现/beginWork.md","title":"beginWork","text":"## reconcile 阶段入口\r\n\r\n判断当前 fiber 的类型(host or hook)，如果是 host 类型则根据 fiber.tag 生成一个 dom 节点，如果是 hook 类型则实例就是自己，在实例上保存一个 stateNode 属性(还是自己)用于在 createWorkInProgress 执行中回溯到 rootFiber。\r\n\r\n```typescript\r\nfunction beginWork(fiber: Fiber) {\r\n  if (fiber.type === \"hook\") {\r\n    return updateHOOKComponent(fiber);\r\n  } else {\r\n    return updateHostComponent(fiber);\r\n  }\r\n}\r\n```\r\n\r\n### updateHostComponent\r\n\r\n更新 host Fiber\r\n\r\n```typescript\r\nfunction updateHostComponent(fiber: Fiber) {\r\n  // 如果实例不存在，则生成一个真实DOM节点赋给instance\r\n  if (!fiber.instance) fiber.instance = renderToDOM(fiber);\r\n  // 对props.children(通过React.createElement生成的VNode树的children集合)进行reconcile新旧比对，标记effectType\r\n  return reconcileChildren(fiber, fiber.props.children);\r\n}\r\n```\r\n\r\n#### renderToDOM\r\n\r\n根据 host Fiber 生成对应实例(真实 DOM)\r\n\r\n```typescript\r\nfunction renderToDOM(fiber: Fiber) {\r\n  // 如果fiber.tag是function类型，则返回(这里主要用于类型安全)\r\n  if (typeof fiber.tag === \"function\") return;\r\n\r\n  // host Fiber实例可能是Element也可能是Text\r\n  let dom: HTMLElement | Text = null;\r\n\r\n  if (fiber.tag === \"text\") {\r\n    // 如果tag 值为 text，则创建一个文本节点\r\n    dom = document.createTextNode(\"\");\r\n  } else {\r\n    // 根据fiber.tag创建对应真实DOM\r\n    dom = document.createElement(fiber.tag);\r\n  }\r\n\r\n  // 根据fiber.props(即JSX标签上的属性)更新DOM节点\r\n  // 第二个参数为oldProps，因为这是Fiber实例初始化，故没有alternate(旧的Fiber)。直接传一个空属性进去。\r\n  updateHostProperties(dom, {}, fiber.props);\r\n\r\n  return dom as FiberInstance;\r\n}\r\n```\r\n\r\n### updateHOOKComponent\r\n\r\n更新 hook Fiber\r\n\r\n```typescript\r\nfunction updateHOOKComponent(fiber: Fiber) {\r\n  // 如果实例不存在，则把函数组件对应Fiber(就是自己)赋给instance\r\n  if (!fiber.instance) fiber.instance = fiber as FiberInstance;\r\n  // 在实例上保存一个 stateNode 属性(还是自己)用于回溯到 rootFiber。\r\n  fiber.instance.stateNode = fiber;\r\n\r\n  // 给全局变量currentFiber赋值，在Hook API使用\r\n  currentFiber = fiber.instance;\r\n\r\n  // 用于hook API ID 分配，hook需要一个id来标识\r\n  // 例如函数组件内多个useState Hook，在fiber.state上保存initialState时需要利用id区分\r\n  // Order.fallback在hook组件执行后将id分配器回滚。(具体见后续实现)\r\n  Order.fallback();\r\n\r\n  // 这里判断fiber.tag是否为function类型，hook Fiber的实例是函数组件，所以tag就是函数组件。\r\n  if (typeof fiber.tag !== \"function\") return;\r\n  // 执行函数组件，并传入props对象，返回hook Fiber的 Vnode children\r\n  return reconcileChildren(fiber, fiber.tag(fiber.props));\r\n}\r\n```\r\n"},{"path":"/blog/react/reconciler实现/commitAllWork.md","title":"commitAllWork","text":"## commit 阶段\r\n\r\n检测到 pendingCommit 被赋值后则立刻进入 commit 阶段\r\n\r\n### 函数声明\r\n\r\n```typescript\r\nfunction commitAllWork(fiber: Fiber): void;\r\n```\r\n\r\n传入 pendingCommit(一个 EffectFibers 链表，其实是 rootFiber，rootFiber 的 effectList 属性就相当于一个 Fiber 链表。JS 里数组不也是一种链表么，还是可迭代对象(Iteratable)呢)\r\n\r\n### 函数实现\r\n\r\n```typescript\r\nfunction commitAllWork(fiber: Fiber) {\r\n  // 遍历effectList链表，对每个EffectFiber执行commitWork操作\r\n  fiber.effectList.forEach(commitWork);\r\n\r\n  // 所有任务commit完毕后，将workInProgress和pendingCommit置空\r\n  workInProgress = null;\r\n  pendingCommit = null;\r\n}\r\n```\r\n"},{"path":"/blog/react/reconciler实现/commitWork.md","title":"commitWork","text":"## 单个 Fiber 的 commit 操作\r\n\r\n### 函数声明\r\n\r\n```typescript\r\nfunction commitWork(fiber: Fiber): void;\r\n```\r\n\r\n根据 Fiber.effectType 的类型进行 commit 操作\r\n\r\n### 函数实现\r\n\r\n```typescript\r\nfunction commitWork(fiber: Fiber) {\r\n  // 向上查找host Fiber类型的parent节点\r\n  let parentFiber = fiber.parent;\r\n  while (parentFiber.type === \"hook\") {\r\n    parentFiber = parentFiber.parent;\r\n  }\r\n\r\n  // 拿到host Fiber类型的parentFiber的实例(host Fiber类型的实例是真实DOM)\r\n  const parentDom = parentFiber.instance;\r\n\r\n  // 判断effectType\r\n  if (fiber.effectType === \"place\" && fiber.type === \"host\") {\r\n    // 如果是effectType:place，并且当前fiber是host Fiber类型\r\n\r\n    // 因为组件要被其他组件替换，即UnMount，则执行effects中的清理函数。\r\n    commitEffects(fiber);\r\n    // place替换真实DOM节点(或append创建)\r\n    commitPlace(fiber, parentDom, parentFiber.refChild);\r\n  } else if (fiber.effectType === \"update\") {\r\n    // 如果是effectType:update\r\n    // diff 新旧fiber的props属性(利用alternate链接到旧的fiber的props)\r\n    updateHostProperties(fiber.instance, fiber.alternate.props, fiber.props);\r\n  } else if (fiber.effectType === \"delete\") {\r\n    // 如果是effectType:delete\r\n    // 组件卸载，执行effects中的清理函数\r\n    commitEffects(fiber);\r\n    // 删除真实DOM节点\r\n    commitDelete(fiber, parentDom);\r\n  }\r\n\r\n  // 如果组件WillMount或者UnMount则执行一次commitEffects\r\n  // 本质是遍历Fiber.effects数组，执行注册的副作用任务，并收集副作用的返回值(清理函数)。\r\n  if (!fiber.isMount) commitEffects(fiber);\r\n\r\n  // 如果props中注册了ref指针，并且当前fiber是host Fiber类型，则将实例(真实DOM)赋值给ref.current\r\n  if (\"ref\" in fiber.props && fiber.type === \"host\") {\r\n    fiber.props.ref.current = fiber.instance;\r\n  }\r\n}\r\n```\r\n\r\n#### commitPlace\r\n\r\n替换或者创建 host Fiber 的实例\r\n\r\n```typescript\r\nfunction commitPlace(fiber: Fiber, parentDom: FiberInstance, refChild: Fiber) {\r\n  if (refChild) {\r\n    // 如果存在refChild表示是一次place操作\r\n    const newChild = fiber.instance;\r\n    // refChild就是fiber.alternate.sibling.instance，即旧fiber的兄弟节点\r\n    const oldChild = refChild.instance;\r\n\r\n    // 在旧fiber的兄弟节点前插入新fiber的实例\r\n    parentDom.insertBefore(newChild, oldChild);\r\n  } else {\r\n    // 没有refChild，则是一次create操作\r\n    // 组件WillMount，设置标志位true\r\n    fiber.isMount = true;\r\n    // 在DOM树上添加host Fiber实例\r\n    parentDom.append(fiber.instance);\r\n  }\r\n}\r\n```\r\n\r\n#### commitDelete\r\n\r\n删除 host Fiber 的实例(从 DOM 树上移除)\r\n\r\n```typescript\r\nfunction commitDelete(fiber: Fiber, parentDom: FiberInstance) {\r\n  // 如果是hook Fiber，则找它的host Fiber子节点，但不能是text类型tag\r\n  while (fiber.type === \"hook\") {\r\n    if (fiber.child.tag === \"text\") break;\r\n    fiber = fiber.child;\r\n  }\r\n  // 找到了hook Fiber的host Fiber子节点，将它的实例从DOM树上移除\r\n  parentDom.removeChild(fiber.instance);\r\n}\r\n```\r\n"},{"path":"/blog/react/reconciler实现/createElement.md","title":"createElement","text":"## jsxFactory 函数\r\n\r\n即 React.createElement 函数，用于生成 VNode 节点并链接成 VNode 树\r\n\r\n### 函数声明\r\n\r\n```typescript\r\nfunction createElement<K extends keyof HTMLElementTagNameMap>(\r\n  tag: K,\r\n  props: Partial<HTMLElementTagNameMap[K]>,\r\n  ...childNodes: JSX.Element[]\r\n): JSX.Element;\r\n```\r\n\r\nK 泛型参数约束为 keyof HTMLElementTagNameMap，例如\"div\"、\"a\"、\"button\"等，可以看看 TS 标准库中对 HTMLElementTagNameMap 的定义:\r\n\r\n```typescript\r\ninterface HTMLElementTagNameMap {\r\n  a: HTMLAnchorElement;\r\n  abbr: HTMLElement;\r\n  address: HTMLElement;\r\n  applet: HTMLAppletElement;\r\n  area: HTMLAreaElement;\r\n  article: HTMLElement;\r\n  aside: HTMLElement;\r\n  audio: HTMLAudioElement;\r\n  b: HTMLElement;\r\n  base: HTMLBaseElement;\r\n  basefont: HTMLBaseFontElement;\r\n  bdo: HTMLElement;\r\n  blockquote: HTMLQuoteElement;\r\n  body: HTMLBodyElement;\r\n  br: HTMLBRElement;\r\n  button: HTMLButtonElement;\r\n  ...\r\n}\r\n```\r\n\r\n所以 HTMLElementTagNameMap[K]就是 K 对应 HTMLElement 的属性类型。\r\n\r\nchildNodes 为子节点，举个例子\r\n\r\n```typescript\r\nconst List = React.createElement(\r\n  \"ul\",\r\n  null,\r\n  React.createElement(\"li\", null),\r\n  React.createElement(\"li\", null)\r\n);\r\n```\r\n\r\n这个 List 是个 JSX.Element 实例，其 childNodes 为[{tag:\"li\", props:null}, {tag:\"li\", props:null}]，渲染到真实 DOM 就是\r\n\r\n```html\r\n<ul>\r\n  <li></li>\r\n  <li></li>\r\n</ul>\r\n```\r\n\r\n### 函数实现\r\n\r\n```typescript\r\nexport function createElement<K extends keyof HTMLElementTagNameMap>(\r\n  tag: K,\r\n  props: Partial<HTMLElementTagNameMap[K]>,\r\n  ...childNodes: JSX.Element[]\r\n): JSX.Element {\r\n  // 用于map的映射函数\r\n  // 判断childNode类型，如果它是string或者number类型，则生成一个为tag为text的VNode\r\n  // 将childNode(就是文本节点内容)作为props中nodeValue的值\r\n  const mapper = (c: any): any =>\r\n    typeof c === \"string\" || typeof c === \"number\"\r\n      ? createElement(\"text\" as \"span\", { nodeValue: c as string })\r\n      : c;\r\n\r\n  // 对childNodes中每个子节点执行上面的映射函数\r\n  const children = [].concat(...childNodes).map(mapper);\r\n  // 将处理好的children保存在props中然后返回一个VNode节点\r\n  return <any>{ tag, props: { ...props, children } };\r\n}\r\n```\r\n\r\n这里有个非常有趣的操作，看似无用\r\n\r\n```typescript\r\n[].concat(...childNodes);\r\n```\r\n\r\n[].concat(...array) 这个表达式常用来对 array 数组降维，例如\r\n\r\n```typescript\r\n[].concat(...[1, 2, [3, 4]]); // [1, 2, 3, 4]\r\n```\r\n\r\n那么 childNodes 数组什么时候可能会变的不“平坦”呢？\r\n\r\n举个场景例子，在 React 组件中常有一种操作\r\n\r\n比如想通过数组['a', 'b']得到一个 a, b, c 的列表\r\n\r\n```html\r\n<ul>\r\n  <li>a</li>\r\n  <li>b</li>\r\n  <li>c</li>\r\n</ul>\r\n```\r\n\r\n在 React 中 JSX 标签可以看作是值，那么可以使用数组 map 来高效生成：\r\n\r\n```typescript\r\n<ul>\r\n  {[\"a\", \"b\"].map(ch => (\r\n    <li key={ch}>{ch}</li>\r\n  ))}\r\n  <li>c</li>\r\n</ul>\r\n```\r\n\r\n编译之后\r\n\r\n```typescript\r\nReact.createElement(\r\n  \"ul\",\r\n  null,\r\n  [\"a\", \"b\"].map(ch =>\r\n    React.createElement(\r\n      \"li\",\r\n      { key: ch },\r\n      React.createElement(\"text\", { nodeValue: ch })\r\n    )\r\n  ),\r\n  React.createElement(\r\n    \"li\",\r\n    null,\r\n    React.createElement(\"text\", { nodeValue: \"c\" })\r\n  )\r\n);\r\n```\r\n\r\n分析一下它生成的 VNode 树\r\n\r\n```typescript\r\n{\r\n  tag: \"ul\", props: null,\r\n  [\r\n    {tag:\"li\", null,\r\n      {tag:\"text\", {nodeValue: 'a'}}\r\n    },\r\n    {tag:\"li\", null,\r\n      {tag:\"text\", {nodeValue: 'b'}}\r\n    }\r\n  ],\r\n  {tag:\"li\", null,\r\n      {tag:\"text\", {nodeValue: 'c'}}\r\n  }\r\n}\r\n```\r\n\r\n简化一下就是变成了[['a', 'b'], 'c']的结构，变不“平坦”了！但是三个 li 标签在结构上应该是['a', 'b', 'c']才对，所以需要数组降维。\r\n"},{"path":"/blog/react/reconciler实现/hook","title":"hook","children":[{"path":"/blog/react/reconciler实现/hook/createContext.md","title":"createContext","text":"## Context Hook\r\n\r\ncontext 理解为全局变量就好了，只不过约定使用 createContext 创建，使用 useContext 读取。\r\n(如果是 class 组件，需要实现为 provider & customer，但当前只实现函数组件。)\r\n\r\n### 实现\r\n\r\n```typescript\r\nfunction createContext<T extends Dict>(context: T) {\r\n  return context;\r\n}\r\n\r\nfunction useContext<T extends Dict>(context: T) {\r\n  return context;\r\n}\r\n```\r\n\r\ncontext 初次听起来怪怪的，但是实际上它就是这样。\r\nuseContext 读取了 context，其实就已经引入了副作用，至少它访问了外部环境。需要将 Context 包装在 Monad 里才对，然后把对 Context 的操作 liftM 进 Context Monad 里。(貌似 React 内部的 useContext 会引发 rerender，应该是改变 context 后需要重新通知所有组件一次)\r\n"},{"path":"/blog/react/reconciler实现/hook/useEffect.md","title":"useEffect","text":"## Effect Hook\r\n\r\n这是一个 pure 操作，将副作用包裹在了 Monad 里（可以理解为外面又包了一层函数），react 调度机制会在一轮渲染之后执行这些副作用操作，保证了副作用与函数组件主体的充分隔离。\r\n\r\n### Effect 类型\r\n\r\n```typescript\r\ntype Effect = () => Effect | void;\r\n```\r\n\r\n这是一个利用函数特性实现的 Monad。首先是个映射到自身类型的自函子，然后可以 return 可以 >>=，即自函子范畴上的幺半群。\r\n\r\n## useEffect 实现\r\n\r\n```typescript\r\nexport function useEffect(effect: Effect, deps?: any[]) {\r\n  if (deps) {\r\n    // 如果deps存在，使用memorize优化\r\n    useMemo(() => currentFiber.effects.push(effect), deps);\r\n  } else {\r\n    currentFiber.effects.push(effect);\r\n  }\r\n}\r\n```\r\n\r\n这里将 Moand 放到了一个 List 中，在纯函数组件执行完之后(进入 commitWork 阶段)，依次执行。\r\n"},{"path":"/blog/react/reconciler实现/hook/useMemo.md","title":"useMemo","text":"## Memo Hook\r\n\r\nmemorize 优化\r\n\r\n因为对于纯函数来说，相同的输入得到相同的输出，所以可以把结果缓存起来，对于同样的输入没必要再执行第二遍。\r\n\r\n### 对 deps 数组的 diff\r\n\r\n```typescript\r\nconst diffArray = <T extends any[]>(a: T, b: T) => {\r\n  if (a.length && b.length) {\r\n    let i = a.length > b.length ? a.length : b.length;\r\n    while (i--) if (a[i] !== b[i]) return false;\r\n    return true;\r\n  } else {\r\n    return false;\r\n  }\r\n};\r\n```\r\n\r\n没什么好解释的。\r\n\r\n## useMemo 实现\r\n\r\n依赖 Fiber.memorize 属性\r\n\r\n```typescript\r\n// memo hook的顺序id分配器\r\nconst MemoOrder = Order.create();\r\n\r\nexport function useMemo(callback: Function, deps: any[] = []) {\r\n  // 给当前hook关联的memorize分配一个id\r\n  const id = MemoOrder.forward();\r\n\r\n  // currentFiber是一个不断变化的值，hook内部需要捕获并缓存一份它的瞬时值\r\n  // 记录即缓存一份currentFiber，拿到控制权，用于从当前记录点恢复\r\n  const fiber = currentFiber;\r\n\r\n  // fiber.memorize是一个memorizations map，类型为 {[id:string]: Dict}\r\n  const memoMap = fiber.memorize;\r\n\r\n  // 获取上一次输入\r\n  const memorized = memoMap[id] || [];\r\n\r\n  if (diffArray(deps, memorized)) {\r\n  } else {\r\n    // 如果和上次输入不同，则更新memorization为新的deps\r\n    memoMap[id] = deps;\r\n    // 执行memo callback\r\n    callback();\r\n  }\r\n}\r\n```\r\n"},{"path":"/blog/react/reconciler实现/hook/useRef.md","title":"useRef","text":"## Ref Hook\r\n\r\nref 用来索引到 host Fiber 的实例(真实 DOM)\r\n\r\nref 是一个指针，在 JS 中实现为对象，传递它的引用避免值拷贝\r\n\r\n### ref 类型\r\n\r\n```typescript\r\ntype RefAttributes<T extends HTMLElement> = {\r\n  current: T;\r\n};\r\n```\r\n\r\n是一个对象，只有一个成员属性 current，泛型类型约束为 HTMLElement，即 T 类型需要满足 [继承自 HTMLElement] 的条件\r\n\r\n### 何时被初始化？\r\n\r\n在组件对应 Fiber commit 时初始化(异步初始化)，在组件内部需要异步读取此值，例如在 useEffect 里，在 onClick 里等等，组件内顶层直接读取值为 null(因为组件执行是同步的)\r\n\r\n在实现 commitWork 的时候已经解释了 ref 的初始化。这里不再赘述。\r\n\r\n## useRef 实现\r\n\r\n因为它本质就是利用了 JS 中对象赋值传引用的特性。所以十分简单。\r\n\r\n```typescript\r\nexport function useRef<T extends HTMLElement>(\r\n  current: T = null\r\n): React.RefAttributes<T> {\r\n  return { current };\r\n}\r\n```\r\n\r\n没有什么好解释的。\r\n\r\n> 其实就是对 ref 惰性求值，你也可以把它实现为 pure 版本，利用 Monad 包装起来，例如 ref = () => current\r\n"},{"path":"/blog/react/reconciler实现/hook/useState.md","title":"useState","text":"## State Hook\r\n\r\n在 beginWork/updateHookComponent 函数中留了两个问题，就是关于 Order 类和 currentFiber。\r\n\r\n#### updateHOOKComponent\r\n\r\n```typescript\r\nfunction updateHOOKComponent(fiber: Fiber) {\r\n  // 省略细节...\r\n\r\n  currentFiber = fiber.instance;\r\n\r\n  Order.fallback();\r\n\r\n  // 省略细节...\r\n}\r\n```\r\n\r\n### currentFiber\r\n\r\ncurrentFiber 为调度过程中的瞬时执行点，在 hook API 闭包内会捕获并保存一份拷贝。\r\n\r\n### Order\r\n\r\n顺序 ID 分配器\r\n\r\n```typescript\r\nclass Order {\r\n  private constructor() {}\r\n  public static create() {\r\n    const instance = new Order();\r\n    Order.insList.push(instance);\r\n    return instance;\r\n  }\r\n  public static insList: Order[] = [];\r\n  private it = Order.INIT();\r\n  public forward() {\r\n    return this.it.next().value;\r\n  }\r\n  private fallback() {\r\n    this.it = Order.INIT();\r\n  }\r\n  public static fallback() {\r\n    Order.insList.forEach(ins => ins.fallback());\r\n  }\r\n  private static *INIT() {\r\n    for (let i = 0; ; ++i) yield i;\r\n  }\r\n}\r\n```\r\n\r\n就是个惰性的无穷数列，即[0, 1 ..]\r\nforward 用于分配 ID，fallback 用于分配器回滚。\r\n它解决了什么问题？区分多次调用同类型 Hook API 的上下文。\r\n\r\n## useState 实现\r\n\r\n依赖 Fiber.state 属性\r\n\r\n```typescript\r\n// state hook的顺序id分配器\r\nconst StateOrder = Order.create();\r\n\r\n// setState类型\r\ntype Dispatcher<T> = (state: T) => void;\r\n\r\nexport function useState<T>(initialState: T): [T, Dispatcher<T>] {\r\n  // 给当前hook关联的state分配一个id\r\n  const id = StateOrder.forward();\r\n\r\n  // currentFiber是一个不断变化的值，hook内部需要捕获并缓存一份它的瞬时值\r\n  // 记录即缓存一份currentFiber，拿到控制权，用于从当前记录点恢复\r\n  const fiber = currentFiber;\r\n\r\n  // fiber.state是一个state map，类型为 {[id:string]: Dict}\r\n  const stateMap = fiber.state;\r\n\r\n  // 如果当前id不存在则stateMap[id]初始化为init state\r\n  if (!(id in stateMap)) stateMap[id] = initialState;\r\n\r\n  // setState函数\r\n  const setState: Dispatcher<T> = state => {\r\n    // 检查setState执行时期，如果workInProgress存在表明是同步调用setState\r\n    // setState必须为异步调用，否则调度机制会陷入死循环\r\n    // 而且同步调用setState也没有任何意义。\r\n    if (workInProgress) {\r\n      throw new Error(\"setState should be executed asynchronously.\");\r\n    }\r\n\r\n    // 根据id拿到当前hook分配到的state，并更新为传入的新的state\r\n    stateMap[id] = state;\r\n\r\n    // 从hook 闭包内保存的fiber断点恢复(或叫返回现场)\r\n    React.render(fiber);\r\n  };\r\n\r\n  // 返回分配到的state和setState函数\r\n  return [stateMap[id], setState];\r\n}\r\n```\r\n"}]},{"path":"/blog/react/reconciler实现/performUnitOfWork.md","title":"performUnitOfWork","text":"## 函数声明\r\n\r\n```typescript\r\nfunction performUnitOfWork(fiber: Fiber): void;\r\n```\r\n\r\n遍历一颗 Fiber 链表，reconcile 然后收集 effectFibers(向上合并最终收集到 Fiber 链表的 head Fiber(即 rootFiber)的 effectLists 中)\r\n\r\n## 函数实现\r\n\r\n```typescript\r\nfunction performUnitOfWork(fiber: Fiber) {\r\n  // beginWork内部负责对fiber.child的两条sibling-sibling链表进行新旧比对\r\n  // 通过child.alternate拿到旧的链表\r\n  // 最终返回fiber.child\r\n  const next = beginWork(fiber);\r\n  // 如果next(也就是fiber.child)存在，则直接返回它\r\n  if (next) return next;\r\n\r\n  // 如果不存在，则开始回溯\r\n  let current = fiber;\r\n  while (current) {\r\n    // completeWork负责向上收集effectFibers，如果到达了顶点，则把当前Fiber节点赋值给pendingCommit\r\n    completeWork(current);\r\n\r\n    // 如果有sibling，则返回它的sibling\r\n    if (current.sibling) return current.sibling;\r\n    // 如果没有sibling，则向上回溯\r\n    current = current.parent;\r\n  }\r\n}\r\n```\r\n"},{"path":"/blog/react/reconciler实现/performWork.md","title":"performWork","text":"## performWork 渲染流程\r\n\r\nrender 渲染流程入口\r\n\r\n### 函数声明\r\n\r\n```typescript\r\nfunction performWork(deadline: IdleDeadline);\r\n```\r\n\r\nperformWork 由 requestIdleCallback 函数注册到后台协同任务队列，当 JS 线程空闲时执行队列中的函数。\r\n\r\n### 函数实现\r\n\r\n```typescript\r\nfunction performWork(deadline: IdleDeadline) {\r\n  // 内部循环迭代workInProgress\r\n  workLoop(deadline);\r\n\r\n  // 如果workInProgress为空了，表示当前渲染任务执行完毕，查看updateQueue是否为空\r\n  // 如果不为空则再请求一次后台协同任务\r\n  if (workInProgress || updateQueue.length) {\r\n    requestIdleCallback(performWork);\r\n  }\r\n}\r\n```\r\n"},{"path":"/blog/react/reconciler实现/reconcileChildren.md","title":"reconcileChildren","text":"## children 新旧比对\r\n\r\n拿到当前 fiber 对应 VNode 树的 children 集合作为新链表，通过 alternate 拿到旧链表，然后 diff 两条链表。\r\n\r\n### 函数声明\r\n\r\n```typescript\r\nfunction reconcileChildren(fiber: Fiber, newChildren: Fiber | Fiber[]): Fiber;\r\n```\r\n\r\n第二个参数 newChildren 来源：当 fiber 为 host Fiber 类型时，则从 props.children 中取(由 jsxFactory 函数即 React.createElement 函数收集 children VNode)；当 fiber 为 hook Fiber 类型时(此时 fiber.tag 为 function 类型，也就是你的函数组件)，执行 fiber.tag(fiber.props)，即将 props 传入函数组件执行，返回 children。\r\n\r\n### 函数实现\r\n\r\n```typescript\r\nfunction reconcileChildren(fiber: Fiber, newChildren: Fiber | Fiber[]) {\r\n  // 数组化，归一化处理。例如'a' -> ['a'], ['a', 'b'] -> ['a', 'b']\r\n  const children = React.Children.toArray<Fiber>(newChildren);\r\n\r\n  // 拿到旧fiber节点的child\r\n  let nextOldFiber = fiber.alternate ? fiber.alternate.child : null;\r\n\r\n  let newFiber: Fiber = null;\r\n  let i = 0;\r\n\r\n  // 新旧两条链表开始比对，一条是VNode.props.children链表，一条是oldFiber.sibling链表\r\n  while (i < children.length || nextOldFiber) {\r\n    // prevChild用来记录上一次的newFiber，用于链接新的sibling-sibling链表\r\n    const prevChild = newFiber;\r\n\r\n    // 遍历过程中当前旧的节点\r\n    const oldFiber = nextOldFiber;\r\n\r\n    // 当前新的VNode节点\r\n    const element = i < children.length && children[i];\r\n\r\n    // 如果oldFiber存在且element也存在，并且两者tag相同，则两个fiber节点相同\r\n    // 否则不同\r\n    const sameTag = oldFiber && element && element.tag === oldFiber.tag;\r\n\r\n    if (sameTag) {\r\n      // 如果新旧节点相同，则直接拷贝旧的节点，并标记effectType为update\r\n      // 为什么要拷贝，而不是直接newFiber = oldFiber，下文解释\r\n\r\n      newFiber = new Fiber(oldFiber.type);\r\n      newFiber.tag = oldFiber.tag;\r\n      newFiber.instance = oldFiber.instance;\r\n      newFiber.state = oldFiber.state;\r\n      newFiber.props = element.props;\r\n      newFiber.parent = fiber;\r\n      newFiber.alternate = oldFiber; // 新fiber上利用alternate链接到旧的fiber，后续commit:update需要\r\n      newFiber.effectType = \"update\";\r\n      newFiber.effects = oldFiber.effects;\r\n      newFiber.isMount = oldFiber.isMount;\r\n    }\r\n    if (element && !sameTag) {\r\n      // 如果新的节点存在，但和旧的节点不同，则保持新节点的属性，并标记effectType为place\r\n\r\n      newFiber = new Fiber(typeof element.tag === \"string\" ? \"host\" : \"hook\");\r\n      newFiber.tag = element.tag;\r\n      newFiber.props = element.props;\r\n      newFiber.parent = fiber;\r\n      newFiber.effectType = \"place\";\r\n      newFiber.isMount = false; // 要被替换掉，所以UnMount\r\n    }\r\n    if (oldFiber && !sameTag) {\r\n      // 如果旧的节点存在，但和新的节点不同，则删除旧的节点，并标记effectType为delete\r\n\r\n      oldFiber.effectType = \"delete\";\r\n      oldFiber.isMount = false; // 要被删除掉，所以UnMount\r\n      // 提交到parent Fiber effectList中\r\n      fiber.effectList.push(oldFiber);\r\n      // 节点被删除，在父节点上标记refChild\r\n      fiber.refChild = oldFiber.sibling;\r\n    }\r\n\r\n    // 旧链表向后遍历\r\n    if (nextOldFiber) nextOldFiber = nextOldFiber.sibling;\r\n\r\n    if (i === 0) {\r\n      // 如果是第一个child则赋给parentFiber.child\r\n      fiber.child = newFiber;\r\n    } else if (prevChild && element) {\r\n      // 链接新链表的sibling-sibling\r\n      prevChild.sibling = newFiber;\r\n    }\r\n\r\n    // 新链表向后遍历，element依靠index索引从children获取current节点\r\n    i++;\r\n  }\r\n\r\n  // 返回第一个child\r\n  return fiber.child;\r\n}\r\n```\r\n\r\n解释当 effectType 为 update 时为什么要拷贝:\r\n一个词 immutable.\r\n"},{"path":"/blog/react/reconciler实现/render.md","title":"render","text":"## ReactDOM.render\r\n\r\n渲染流程起点\r\n\r\n### 函数声明\r\n\r\n```typescript\r\nexport namespace ReactDOM {\r\n  export function render(component: JSX.Element): void;\r\n  export function render(component: JSX.Element, container: HTMLElement): void;\r\n}\r\n```\r\n\r\n函数重载两次\r\n\r\n传入 container 参数(也就是 div#root)，表示这是第一次渲染，并清空 rootContainer 子节点。创建一个 host Fiber(rootFiber)，其实例为 container，将 component 添加到 rootFiber 的子节点(即保存到 rootFiber.props 的 children 属性 )。\r\n\r\n不传 container 参数表示是一次由 hook 函数组件调用 ReactDispatcher 引起的更新(场景为用户点击事件)，例如 useState 返回的 setState 函数执行，在 createWorkInProgress 函数中将从当前 fiber 实例上的 stateNode 向上回溯到 rootFiber 并赋值给 workInProgress。\r\n\r\n### 函数实现\r\n\r\n```typescript\r\nexport namespace ReactDOM {\r\n  export function render(\r\n    component: JSX.Element,\r\n    container?: HTMLElement\r\n  ): void {\r\n    let fiber: Fiber;\r\n\r\n    if (container) {\r\n      // 第一次渲染\r\n\r\n      // 创建一个rootFiber\r\n      fiber = new Fiber(\"host\");\r\n\r\n      // rootFiber实例为真实DOM(div#root)\r\n      fiber.instance = container as FiberInstance;\r\n\r\n      // 清空rootFiber实例子节点\r\n      container.innerHTML = null;\r\n\r\n      // 将component添加到 rootFiber 的子节点\r\n      fiber.props = { children: component };\r\n    } else {\r\n      // 创建一个hook Fiber\r\n      fiber = new Fiber(\"hook\");\r\n\r\n      // 将函数组件作为hook Fiber的实例\r\n      fiber.instance = component as FiberInstance;\r\n\r\n      // 设置高优先级\r\n      fiber.expirationTime = 1;\r\n    }\r\n\r\n    // 放入待调度队列\r\n    updateQueue.push(fiber);\r\n\r\n    // 启动渲染流程\r\n    requestIdleCallback(performWork);\r\n  }\r\n}\r\n```\r\n"},{"path":"/blog/react/reconciler实现/updateHostProperties.md","title":"updateHostProperties","text":"## 更新 DOM\r\n\r\ndom 操作\r\n\r\n### 函数声明\r\n\r\n```typescript\r\ntype Dict = { [k: string]: any };\r\n\r\nfunction updateHostProperties(\r\n  dom: (HTMLElement | Text) & Dict,\r\n  oldProps: Dict,\r\n  newProps: Dict\r\n): void;\r\n```\r\n\r\n三个参数，dom 的类型为 HTMLElement 或者 Text，`& Dict`用于给这俩个类型添加属性索引，第二个参数为 dom 节点旧的属性，即 host Fiber 的 alternate.props，第三个参数为新的 host Fiber 的 props，由 React.createElement 生成的 VNode 节点提供。\r\n\r\n### 函数实现\r\n\r\n```typescript\r\n// props中需要过滤掉的属性\r\nconst fiberProps = [\"children\", \"ref\"];\r\n\r\nfunction updateHostProperties(\r\n  dom: (HTMLElement | Text) & Dict,\r\n  oldProps: Dict,\r\n  newProps: Dict\r\n) {\r\n  // 遍历newProps属性，diff\r\n  Object.entries(newProps).forEach(([k, v]) => {\r\n    // 过滤属性\r\n    if (fiberProps.includes(k)) return;\r\n    // style属性过滤掉，下文单独处理\r\n    if (k === \"style\") return;\r\n    // 新旧值没变化，跳过此次DOM操作\r\n    if (oldProps[k] === v) return;\r\n    // on开头的event事件handle变lower case\r\n    if (k.startsWith(\"on\")) k = k.toLowerCase();\r\n    // 应用变化的属性到真实DOM\r\n    dom[k] = v;\r\n  });\r\n  // style属性diff\r\n  if (\"style\" in dom) {\r\n    const newStyle = newProps.style || {};\r\n    const oldStyle = oldProps.style || {};\r\n    Object.entries(newStyle).forEach(([k, v]) => {\r\n      // 新旧样式属性没变化，跳过此次DOM操作\r\n      if (oldStyle[k] === v) return;\r\n      // 应用变化的样式属性到真实DOM\r\n      dom.style[k] = v;\r\n    });\r\n  }\r\n}\r\n```\r\n"},{"path":"/blog/react/reconciler实现/workLoop.md","title":"workLoop","text":"## workLoop 渲染循环\r\n\r\n用于创建并迭代更新 workInProgress(一个 Fiber 链表)。同时负责检查 pendingCommit(就是收集了 effectFibers 的 rootFiber，也可以实现为一个 Fiber 链表)，如果有就进入 commit 阶段。\r\n\r\n### 函数声明\r\n\r\n```typescript\r\nfunction workLoop(deadline: IdleDeadline);\r\n```\r\n\r\n传入了一个 deadline 对象，检查空闲时间。\r\n\r\n### 函数实现\r\n\r\n```typescript\r\nfunction workLoop(deadline: IdleDeadline) {\r\n  // 如果workInProgress为空，则先构建一个Fiber赋值给workInProgress\r\n  // 本质是回溯到rootFiber\r\n  if (!workInProgress) workInProgress = createWorkInProgress(updateQueue);\r\n\r\n  // 如果workInProgress不为空且当前空闲时间足够就开始迭代更新。\r\n  while (\r\n    workInProgress &&\r\n    deadline.timeRemaining() > workInProgress.expirationTime\r\n  ) {\r\n    // 迭代更新\r\n    workInProgress = performUnitOfWork(workInProgress);\r\n  }\r\n\r\n  // 如果有pendingCommit则立刻commit\r\n  if (pendingCommit) commitAllWork(pendingCommit);\r\n}\r\n```\r\n"},{"path":"/blog/react/reconciler实现/全局变量.md","title":"全局变量","text":"## 概览\r\n\r\n在调度更新时全局范围内存在有四个变量\r\n\r\n```typescript\r\nconst updateQueue: Fiber[] = [];\r\nlet workInProgress: Fiber;\r\nlet pendingCommit: Fiber;\r\nlet currentFiber: Fiber;\r\n```\r\n\r\n### updateQueue\r\n\r\n一个任务队列。用于注册待调度更新的 Fiber 链表。当浏览器空闲时会从中取出 Fiber 链表开始调度更新。\r\n\r\n### workInProgress\r\n\r\n在迭代更新(新旧更替)过程中的 Fiber 链表快照。\r\n\r\n### pendingCommit\r\n\r\n在 workLoop 过程中收集到的标记有 EffectType 的 Fiber 链表，等待 commit。\r\n\r\n### currentFiber\r\n\r\n当前正在调度更新的 Fiber 节点。在 Hook API 中会读取并缓存一份此值的拷贝(保存现场，即 yield)，用于在渲染完毕之后返回现场。\r\n"}]},{"path":"/blog/react/数据结构类型","title":"数据结构类型","children":[{"path":"/blog/react/数据结构类型/Fiber数据结构.md","title":"Fiber数据结构","text":"## Fiber 链表\r\n\r\n> 数据域和 React Fiber 有所区别，但核心的指针域是一样的。\r\n\r\n### 概览\r\n\r\n```typescript\r\ntype Fiber = {\r\n  type: FiberType;\r\n  tag: Tag | React.FC;\r\n  effectType: EffectType;\r\n  parent: Fiber;\r\n  child: Fiber;\r\n  sibling: Fiber;\r\n  alternate: Fiber;\r\n  props: Props;\r\n  state: Dict;\r\n  memorize: Dict;\r\n  effects: Effect[];\r\n  effectList: Fiber[];\r\n  instance: FiberInstance;\r\n  stateNode: Fiber;\r\n  expirationTime: number;\r\n  isMount: boolean = false;\r\n  refChild: Fiber;\r\n};\r\n```\r\n\r\n### Fiber.type\r\n\r\n```typescript\r\ntype FiberType = \"host\" | \"hook\";\r\n```\r\n\r\n如果一个 Fiber 的 type 值为 \"host\"，那么表示它的实例(Fiber.instance)是原生 DOM 节点。\r\n如果值为\"hook\"，那么表示它的实例是函数组件(React.FC)对应的 Fiber，也就是自己，此时 Fiber.tag 是函数组件(function)。\r\n\r\n### Fiber.tag\r\n\r\n```typescript\r\ntype Fiber = {\r\n  tag: Tag | React.FC;\r\n};\r\n\r\n// Dict 字典类型\r\ntype Dict = { [k: string]: any };\r\n\r\nnamespace React {\r\n  // FC 函数组件类型\r\n  export type FC<T extends Dict = Dict> = (props: T) => JSX.Element;\r\n}\r\n\r\ntype Tag = keyof HTMLElementTagNameMap | \"text\";\r\n```\r\n\r\nFiber.tag 的类型可以是 string 类型，也可以是 function 类型。string 类型就是原生 DOM 节点的 TagNameMap 集合成员，这里在集合中添加了一个新的 tag: \"text\"，用于表示原生 Text 对象，即文本节点。\r\n\r\n当 tag 为 string 类型时，Fiber.instance 就是 DOM 实例，为 function 类型时，Fiber.instance 就是函数组件对应的 Fiber\r\n\r\n### Fiber.effectType\r\n\r\n```typescript\r\ntype EffectType = \"place\" | \"delete\" | \"update\";\r\n```\r\n\r\neffectType 有三种类型，替换，删除，更新。\r\n\r\n其实还有创建，但是其过程和 place 相似(从无到有不也是一种替换么？)，故只要在 reconcile 阶段 和 commit 阶段 处理中稍作判断即可当作 place 处理。\r\n\r\n### Fiber 指针域(parent, child, sibling)\r\n\r\n```typescript\r\ntype Fiber = {\r\n  parent: Fiber;\r\n  child: Fiber;\r\n  sibling: Fiber;\r\n};\r\n```\r\n\r\nFiber 链表的空间结构\r\n\r\n```typescript\r\nparent\r\n|    \\\r\nchild-sibling\r\n|\r\nchild\r\n```\r\n\r\n和 TreeNode 数据结构有所不同，Fiber 添加了一个称做 sibling 的指针域，指向自己的兄弟节点。在 TreeNode 的遍历中可以直接拿到 children 集合，然后使用栈或者队列进行深度优先或者广度优先遍历。而在 Fiber 节点中，采取的是深度优先 + 回溯的办法遍历，优先向下遍历 child-child 链表，到头之后优先回溯到 sibling，再向下遍历 child-child 链表，如果没有 sibling 就回溯到 parent，如果没有 parent 就遍历终止。\r\n\r\n### Fiber.alternate\r\n\r\n```typescript\r\ntype Fiber = {\r\n  alternate: Fiber;\r\n};\r\n```\r\n\r\nalternate 用于链接到旧的自己。\r\n\r\n在 reconcileChildrenArray 阶段中判断 tag 是否相同，相同则标记 effectType:'update'，tag 不同或者旧的自己为 null 则标记 effectType:'place'，并把旧的自己标记 effectType:'delete'然后提交到 parent 的 effectList 中。\r\n\r\n在 commit 阶段的 effectType:update 处理中，利用 alternate 链接到旧的自己并与之 diff props 判断，更新变化的属性到真实 DOM。\r\n\r\n### Fiber.props\r\n\r\n```typescript\r\ntype Dict = { [k: string]: any };\r\n\r\ninterface Props extends Dict {\r\n  children?: Fiber | Fiber[];\r\n  ref?: React.RefAttributes<any>;\r\n}\r\n```\r\n\r\n如果 Fiber.type 值为'host'， 那么 props 表示真实 DOM 数据域，用于描述 DOM 属性。在 commit effectType:'update' 阶段参与属性 diff。\r\n\r\n如果 Fiber.type 值为'hook'，则 props 用于函数组件传值，例如传递 children。在 updateHookComponent 阶段中将 props 传入函数组件实例并执行，得到新的 elements(VDom tree 的所有孩子节点) 用于 reconcileChildrenArray。\r\n\r\n### Fiber.state\r\n\r\n```typescript\r\ntype Fiber = {\r\n  state: Dict;\r\n};\r\n```\r\n\r\nFiber 函数组件状态。在 useState Hook 中读取和更新。\r\n\r\n### Fiber.memorize\r\n\r\n```typescript\r\ntype Fiber = {\r\n  memorize: Dict;\r\n};\r\n```\r\n\r\n记录 memo hook 上次的输入。\r\n\r\n### Fiber.effects\r\n\r\n```typescript\r\ntype Effect = (...args: any) => Effect | void;\r\n\r\ntype Fiber = {\r\n  effects: Effect[];\r\n};\r\n```\r\n\r\nFiber 函数组件中的副作用操作，在该 Fiber 最终的 commit 阶段执行。\r\n如果 effect 执行后返回了新的函数，则保存新的函数到 effects 中，在 commit effectType:'place'阶段和 commit effectType:'delete'执行。\r\n\r\n使用 Fiber.isMount 来确定副作用是否需要 commit，如果组件已经 Mount，则保持 effects。\r\n\r\n> Effect 是一个自函子类型，将自身映射为自身类型，其实应该算是 Monad 了。其实函数本身就是个 Monad，函数本身就实现了 return (高阶化) 和>>= (函数执行降阶)。\r\n\r\n### Fiber.effectList\r\n\r\n```typescript\r\ntype Fiber = {\r\n  effectList: Fiber[];\r\n};\r\n```\r\n\r\n用于向上收集打上 effectType 标记的 Fiber 节点，最终收集到 rootFiber。在 commit 阶段遍历 effectList 中所有 Fiber。\r\n\r\n### Fiber.instance\r\n\r\n```typescript\r\ntype FiberInstance = Fiber & HTMLElement;\r\n\r\ntype Fiber = {\r\n  instance: FiberInstance;\r\n};\r\n```\r\n\r\nFiber 实例，当 Fiber.type 值为'host'时，instance 就是真实 DOM，值为'hook'时，instance 就是函数组件对应 Fiber(自己)。\r\n\r\n### Fiber.stateNode\r\n\r\n```typescript\r\ntype Fiber = {\r\n  stateNode: Fiber;\r\n};\r\n```\r\n\r\n在 rootFiber 实例(rootContainer 也就是 div#root 节点) 上链接到 rootFiber。\r\n\r\n### Fiber.expirationTime\r\n\r\n```typescript\r\ntype Fiber = {\r\n  expirationTime: number;\r\n};\r\n```\r\n\r\nFiber 完成一次 reconcile 所需要的最少时间。\r\n\r\n### Fiber.isMount\r\n\r\n```typescript\r\ntype Fiber = {\r\n  isMount: boolean;\r\n};\r\n```\r\n\r\n标记 Fiber Mount 状态\r\n\r\n### Fiber.refChild\r\n\r\n```typescript\r\ntype Fiber = {\r\n  refChild: Fiber;\r\n};\r\n```\r\n\r\n当 Fiber.effectType 为'delete'时将自己的 sibling 标记到 parent 的 refChild 属性，用于 commit effectType:'place'阶段的 insertBefore。\r\n在 commit effectType:'place'阶段会判断 parent 上的 refChild 属性是否为空，如果为空则表示 create 操作(append)，如果不为空则表示 place 操作(insertBefore)。\r\n"},{"path":"/blog/react/数据结构类型/关于TSX的类型定义.md","title":"关于TSX的类型定义","text":"## JSX 接口\r\n\r\n在 global 命名空间中有一个抽象接口 JSX\r\n\r\nJSX 接口中的部分类型\r\n\r\n```typescript\r\ndeclare global {\r\n  namespace JSX {\r\n    // 标签集合接口，定义了可用的标签类型和对应属性。(需要你实现。)\r\n    type IntrinsicElements = {};\r\n    // JSX.Element 接口(需要你实现。)\r\n    interface Element {}\r\n    // Children 类型接口，用于对闭合标签中children做类型检查。(需要你实现。)\r\n    interface ElementChildrenAttribute {}\r\n  }\r\n}\r\n```\r\n\r\n#### JSX.IntrinsicElements\r\n\r\nJSX 标签集合接口，类似 HTMLElementTagNameMap\r\n\r\n```typescript\r\ndeclare global {\r\n  namespace JSX {\r\n    type IntrinsicElements = {\r\n      view: { bindtap?: Function };\r\n      richText: { bindtap?: Function };\r\n      text: { bindtap?: Function };\r\n      label: { bindtap?: Function };\r\n      navigator: { bindtap?: Function };\r\n    };\r\n  }\r\n}\r\n```\r\n\r\n在 global::JSX::IntrinsicElements 中实现标签名和对应的属性，然后在.tsx 文件中的 JSX 标签就会有 view、richText 这些的类型提示，并且都提示有一个可选的 bindtap 属性。例如\r\n\r\n```typescript\r\nfunction App() {\r\n  return (\r\n    <view>\r\n      <text bindtap={() => console.log(\"click\")} />\r\n      <text />\r\n    </view>\r\n  );\r\n}\r\n```\r\n\r\n#### 类型 mapped type\r\n\r\n因为都有 bindtap 属性所以可以直接抽离出来，然后使用 mapped type，将 TagNameMap 集合中每个属性的值并入一个 Base 基类型得到一个新的集合类型 IntrinsicElements\r\n\r\n> 有点类似 Functor，将`& Base`运算应用到 TagNameMap 范畴中的每个值，然后得到新的范畴 IntrinsicElements\r\n\r\n```typescript\r\n// TagNameMap 范畴\r\ntype TagNameMap = {\r\n  view: {};\r\n  richText: {};\r\n  text: {};\r\n  label: {};\r\n  navigator: {};\r\n};\r\n\r\ntype Base = {\r\n  bindtap?: Function;\r\n};\r\n\r\ndeclare global {\r\n  namespace JSX {\r\n    // IntrinsicElements 范畴\r\n    type IntrinsicElements = {\r\n      [Tag in keyof TagNameMap]: TagNameMap[Tag] & Base\r\n    };\r\n  }\r\n}\r\n```\r\n\r\n### JSX.ElementChildrenAttribute\r\n\r\n它用来干什么，举个例子 8\r\n\r\n就在上面例子基础上扩展\r\n\r\n```typescript\r\ndeclare global {\r\n  namespace JSX {\r\n    type IntrinsicElements = {\r\n      [Tag in keyof TagNameMap]: TagNameMap[Tag] & Base\r\n    };\r\n    export interface Element extends Base {}\r\n    export interface ElementChildrenAttribute {\r\n      children: any; // JSX标签中子节点即children的类型\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n写一个 Component，子节点是个 function，即 render props 方式渲染\r\n\r\n```typescript\r\nfunction Text({ children }: { children?: (value: number) => JSX.Element }) {\r\n  return <text>{children(233)}</text>;\r\n}\r\n\r\nfunction App() {\r\n  return (\r\n    <view>\r\n      <text bindtap={() => console.log(\"click\")} />\r\n      <Text>{value => <text>{value}</text>}</Text>\r\n    </view>\r\n  );\r\n}\r\n```\r\n\r\n<Text/>标签的子节点被约束为(value: number) => JSX.Element 类型，Text Component 内部传给它一个值执行返回 JSX.Element。\r\nReact 中 Context Customer 就是采用此种方式渲染。\r\n\r\n如果去掉 JSX.ElementChildrenAttribute 中 children 的声明，在 App 组件内调用 Text 组件时，Text 组件的子节点类型就会变成 any。所以它的作用就是用于约束 JSX Children 的类型\r\n\r\n## 关于 TSX 编译\r\n\r\n如果是 jsx 文件，需要给 babel 添加@babel/plugin-transform-react-jsx 插件，并配置 pragma(即 jsxFactory 函数)为你实现的 createElement 函数，例如默认的 React.createElement。\r\n\r\n但是现在是 tsx 文件，ts 编译到 js 可以在 tsconfig.json 中配置 compileOptions，可以指定到 target，即具体的 es 版本，和 module 模块规范等。\r\ntsx 需要配置两个选项：\r\n\r\n1. 一个必选的 jsx，如果指定为 react，tsc 会把 tsx 标签编译为 createElement 形式(脱糖编译)，如果指定为 preserve，则保留 jsx 部分不变(不脱糖编译)。如果要使用 Fragment 标签，则 jsx 必须指定为 react。\r\n\r\n2. 可选的 jsxFactory，默认为 React.createElement。\r\n"}]},{"path":"/blog/react/浏览器API","title":"浏览器API","children":[{"path":"/blog/react/浏览器API/requestIdleCallback方法.md","title":"requestIdleCallback方法","text":"## 简介\r\n\r\n这个 API 是 BOM API 之一，即 window.requestIdleCallback，由浏览器实现。在 Node.js 上没有此 API 的实现。\r\n\r\n它会在浏览器空闲时期调用注册的函数，即 JS 引擎的空闲时期。\r\n\r\n函数签名(由于还处于提案阶段，Typescript 并没有给出函数的声明，所以需要自己 declare 声明函数的签名)\r\n\r\n```typescript\r\ndeclare interface IdleDeadline {\r\n  readonly didTimeout: boolean;\r\n  timeRemaining(): number; // 时间片中剩余时间(0 <= timeRemained < 50)\r\n}\r\n\r\ndeclare type IdleOptions = {\r\n  timeout: number;\r\n};\r\n\r\ndeclare type IdleCallback = (deadline: IdleDeadline) => void;\r\n\r\ndeclare function requestIdleCallback(callback: IdleCallback): number;\r\n\r\ndeclare function requestIdleCallback(\r\n  callback: IdleCallback,\r\n  options: IdleOptions\r\n): number;\r\n```\r\n\r\n浏览器将时间以每 50ms 切成片，每个时间片内会执行 JS 线程。如果有空余时间，会执行 IdleCallback，并传入一个 deadline 对象，用于获取剩余空闲时间。\r\n\r\n## Fiber 相关\r\n\r\n此 API 对于 Fiber 调度算法的意义重大，通过判断算法复杂度和 timeRemained 的相对大小决定是否进行调度更新。\r\n\r\n在 Fiber 调度逻辑中，requestIdleCallback 用于迭代更新 workInProgress\r\n\r\n简化后的逻辑\r\n\r\n```typescript\r\nfunction workLoop(deadline: IdleDeadline) {\r\n  nextWorkInProgress = performUnitOfWork(nextWorkInProgress);\r\n\r\n  if (nextWorkInProgress) {\r\n    requestIdleCallback(workLoop);\r\n  }\r\n}\r\n\r\n// 开始调度循环\r\nrequestIdleCallback(workLoop);\r\n```\r\n"}]}]},{"path":"/blog/reflect","title":"reflect","children":[{"path":"/blog/reflect/reflect-metadata中HashMap巨大Object的读取速度优化.md","title":"reflect-metadata中HashMap巨大Object的读取速度优化","text":"HashMap 原理比较复杂，不是这篇文章重点。(其实是本菜鸡不懂(\r\n\r\nreflect-metadata 中实现了 HashMap 的 polyfill，需要能快速读取数据，而 js 的 Object 当属性很多的时候性能并不好，不然就不会有 Map 了。然而 reflect-metadata 中 HashMap 用的是 Dictionary，利用了一个非常 hack 的方法。\r\n\r\nHashMap\r\n\r\n```typescript\r\ntype HashMap<V> = Record<string, V>;\r\n\r\nconst HashMap = {\r\n  // create an obj into dictionary mode (a.k.a. \"slow\" mode on v8)\r\n  create: <V>() => MakeDictionary(Object.create(null) as HashMap<V>),\r\n\r\n  has: <V>(map: HashMap<V>, key: string | number | symbol) =>\r\n    Object.prototype.hasOwnProperty.call(map, key),\r\n\r\n  get: <V>(map: HashMap<V>, key: string | number | symbol): V | undefined =>\r\n    Object.prototype.hasOwnProperty.call(map, key)\r\n      ? map[key as string | number]\r\n      : undefined\r\n};\r\n```\r\n\r\n好像有点简单啊，除了有个 MakeDictionary 函数\r\n\r\n在 reflect-metadata 源码中最后有一个 MakeDictionary 函数，来看看这个神奇的函数\r\n\r\nMakeDictionary\r\n\r\n```typescript\r\n// uses a heuristic used by v8 and chakra to force an obj into dictionary mode.\r\nfunction MakeDictionary<T>(obj: T): T {\r\n  (<any>obj).__ = undefined;\r\n  delete (<any>obj).__;\r\n  return obj;\r\n}\r\n```\r\n\r\n它给 obj 添加了\\_\\_属性，值为 undefined，然后又删了，注释解释说这可以启发 v8 或者査克拉引擎将 Object 转换到 dictionary mode（？？），可以大幅提升 Object 属性读取的速度？\r\n\r\n下面来测试一下（Node 环境）\r\n\r\n先写一个 fill 函数，用来填充属性\r\n\r\n```typescript\r\nfunction fillSomething(obj: Object, size: number = 100000) {\r\n  while (size--) obj[size] = Math.random();\r\n}\r\n```\r\n\r\n测试一下读取速度\r\n\r\n```typescript\r\n// 普通obj\r\nconst obj = {};\r\n// 填充100000个随机属性\r\nfillSomething(obj);\r\n\r\nconsole.time(\"obj\");\r\nconsole.log(obj[\"5555\"]);\r\nconsole.timeEnd(\"obj\"); // obj 2.813ms\r\n\r\n// 创建一个hashMap\r\nconst hashMap = HashMap.create();\r\n// 填充100000个随机属性\r\nfillSomething(hashMap);\r\n\r\nconsole.time(\"hashMap\");\r\nconsole.log(HashMap.get(hashMap, \"5555\"));\r\nconsole.timeEnd(\"hashMap\"); // hashMap 0.398ms\r\n```\r\n\r\n足足快了 30 多倍？\r\n\r\n真假？。。其实把上面两个 time 顺序颠倒也不是这么回事，但出自 rbuckton 大神之手应该不是随便写的\r\n\r\n所以以后遇到巨大 Object 的时候不妨用此方法优化一下试试。\r\n"},{"path":"/blog/reflect/reflect-metadata实现及其原理.md","title":"reflect-metadata实现及其原理","text":"最近研究了一下 reflect 机理，基本算是实现了所有的 api，也通过了全部的测试用例，所以想写一篇文章记录下来。\r\n\r\nps: 这篇文章最先发在我的知呼上：https://zhuanlan.zhihu.com/p/65239993\r\n\r\nReflect Metadata 是 ES7 的一个提案，它主要用来在声明的时候添加和读取元数据。Typescript 使用反射需要安装一个依赖 reflect-metadata.\r\n\r\nTypescript 拥有完整的面向对象支持，依赖注入技术(DI)已经在 Angular、Nest 等框架中大规模使用了，就像这样\r\n\r\n```typescript\r\nclass Service {}\r\n\r\nclass Controller {\r\n  constructor(private Service: Service) {}\r\n}\r\n```\r\n\r\nIOC 框架会获取到 Controller 所依赖的类，并注入一个实例或类本身，这其中获取依赖类型就会利用到 Reflect。\r\n\r\n利用元数据设计键(Design-time type annotations)来获取依赖类型\r\n\r\n```typescript\r\nfunction Injectable(): ClassDecorator {\r\n  return target => {\r\n    const metadata = Reflect.getMetadata(\"design:paramtypes\", target);\r\n    console.log(metadata);\r\n  };\r\n}\r\n\r\nclass Service {\r\n  constructor() {}\r\n}\r\n\r\n@Injectable() // 输出 [ Service() ]\r\nclass Controller {\r\n  constructor(private Service: Service) {}\r\n}\r\n```\r\n\r\n这里需要利用装饰器来获取。这里也许你会有疑问，元数据需要先 defineMetadata 然后在 getMetadata 获取，这里为什么可以直接获取?\r\n\r\n答案就是如果 tsconfig 开启了 emitDecoratorMetadata 为 true，编译器会发出设计元数据信息。\r\n\r\n来看下 ts 编译后的 js (已开启 emitDecoratorMetadata)\r\n\r\n```typescript\r\n// 判断一下Reflect上是否有metadata函数，并赋给__metadata\r\nvar __metadata =\r\n  (this && this.__metadata) ||\r\n  function(k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\r\n      return Reflect.metadata(k, v);\r\n  };\r\n\r\nvar Service = /** @class */ (function() {\r\n  function Service() {}\r\n  return Service;\r\n})();\r\n\r\nvar Controller = /** @class */ (function() {\r\n  function Controller(Service) {\r\n    this.Service = Service;\r\n  }\r\n  Controller = __decorate(\r\n    [\r\n      Injectable(),\r\n      // 注意这里，使用design-paramtypes键定义了元数据，值是[Service]\r\n      __metadata(\"design:paramtypes\", [Service])\r\n    ],\r\n    Controller\r\n  );\r\n  return Controller;\r\n})();\r\n\r\nfunction Injectable() {\r\n  return function(target) {\r\n    Reflect.getMetadata(\"design:paramtypes\", target);\r\n  };\r\n}\r\n```\r\n\r\n开启了 emitDecoratorMetadata 编译器会自动生成 Design-time type annotations。\r\n\r\n通过前面的实例，容易发现，Reflect 内部应该会维护一个 Map，而且应该是 WeakMap，\r\n\r\n果不其然，在 reflect-metadata 这个库内部使用了 WeakMap，而且居然还自带了 Polyfill(不仅实现 WeakMap，还有 HashMap...)\r\n\r\n[[Metadata]] internal slot\r\n\r\nhttps://github.com/rbuckton/reflect-metadata/blob/master/Reflect.ts#L685\r\n\r\nnaive WeakMap shim\r\n\r\nhttps://github.com/rbuckton/reflect-metadata/blob/master/Reflect.ts#L1725\r\n\r\n下面开始实现。\r\n\r\n实现 Reflect.defineMetadata\r\n\r\n首先创建一个 WeakMap，它将负责维护所有类和类实例的元数据，以及解决自动回收问题。\r\n\r\n```typescript\r\nconst Metadata = new WeakMap<Object, Map<PropertyKey, MetadataMap>>();\r\n```\r\n\r\n这是一个高维的 Map，对于每个 Object 也就是类或者类实例，它都关联一个 Map。这个 Map 里又关联了属性 key 和属性所对应的 Map，所以又是一个高维的 Map。所以这个 Metadata 就是一个 3 维的 Map。\r\n\r\n```typescript\r\nexport function defineMetadata(\r\n  metadataKey: MetadataKey,\r\n  metadataValue: MetadataValue,\r\n  target: Object,\r\n  propertyKey: PropertyKey = DEFAULTKAY\r\n) {\r\n  // 判断target类型，因为target将作为WeakMap的键，必须是对象类型\r\n  if (typeof target !== \"object\" && typeof target !== \"function\") {\r\n    throw new TypeError();\r\n  }\r\n\r\n  // 如果传入propertyKey，要求类型为string或symbol\r\n  if (propertyKey && ![\"string\", \"symbol\"].includes(typeof propertyKey)) {\r\n    throw new TypeError();\r\n  }\r\n\r\n  // 从Metadata中获取target关联的Map，若没有就创建一个新的Map\r\n  const targetMetadata =\r\n    Metadata.get(target) || new Map<PropertyKey, MetadataMap>();\r\n\r\n  // 将targetMetadata再保存回Metadata中\r\n  Metadata.set(target, targetMetadata);\r\n\r\n  // 从targetMetadata中获取propertyKey关联的Map，若没有就创建一个新的Map\r\n  const metadataMap: MetadataMap = targetMetadata.get(propertyKey) || new Map();\r\n\r\n  // 将metadataMap再保存回targetMetadata中\r\n  targetMetadata.set(propertyKey, metadataMap);\r\n\r\n  // 设置元数据到metadataMap，键为metadataKey，值metadataValue\r\n  metadataMap.set(metadataKey, metadataValue);\r\n}\r\n```\r\n\r\n实现 Reflect.getMetadata\r\n\r\n这个 api 会依赖 getMetadataMap、getOwnMetadataMap。所以先倒着来实现\r\n\r\n1. getOwnMetadataMap\r\n\r\n```typescript\r\nexport function getOwnMetadataMap(\r\n  target: Object,\r\n  propertyKey: PropertyKey = DEFAULTKAY\r\n) {\r\n  // 判断target类型，因为target将作为WeakMap的键，必须是对象类型\r\n  if (typeof target !== \"object\" && typeof target !== \"function\") {\r\n    throw new TypeError();\r\n  }\r\n\r\n  // 从Metadata中获取target关联的Map，如果没有就返回undefined\r\n  const targetMetadata = Metadata.get(target);\r\n  if (!targetMetadata) return;\r\n\r\n  // 从targetMetadata中获取propertyKey关联的Map，如果没有就返回undefined\r\n  const metadataMap = targetMetadata.get(propertyKey);\r\n  if (!metadataMap) return;\r\n\r\n  // 返回metadataMap\r\n  return metadataMap;\r\n}\r\n```\r\n\r\n2. getMetadataMap\r\n\r\n获取 target 及其原型上的元数据 Map，对于同一个 propertyKey，自身的 metadataMap 覆盖原型的 metadataMap\r\n\r\n```typescript\r\nexport function getMetadataMap(\r\n  target: Object,\r\n  propertyKey: PropertyKey = DEFAULTKAY\r\n) {\r\n  // 如果自身有了propertyKey对应的map\r\n  if (Boolean(getOwnMetadataMap(target, propertyKey))) {\r\n    return getOwnMetadataMap(target, propertyKey);\r\n  }\r\n\r\n  // 去原型上找propertyKey对应的map，如果没有就返回undefined\r\n  const targetMetadata = Metadata.get(Object.getPrototypeOf(target));\r\n  if (!targetMetadata) return;\r\n\r\n  // 从targetMetadata中获取propertyKey关联的Map，如果没有就返回undefined\r\n  const metadataMap = targetMetadata.get(propertyKey);\r\n  if (!metadataMap) return;\r\n\r\n  // 返回metadataMap\r\n  return metadataMap;\r\n}\r\n```\r\n\r\n实现 getMetadata\r\n\r\n利用 getMetadataMap 拿到 target 关联的 metadataMap，然后根据 metadataKey 获取对应的 metadataValue\r\n\r\n```typescript\r\nexport function getMetadata<T>(\r\n  metadataKey: MetadataKey,\r\n  target: Object,\r\n  propertyKey?: PropertyKey\r\n): T {\r\n  // 根据propertyKey获取target的metadataMap，如果没有就返回undefined\r\n  const metadataMap = getMetadataMap(target, propertyKey);\r\n  if (!metadataMap) return;\r\n\r\n  // 返回metadataKey对应的metadataValue\r\n  return metadataMap.get(metadataKey);\r\n}\r\n```\r\n\r\n同样的还有 getOwnMetadata，只需要考虑 getOwnMetadataMap 就可以了\r\n\r\n实现 Reflect.getMetadataKeys\r\n\r\n用来获取 target 身上的所有元数据键\r\n\r\n它会依赖 getOwnMetadataKeys，所以先实现 getOwnMetadataKeys\r\n\r\n实现 getOwnMetadataKeys\r\n\r\n获取 target 自身的所有元数据键\r\n\r\n```typescript\r\nexport function getOwnMetadataKeys(\r\n  target: Object,\r\n  propertyKey?: PropertyKey\r\n): MetadataKey[] {\r\n  // 获取target身上与propertyKey关联的metadataMap，若没有返回空数组\r\n  const metadataMap = getOwnMetadataMap(target, propertyKey);\r\n  if (!metadataMap) return [];\r\n\r\n  // metadataMap转为数组并返回\r\n  return Array.from(metadataMap.keys());\r\n}\r\n```\r\n\r\n实现 getMetadataKeys\r\n\r\n获取自身的 metadataKeys，获取原型的 metadataKeys，合并后返回\r\n\r\n```typescript\r\nexport function getMetadataKeys(\r\n  target: Object,\r\n  propertyKey?: PropertyKey\r\n): MetadataKey[] {\r\n  // 获取target自身与propertyKey关联的metadataKeys\r\n  const ownKeys = getOwnMetadataKeys(target, propertyKey);\r\n\r\n  // 获取target原型与propertyKey关联的metadataKeys\r\n  const protoKeys = getOwnMetadataKeys(\r\n    Object.getPrototypeOf(target),\r\n    propertyKey\r\n  );\r\n\r\n  // 返回结果\r\n  return [...ownKeys, ...protoKeys];\r\n}\r\n```\r\n\r\n实现 Reflect.hasMetadata\r\n\r\n用来判断 target 上是否有对应的 metadataKey\r\n\r\n注意是判断有无 key，而不是有无 value，所以不能等价 Boolean(getMetadata)，因为 metadataValue 可以是 null 和 undefined 等值。测试用例对这里做了大量的 test。\r\n\r\n```typescript\r\nexport function hasMetadata(\r\n  metadataKey: MetadataKey,\r\n  target: Object,\r\n  propertyKey?: PropertyKey\r\n) {\r\n  const metadataKeys = getMetadataKeys(target, propertyKey);\r\n  return metadataKeys.includes(metadataKey);\r\n}\r\n```\r\n\r\n这个很简单，没什么好说的\r\n\r\n同样还有 hasOwnMetadata，利用 getOwnMetadataKeys 就 ok\r\n\r\n实现 Reflect.deleteMetadata\r\n\r\n```typescript\r\nexport function deleteMetadata(\r\n  metadataKey: MetadataKey,\r\n  target: Object,\r\n  propertyKey?: PropertyKey\r\n) {\r\n  const metadataMap = getOwnMetadataMap(target, propertyKey);\r\n  if (!metadataMap) return false;\r\n\r\n  return metadataMap.delete(metadataKey);\r\n}\r\n```\r\n\r\n实现 Reflect.decorate\r\n\r\n这个可以从测试用例上获取思路\r\n\r\n```typescript\r\n// reflect-decorate.test.ts\r\n\r\nit(\"DecoratorCorrectTargetInPipelineForFunctionOverload\", () => {\r\n  let sent: Function[] = [];\r\n  let A = function A(): void {};\r\n  let B = function B(): void {};\r\n  let decorators = [\r\n    (target: Function): any => {\r\n      sent.push(target);\r\n      return undefined;\r\n    },\r\n    (target: Function): any => {\r\n      sent.push(target);\r\n      return undefined;\r\n    },\r\n    (target: Function): any => {\r\n      sent.push(target);\r\n      return A;\r\n    },\r\n    (target: Function): any => {\r\n      sent.push(target);\r\n      return B;\r\n    }\r\n  ];\r\n  let target = function(): void {};\r\n  Reflect.decorate(decorators, target);\r\n  expect(sent).toEqual([target, B, A, A]);\r\n});\r\n```\r\n\r\n测试中给出的 decorators 是 4 个箭头函数的数组，把 target 参数 push 到 sent 里，然后返回一个结果\r\n\r\n要求是 Reflect.decorate 执行后，sent 是[target, B, A, A]\r\n\r\n再结合测试用例的 name 分析，看到了管道(Pipeline)，那应该会想到 reduce 而且是 reduceRight。\r\n\r\ntarget 就是 initialValue，decorators 就是 reducers。\r\n\r\ndecorate\r\n\r\n有点类型 redux 的样子，target 就是 state，decorators 就是 reducers\r\n\r\n```typescript\r\nexport function decorate(\r\n  decorators: (PropertyDecorator | MethodDecorator)[],\r\n  target: Object | Function,\r\n  propertyKey?: string | symbol,\r\n  attributes?: PropertyDescriptor\r\n): PropertyDescriptor {\r\n  // 如果decorators是空数组则抛出TypeError\r\n  if (0 === decorators.length) {\r\n    throw new TypeError();\r\n  }\r\n\r\n  // target作为initialValue，遍历decorators，将上一个decorator的结果作为target传给下一个decorator\r\n  return decorators.reduceRight(\r\n    (target, decorator) => decorator(target, propertyKey, attributes) || target,\r\n    <any>target\r\n  );\r\n}\r\n```\r\n\r\n确定 Reflect 的 type 以及混入原生 Reflect\r\n\r\n为了避免类型冲突，首先需要给原生 Reflect 的 type 起个别名，就叫 IReflect 吧\r\n\r\n```typescript\r\nexport type IReflect = typeof Reflect;\r\nexport const reflect = Reflect;\r\n```\r\n\r\n然后混入 Reflector\r\n\r\n```typescript\r\nexport const Reflect: typeof Reflector & IReflect = Object.assign(\r\n  reflect,\r\n  Reflector\r\n);\r\n```\r\n\r\n因为原生 Reflect 对象的属性不可枚举，所以只能往原生 reflect 合并\r\n\r\nps: 之前我写的 IOC 框架依赖的 reflect-metadata 也换成了现在实现的这个版本，demo 也能跑起来，感觉还不错。\r\n\r\nSaber2pr/saber-ioc\r\n\r\nhttps://github.com/Saber2pr/saber-ioc\r\n\r\nGithub\r\n\r\n@saber2pr/reflect\r\n\r\nhttps://github.com/Saber2pr/-saber2pr-reflect\r\n"},{"path":"/blog/reflect/依赖注入(IOC)实现.md","title":"依赖注入(IOC)实现","text":"## 实现 reflect-metadata\r\n\r\n1. 首先说明要干什么。\r\n   实现一个存放类的容器，并能按照类之间依赖关系自动构建实例。\r\n\r\n2. 核心原理：\r\n\r\n利用 Reflect-metadata 获取构造函数中的参数类型(design:paramtypes)。\r\n利用 Reflect-metadata 在目标对象上定义和获取元数据。\r\n\r\n先举个例子：\r\n\r\n```typescript\r\nclass Service {\r\n  constructor() {}\r\n}\r\n\r\nclass Controller {\r\n  constructor(private Service: Service) {}\r\n}\r\n```\r\n\r\n一个 Service 类，一个 Controller 类，其中 Controller 类依赖于 Service 类。\r\n\r\n利用 Reflect 可以轻松获取 Controller 类构造函数中的 paramtypes。\r\n\r\n## 实现@Injectable\r\n\r\n> Injectable 函数返回一个类装饰器，利用反射获取被装饰类的构造函数的参数类型。\r\n\r\n先举个栗子\r\n\r\n```typescript\r\nconst enum DESIGN {\r\n  PARAMTYPES = \"design:paramtypes\"\r\n}\r\n\r\nfunction Injectable(): ClassDecorator {\r\n  return target => {\r\n    // 获取被装饰类的构造函数的参数类型\r\n    const ctorParams: any[] = Reflect.getMetadata(DESIGN.PARAMTYPES, target);\r\n    console.log(ctorParams);\r\n  };\r\n}\r\n```\r\n\r\n利用设计键获取到参数列表：\r\n\r\n```typescript\r\nclass Service {\r\n  constructor() {}\r\n}\r\n\r\n@Injectable() // Array [ Service() ]\r\nclass Controller {\r\n  constructor(private Service: Service) {}\r\n}\r\n```\r\n\r\n## @Injectable\r\n\r\n```typescript\r\nexport function Injectable(id?: PropertyKey): ClassDecorator {\r\n  return target => {\r\n    // 索引键值默认为target.name\r\n    const token = id || target.name;\r\n\r\n    // 如果token已存在则抛出Error\r\n    if (Reflect.hasMetadata(token, MetaStore)) {\r\n      throw new Error(`id:[${String(token)}] is existed!`);\r\n    } else {\r\n      Reflect.defineMetadata(token, target, MetaStore);\r\n    }\r\n  };\r\n}\r\n```\r\n\r\n> Injectable 提供了可选项 id?，用来避免命名冲突。\r\n\r\n这样只要被 Injectable()装饰过的类都会被缓存到 MetaStore 中。\r\n\r\n## @Inject\r\n\r\n> 构造函数参数注入。读写 target 身上的元数据，用于注入依赖信息。\r\n\r\n```typescript\r\n// target身上的元数据类型(参数注入)\r\nexport type ParamMeta = Array<[PropertyKey, number]>;\r\n\r\nexport function Inject(id: PropertyKey): ParameterDecorator {\r\n  return (target, _, index) => {\r\n    // 获取到target身上的ParamMeta，如果没有就创建一个新的\r\n    const depMeta =\r\n      Reflect.getMetadata<ParamMeta>(CUSTOM.META_PARAM, target) || [];\r\n\r\n    // push一个ParamMeta，id和index\r\n    depMeta.push([id, index]);\r\n\r\n    // 再把ParamMeta保存回target\r\n    Reflect.defineMetadata(CUSTOM.META, depMeta, target);\r\n  };\r\n}\r\n```\r\n\r\n> index 即参数在函数(构造函数)arguments 数组中的下标，id 为 Injectable-token\r\n\r\n例如：\r\n\r\n```typescript\r\n@Injectable() // 缓存到MetaStore, id: 'Service'.\r\nclass Service {}\r\n\r\ninterface IService {}\r\n\r\nclass Controller {\r\n  // inject注解，请求依赖为id: 'Service', 位置为index: 0\r\n  constructor(@Inject(\"Service\") private Service: IService) {}\r\n}\r\n```\r\n\r\n## @InjectProp\r\n\r\n> 成员属性注入。读写 target 身上的元数据，用于注入依赖信息。\r\n\r\n```typescript\r\n// target身上的元数据类型(成员属性注入)\r\nexport type PropMeta = Array<[PropertyKey, PropertyKey]>;\r\n\r\nexport function InjectProp(id?: PropertyKey): PropertyDecorator {\r\n  return (target, key) => {\r\n    // 请求的依赖token，默认为成员属性名key\r\n    const token = id || key;\r\n\r\n    // 获取到target身上的PropMeta，如果没有就创建一个新的\r\n    const depMeta =\r\n      Reflect.getMetadata<PropMeta>(CUSTOM.META_PROP, target) || [];\r\n\r\n    // push一个PropMeta，id和index\r\n    depMeta.push([token, key]);\r\n\r\n    // 再把ParamMeta保存回target\r\n    Reflect.defineMetadata(CUSTOM.META_PROP, depMeta, target);\r\n  };\r\n}\r\n```\r\n\r\n例如：\r\n\r\n```typescript\r\n@Injectable() // 缓存到MetaStore, id: 'Service'.\r\nclass Service {}\r\n\r\ninterface IService {}\r\n\r\nclass Controller {\r\n  // inject注解，请求依赖为id: 'Service', 属性名为'Service'\r\n  @InjectProp() private Service: IService;\r\n}\r\n```\r\n\r\n## 实现 Injector 函数（核心）\r\n\r\n> 从入口开始构建整个依赖树，并生成根实例\r\n> 这里需要利用 AOP 思想，在 Target 生成实例前后做切面\r\n\r\n```typescript\r\ntype Constructor<T = any> = { new (...args: Array<any>): T };\r\n\r\nexport function Injector<T>(Target: Constructor<T>): T | Constructor<T> {\r\n  // 如果是静态类，直接返回\r\n  if (Reflect.hasMetadata(CUSTOM.STATIC, Target)) return Target;\r\n\r\n  // before 拿到ParamMeta实例数组\r\n  const instances = before(Target);\r\n\r\n  // 注入ParamMeta实例数组，生成Target实例\r\n  const target = new Target(...instances);\r\n\r\n  // after 进行PropMeta依赖注入\r\n  after(target);\r\n\r\n  return target;\r\n}\r\n```\r\n\r\n## before\r\n\r\n> 通过 Target 获取元数据信息(ParamMeta)，返回处理好的依赖项实例数组\r\n\r\n```typescript\r\nfunction before<T>(Target: Constructor<T>) {\r\n  // 获取设计元数据，也就是构造函数参数中的依赖项\r\n  const deps =\r\n    Reflect.getMetadata<Array<Constructor>>(DESIGN.PARAMTYPES, Target) || [];\r\n\r\n  // 获取Injected tags\r\n  const tags = Reflect.getMetadata<ParamMeta>(CUSTOM.META_PARAM, Target) || [];\r\n\r\n  // 遍历每一个tag\r\n  tags.forEach(([id, index]) => {\r\n    // 如果MetaStore中已注册\r\n    if (Reflect.hasMetadata(id, MetaStore)) {\r\n      // 找到MetaStore中id对应的metadata，按index插入deps\r\n      deps[index] = Reflect.getMetadata(id, MetaStore);\r\n    } else {\r\n      // 若没找到，则抛出异常\r\n      throw new Error(`injected dep:${String(id)} not found`);\r\n    }\r\n  });\r\n\r\n  // 对每一个ParamMeta依赖进行Injector依赖注入，得到实例数组并返回\r\n  return deps.map(Injector);\r\n}\r\n```\r\n\r\n## after\r\n\r\n> 通过 Target 实例获取元数据信息(PropMeta)，将处理好的依赖项定义到 Target 实例上\r\n\r\n```typescript\r\nfunction after<T>(target: T) {\r\n  // 获取PropMeta，也就是成员属性名关联的元数据\r\n  const props = Reflect.getMetadata<PropMeta>(CUSTOM.META_PROP, target) || [];\r\n\r\n  // 遍历每一个PropMeta元素\r\n  props.forEach(([id, key]) => {\r\n    // 如果MetaStore中已注册\r\n    if (Reflect.hasMetadata(id, MetaStore)) {\r\n      // 在MetaStore中找到对应metadata，也就是PropertyKey对应的依赖\r\n      const dep = Reflect.getMetadata<Constructor>(id, MetaStore);\r\n      // 对依赖进行依赖注入，得到依赖实例\r\n      const instance = Injector(dep);\r\n\r\n      // 将依赖实例作为属性定义到target上\r\n      Object.defineProperty(target, key, { value: instance });\r\n    } else {\r\n      // 若没找到，则抛出异常\r\n      throw new Error(`injected dep:${String(id)} not found`);\r\n    }\r\n  });\r\n}\r\n```\r\n\r\nDemo\r\n\r\n```typescript\r\n@Injectable()\r\nclass Service {\r\n  public getUser() {\r\n    return \"saber!\";\r\n  }\r\n}\r\n\r\nclass Controller {\r\n  public constructor(@Inject(\"Service\") private Service: Service) {}\r\n\r\n  // @InjectProp() private Service: Service\r\n\r\n  public test() {\r\n    console.log(this.Service.getUser());\r\n  }\r\n}\r\n\r\nconst app = Injector(Controller);\r\n\r\napp.test(); // 'saber!\r\n```\r\n"},{"path":"/blog/reflect/实现一个基于IOC的HttpServer框架","title":"实现一个基于IOC的HttpServer框架","children":[{"path":"/blog/reflect/实现一个基于IOC的HttpServer框架/实现一个基于IOC的HttpServer框架(上).md","title":"实现一个基于IOC的HttpServer框架(上)","text":"总体思路：\r\n\r\n1. Controller 用来组织元数据\r\n2. parse 方法将 Controller 中的 metadata 提取出来，得到 Controller-Metadata-Node\r\n3. transform 方法将 Controller-Metadata-Node 转为 requestListeners\r\n\r\n利用 Class 来组织元数据，利用装饰器和 Reflect 注入元数据信息\r\n\r\n```typescript\r\n@Controller(\"/user\") // 注入 baseUrl: '/user'\r\nclass UserController {\r\n  @Post(\"/register\") // 注入 POST: '/register'\r\n  public register() {}\r\n\r\n  @Get(\"/login\") // 注入 GET: '/login'\r\n  public login() {}\r\n}\r\n```\r\n\r\n> 现在利用 Reflect 来实现装饰器 Controller、Get、Post\r\n\r\n## 在此之前需要定义 constants\r\n\r\n> 因为 Reflect 需要 metadataKey 来索引 metadata\r\n\r\n```typescript\r\nexport namespace KEY {\r\n  export const enum Controller {\r\n    BaseUrl = \"controller:baseUrl\",\r\n    GET = \"method:get\",\r\n    POST = \"method:post\"\r\n  }\r\n}\r\n```\r\n\r\n## 实现装饰器部分\r\n\r\n### 1. @Controller\r\n\r\n> 用来注入 baseUrl 元数据\r\n\r\n```typescript\r\nexport function Controller(path?: string): ClassDecorator {\r\n  return target =>\r\n    Reflector.defineMetadata(KEY.Controller.BaseUrl, path, target);\r\n}\r\n```\r\n\r\n### + DecoratorFactory\r\n\r\n> @Post 和@Get 相似代码太多，抽离一个 Factory 方法\r\n> 输入 Method type 和路由 path，返回一个 MethodDecorator\r\n\r\n```typescript\r\nexport function DecoratorFactory(\r\n  type: KEY.Controller,\r\n  path: string\r\n): MethodDecorator {\r\n  return (target, key) => Reflector.defineMetadata(type, path, target, key);\r\n}\r\n```\r\n\r\n### 2. @Post、@Get\r\n\r\n> 用来注入 method 类型、路由 path、对应的响应方法名(propertyKey)\r\n\r\n```typescript\r\nexport function Get(path?: string): MethodDecorator {\r\n  return DecoratorFactory(KEY.Controller.GET, path);\r\n}\r\n\r\nexport function Post(path?: string): MethodDecorator {\r\n  return DecoratorFactory(KEY.Controller.POST, path);\r\n}\r\n```\r\n\r\n利用上述装饰器可以将 requestListener 需要的 path、method、callbackName 等信息定义在 Controller 上\r\n\r\n### parse\r\n\r\n> 解决如何提取出 Controller 中的 metadata 及其转化为 Controller-Metadata-Node\r\n\r\n首先明确，输入和输入的 type\r\n\r\n输入一个 Class，返回一个 Controller-Metadata-Node\r\n\r\n```typescript\r\n// 伪代码\r\nfunction parse(Controller: { new (): any }): Controller-Metadata-Node\r\n```\r\n\r\n定义 type\r\n\r\n```typescript\r\n// GET和POST还有别的method懒得写了\r\nexport type Method = \"GET\" | \"POST\";\r\n\r\n// 路由\r\nexport type Routes = Array<{\r\n  method: Method;\r\n  path: string;\r\n  callback: Function;\r\n}>;\r\n\r\n// Controller-Metadata-Node\r\nexport interface Controller {\r\n  baseUrl: string;\r\n  routes: Routes;\r\n}\r\n```\r\n\r\n实现 parse\r\n\r\n```typescript\r\n// parse函数实现\r\n// 输入一个Class类型，输出Controller-Metadata-Node\r\nexport function parse(Controller: { new (): any }): Controller {\r\n  // 提取baseUrl\r\n  const baseUrl = Reflector.getMetadata<string>(\r\n    KEY.Controller.BaseUrl,\r\n    Controller\r\n  );\r\n  // 实例化\r\n  const target = new Controller();\r\n  // 获取实例的所有方法callbackNames\r\n  const methods = Object.keys(Object.getPrototypeOf(target));\r\n\r\n  // 遍历所有callbackNames\r\n  // 匹配对应的method并输出\r\n  const routes = methods.reduce((receiver, key) => {\r\n    resolve(target, key, \"GET\", receiver);\r\n    resolve(target, key, \"POST\", receiver);\r\n    return receiver;\r\n  }, []);\r\n\r\n  // 返回Controller-Metadata-Node\r\n  return {\r\n    baseUrl,\r\n    routes\r\n  };\r\n}\r\n```\r\n\r\n说一下 resolve 函数做了什么\r\n\r\n### + resolve\r\n\r\n> reduce 的辅助函数，用于匹配 method 与 metadata\r\n\r\n```typescript\r\nexport function resolve(\r\n  target: Object,\r\n  key: string,\r\n  method: Method,\r\n  receiver: Routes\r\n) {\r\n  // 获取target.key上methodKey对应的metadata\r\n  const path = Reflector.getMetadata<string>(\r\n    mapMethodToKey(method),\r\n    target,\r\n    key\r\n  );\r\n  // 如果method对应的path存在，则往receiver中push一个route\r\n  if (path) receiver.push({ method, path, callback: target[pathToProp(path)] });\r\n}\r\n```\r\n\r\n这里需要实现两个 util 函数\r\n\r\n### + mapMethodToKey 、pathToProp\r\n\r\n> mapMethodToKey 用来进行 Pattern matching\r\n> pathToProp 用来处理 path 的前缀\r\n\r\n```typescript\r\nexport function mapMethodToKey(method: Method): KEY.Controller {\r\n  switch (method) {\r\n    case \"GET\":\r\n      return KEY.Controller.GET;\r\n    case \"POST\":\r\n      return KEY.Controller.POST;\r\n    default:\r\n      throw new TypeError();\r\n  }\r\n}\r\n\r\nexport function pathToProp(path: string) {\r\n  if (path.startsWith(\"/\")) {\r\n    return path.slice(1);\r\n  }\r\n  return path;\r\n}\r\n```\r\n\r\ntransform\r\n\r\n> 将 Controller-Metadata-Node 转为 requestListeners（Units）\r\n\r\n首先明确，输入和输入的 type\r\n\r\n输入一个 Controller-Metadata-Node 返回 Units\r\n\r\n```typescript\r\n// requestListener需要的信息\r\nexport interface Unit {\r\n  url: string;\r\n  callback: Function;\r\n  method: string;\r\n}\r\n\r\n// 实现transform\r\nexport function transform(controller: Controller): Unit[] {\r\n  return controller.routes.map<Unit>(({ path, callback, method }) => ({\r\n    url: controller.baseUrl + path,\r\n    callback,\r\n    method\r\n  }));\r\n}\r\n```\r\n\r\n> transform 这一步做的有点少，其实应该直接转为 requestListeners\r\n\r\n### + mapUnitToJob\r\n\r\n> 用来把 transform 得到的 units 转为 requestListeners\r\n\r\n这里用的是 Koa 所以：\r\n\r\n```typescript\r\n// 得到requestListeners序列\r\nexport function mapUnitToJob(units: Unit[]): Job<Context>[] {\r\n  return units.map<Job>(unit => async (ctx, next) => {\r\n    const { url, method } = ctx.request;\r\n    if (url === unit.url && method === unit.method) {\r\n      // 混入ctx\r\n      await unit.callback.apply(\r\n        Object.assign(unit.origin, { ContextService: ctx })\r\n      );\r\n    } else {\r\n      await next();\r\n    }\r\n  });\r\n}\r\n```\r\n\r\n利用 Koa-compose 就可以组合 requestListeners 序列\r\n\r\n### + ContextService\r\n\r\n```typescript\r\n@Injectable()\r\nexport class ContextService {\r\n  public request: Context[\"request\"];\r\n  public response: Context[\"response\"];\r\n}\r\n```\r\n\r\n只要注入 ContextService 就可以获取 koa-context 信息\r\n\r\n例如\r\n\r\n```typescript\r\n@Controller(\"/user\")\r\nclass UserController {\r\n  constructor(private ContextService: ContextService) {}\r\n\r\n  @Get(\"/login\")\r\n  public login() {\r\n    this.ContextService.response.end(\"login\");\r\n  }\r\n\r\n  @Get(\"/hello\")\r\n  public hello() {\r\n    this.ContextService.response.end(\"hello\");\r\n  }\r\n}\r\n```\r\n\r\n现在有了定义 metadata 的 decorators、parser 和 transformer\r\n\r\n最后需要的就是一个 Factory 类，将这几个过程有序组织起来\r\n\r\n### Factory\r\n\r\n```typescript\r\nexport class Factory {\r\n  public constructor(private modules: Array<{ new (): any }>) {\r\n    // 将classes转为units\r\n    this.units = [].concat(...this.modules.map(mod => transform(parse(mod))));\r\n  }\r\n  public instance: KoaBody;\r\n  private units: Unit[];\r\n  public create() {\r\n    // 将units转为requestListeners，实例化一个koa-app，koa.use...\r\n    this.instance = Koa().use(compose(...mapUnitToJob(this.units)));\r\n    // 返回koa实例\r\n    return this.instance;\r\n  }\r\n}\r\n```\r\n\r\ndemo\r\n\r\n```typescript\r\n@Controller(\"/user\")\r\nclass UserController {\r\n  constructor(private ContextService: ContextService) {}\r\n\r\n  @Get(\"/login\")\r\n  public login() {\r\n    this.ContextService.response.end(\"login\");\r\n  }\r\n\r\n  @Get(\"/hello\")\r\n  public hello() {\r\n    this.ContextService.response.end(\"hello\");\r\n  }\r\n}\r\n\r\nnew Factory([UserController])\r\n  .create()\r\n  .listen(3001, () => console.log(\"http://localhost:3001\"));\r\n```\r\n\r\n> 现在只是实现了从 Controllers 到 requestListeners，关于 Service 注入在下一篇文章分享。\r\n"},{"path":"/blog/reflect/实现一个基于IOC的HttpServer框架/实现一个基于IOC的HttpServer框架(下).md","title":"实现一个基于IOC的HttpServer框架(下)","text":"上一篇文章实现了从 Controllers 到 requestListeners 的转化，下面需要解决的问题是当 Controller 使用了 IOC 容器来注入 Service 时怎么 parse 以及思路。\r\n\r\n以每个 Controller 为一个根节点构建它的实例，parser 从实例中解析出 baseUrl 和 routes\r\n\r\n之前我写的 IOC 容器被我重构了 qwq，API 现在是 Inject、Injectable、Injector.\r\n\r\n> 1. Inject 负责添加依赖信息\r\n> 2. Injectable 用来注册和缓存 constructors\r\n> 3. Injector 用来构建根实例\r\n\r\n所以需要在 parse 方法中使用 Injector 对 Controller 进行依赖注入\r\n\r\n```typescript\r\nexport function parse(Controller: { new (): any }): Controller {\r\n  const baseUrl = Reflector.getMetadata<string>(\r\n    KEY.Controller.BaseUrl,\r\n    Controller\r\n  );\r\n\r\n  // Injector将Controller需要的依赖注入其中，返回它的一个实例\r\n  const target = Injector(Controller);\r\n  const methods = Object.keys(Object.getPrototypeOf(target));\r\n\r\n  const routes = methods.reduce((receiver, key) => {\r\n    resolve(target, key, \"GET\", receiver);\r\n    resolve(target, key, \"POST\", receiver);\r\n    resolve(target, key, \"DELETE\", receiver);\r\n    resolve(target, key, \"PUT\", receiver);\r\n    return receiver;\r\n  }, []);\r\n\r\n  return {\r\n    baseUrl,\r\n    routes\r\n  };\r\n}\r\n```\r\n\r\n> emmm，这就搞定了。原来是 new Controller，现在是 Injector(Controller)\r\n\r\nDemo\r\n\r\n```typescript\r\n@Injectable()\r\nclass UserService {\r\n  public getUserName() {\r\n    return \"saber2pr!\";\r\n  }\r\n\r\n  public getHello() {\r\n    return \"Hello!\";\r\n  }\r\n}\r\n\r\n@Controller(\"/user\")\r\nclass UserController {\r\n  constructor(\r\n    private ContextService: ContextService,\r\n    @Inject(\"UserService\") private UserService: UserService\r\n  ) {}\r\n\r\n  @Get(\"/login\")\r\n  public login() {\r\n    this.ContextService.response.end(this.UserService.getUserName());\r\n  }\r\n\r\n  @Get(\"/hello\")\r\n  public hello() {\r\n    this.ContextService.response.end(this.UserService.getHello());\r\n  }\r\n}\r\n\r\nnew Factory([UserController])\r\n  .create()\r\n  .listen(3001, () => console.log(\"http://localhost:3001\"));\r\n// http://localhost:3001/user/login\r\n// http://localhost:3001/user/hello\r\n```\r\n\r\n> 关于 saber-ioc 现在已重构为@saber2pr/ioc\r\n> 之前写的文章也做了更新，主要是简化了大部分代码\r\n\r\n(最后瞎扯一句) 关于 OOP 的依赖注入和函数式的 compose 一直是个争论的问题，到底哪种方式更好谁也说不清(\r\n"}]}]},{"path":"/blog/saber2prの窝.md","title":"saber2prの窝","text":"你说既视感？\r\n\r\n错觉！\r\n\r\n为什么会有这个 Page？\r\n\r\n大概我想记录自己的心得但穷于购买 server service。\r\n\r\n为什么要搞一些闪瞎眼的 Animation？？\r\n\r\n如果没有过渡你可能想马上关掉这个呆掉的 Page。\r\n\r\n这个 page 上面大概有些什么值得我看的东西？\r\n\r\n如果你对二刺猿感兴趣我建议你点击`链接`->`bilibili`离开这里。\r\n"},{"path":"/blog/test","title":"test","children":[{"path":"/blog/test/来测试一下？.md","title":"来测试一下？","text":"### Web 前端基础知识 100 问\r\n\r\n1. React 生命周期\r\n2. webpack 原理\r\n3. css 清除浮动\r\n4. css 左右定宽中间自适应\r\n5. 事件代理\r\n6. 闭包\r\n7. 继承方法有哪些，各有什么优势\r\n8. 选择排序，各排序复杂度\r\n9. xss csrf\r\n10. 前端性能优化\r\n11. http 缓存机制\r\n12. 个人长处和短处\r\n13. css 选择器优先级\r\n14. html 语义化\r\n15. 块级和行内有哪些\r\n16. display 值有哪些各什么特点\r\n17. box sizing 值有哪些\r\n18. 怎么判断数据类型，instanceof\r\n19. 阻止冒泡，阻止默认行为\r\n20. http header 内容\r\n21. 垃圾回收机制\r\n22. 两个页面通信\r\n23. 介绍 less\r\n24. 原型链和原型\r\n25. 说说 rollup\r\n26. vue 数据双向绑定\r\n27. redux 和 react redux\r\n28. 几种 http 状态码\r\n29. 跨域方式\r\n30. 几种 css 伪类\r\n31. css 常见布局\r\n32. 伪数组\r\n33. 移动端了解\r\n34. html5 新特性\r\n35. url 到渲染一系列\r\n36. 常用的图片格式\r\n37. new 原理\r\n38. 静态变量怎么实现\r\n39. 左栏定宽右栏自适应\r\n40. 反转链表\r\n41. css position 各种特点\r\n42. amd 和 cmd 理解\r\n43. 实现一个观察者模式\r\n44. 生成器用法\r\n45. es6 继承和 es5 不同\r\n46. 宏任务和微任务知道么\r\n47. 虚拟 dom 原理\r\n48. 双向绑定怎么实现\r\n49. css 动画怎么实现\r\n50. react redux 的 connect 函数做了什么，它怎么传的 store\r\n51. 怎么判断一个空对象\r\n52. Object 常用方法\r\n53. websocket 原理\r\n54. tcp 三次握手四次挥手\r\n55. React state 更新机制\r\n56. React fiber 机制\r\n57. 纯 css 开关按钮\r\n58. 原生 ajax\r\n59. 最得意的 github 项目\r\n60. restful 接口\r\n61. 受控组件和非受控组件\r\n62. css 旋转三角形\r\n63. js 正则判断手机号\r\n64. react 是哪种架构\r\n65. flex 属性都说下\r\n66. 原型链对象构造函数之间关系\r\n67. dom2 dom3 标准\r\n68. dom 事件绑定几种方式\r\n69. 项目中用到的技术栈，遇到头疼点，怎么解决 https 和 http 区别是什么\r\n70. webpack 多入口怎么配置，怎么分割\r\n71. 按需加载实践过吗\r\n72. 协商缓存和强制缓存\r\n73. dom 事件里 target 和 currentTarget 区别\r\n74. react context 的理解\r\n75. margin 重叠\r\n76. passive event\r\n77. 浮动原理\r\n78. js 基本类型和复杂类型\r\n79. 闭包 iife 里的 this\r\n80. 浏览器并行下载数量\r\n81. 图片资源异步加载\r\n82. jwt 优缺点\r\n83. redux 解决了什么\r\n84. 回调函数 promise async 区别\r\n85. setState 之后的生命周期\r\n86. xss 怎么防范，完成一次 csrf 攻击步骤\r\n87. css3 圆形头像\r\n88. seo\r\n89. ifc 和 bfc\r\n90. 双飞翼和圣杯\r\n91. 水平垂直居中 4 个以上并各有什么限制\r\n92. web worker 和 websocket 用途\r\n93. h5 新增的语义化标签\r\n94. css 优先级和权重\r\n95. css 实现响应式\r\n96. addEventListener 和 onclick 有什么区别\r\n97. 说几个 es6 特性\r\n98. new 和 Object.create 区别\r\n99. BOM 和 DOM 基础方法例如取 url port origin 协议\r\n100. 前端路由原理\r\n101. 后端能否收到 hash 部分\r\n102. 怎么触发回流重绘怎么避免\r\n103. call bind apply 怎么实现\r\n104. 怎么实现继承\r\n105. get 和 post 区别\r\n106. 深浅拷贝，序列化\r\n107. 实现 promise\r\n108. 闭包特性用途缺点\r\n109. let const var 声明提升是什么\r\n110. 生成器迭代器\r\n111. symbol 理解\r\n112. Set 数据结构\r\n113. 解构\r\n114. commonjs 和 es6 模块有什么区别\r\n115. 动态路由\r\n116. js 并发模型\r\n117. js 的 iterator 和 iteratable 是什么，有哪些内置的 iterator\r\n118. css 会阻塞 dom 树渲染和解析么\r\n119. autocomplete 输入框实现\r\n120. restful 常用接口有哪些，各有什么特点\r\n121. 浏览器后退重复 post 怎么解决\r\n122. raf 和 ric 区别\r\n123. html 语义化理解\r\n124. html5 之前有语义化的标签\r\n125. ul ol dl 三种列表标签的适用场景\r\n126. cookie localStorage sessionStorage 三者区别和应用场景\r\n127. jwt 理解\r\n128. 分片上传\r\n129. fetch 和 ajax 区别是什么\r\n130. 浏览器打开一个页面前端缓存了哪些东西\r\n131. 快速排序有几种\r\n132. 新的事件流和老的事件流\r\n133. css will-change 作用\r\n134. dns 是哪一层协议\r\n135. webassembly 知道么\r\n136. options 除了返回 200 响应还有什么办法\r\n137. 怎么判断两个矩形相交\r\n"}]},{"path":"/blog/typescript","title":"typescript","children":[{"path":"/blog/typescript/对比Monad在TS和Haskell中的使用.md","title":"对比Monad在TS和Haskell中的使用","text":"因为在 TS 中没有关于 Monad 的类型，所以先实现基础设施。\r\n\r\n> 只做简单实现，重点在于与 haskell 代码风格比较。\r\n> 目的：加深对 Monad 的理解。\r\n\r\n## Monad\r\n\r\nMonad 中保存了一个值(惰性)。所以可以这样定义它\r\n\r\n```typescript\r\ntype Monad<T> = {\r\n  readonly _wrapped_: () => T;\r\n};\r\n```\r\n\r\nwrapped 就是一个值包装器，将一个值惰性化。\r\n\r\n> 意义: 用来保存值上下文，串联对值的一系列操作\r\n> 处于相对于普通值类型的上层\r\n> 在 haskell 中 Monad 为一个类型类\r\n\r\n## return\r\n\r\n也就是 pure。将一个值提升到 Monad。\r\n\r\n```typescript\r\ntype pure = <T>(a: T) => Monad<T>;\r\nconst pure: <T>(a: T) => Monad<T> = value => ({\r\n  _wrapped_: () => Object.freeze(value)\r\n});\r\n```\r\n\r\n> 意义: 将一个值惰性化\r\n\r\n## join\r\n\r\n将一个 Monad 解包，然后应用一个提升函数，返回新的 Monad。\r\n\r\n```typescript\r\ntype join = <A, B>(m: Monad<A>, f: (a: A) => Monad<B>) => Monad<B>;\r\nconst join: <A, B>(m: Monad<A>, f: (a: A) => Monad<B>) => Monad<B> = (m, f) =>\r\n  f(m._wrapped_());\r\n```\r\n\r\n> 意义：join 的返回值为 Monad 类型，接受一个 Monad 映射到的还是 Monad，即自函子。\r\n> 提供对 Monad 类型实例的解包。\r\n\r\n## liftA\r\n\r\n将一个 Monad 解包，然后应用一个非提升函数，返回新的 Monad。\r\n\r\n```typescript\r\ntype liftA = <A, B>(m: Monad<A>, f: (a: A) => B) => Monad<B>;\r\nconst liftA: <A, B>(m: Monad<A>, f: (a: A) => B) => Monad<B> = (m, f) =>\r\n  pure(f(m._wrapped_()));\r\n```\r\n\r\n> 将一个函数 lift 进 Monad 中\r\n\r\n## fmap\r\n\r\n和 lift 用法一样，是 Functor 类型类的方法。\r\n\r\n## compose\r\n\r\n一个二元运算\r\n\r\n```typescript\r\nconst compose: <A, R1, R2>(\r\n  f2: (a: R1) => R2,\r\n  f1: (a: A) => R1\r\n) => (a: A) => R2 = (f2, f1) => a => f2(f1(a));\r\n```\r\n\r\n# 与 Haskell Monad 比较\r\n\r\n1. 首先创建一个 Monad。\r\n\r\nin haskell\r\n\r\n```haskell\r\nasync_init :: Monad m => m Integer\r\nasync_init = pure 1\r\n```\r\n\r\nin typescript\r\n\r\n```typescript\r\ntype async_init = Monad<number>;\r\nconst async_init: Monad<number> = pure(1);\r\n```\r\n\r\n2. 使用 join 对 Monad 下层值进行(+1)操作\r\n\r\nin haskell\r\n\r\n```haskell\r\nasync_join_add :: Monad m => m Integer -> m Integer\r\nasync_join_add m = m >>= \\a -> pure $ a + 1\r\n```\r\n\r\nin typescript\r\n\r\n```typescript\r\ntype async_join_add = (m: Monad<number>) => Monad<number>;\r\nconst async_join_add: (m: Monad<number>) => Monad<number> = m =>\r\n  join(m, a => pure(a + 1));\r\n```\r\n\r\n3. 使用 lift 将(+1)函数应用到 Monad\r\n\r\nin haskell\r\n\r\n```haskell\r\nasync_lift_add :: Monad m => m Integer -> m Integer\r\nasync_lift_add m = liftA (\\a -> a + 1) m\r\n```\r\n\r\nin typescript\r\n\r\n```typescript\r\ntype async_lift_add = (m: Monad<number>) => Monad<number>;\r\nconst async_lift_add: (m: Monad<number>) => Monad<number> = m =>\r\n  liftA(m, a => a + 1);\r\n```\r\n\r\n4. fmap 和 lift 用法一样，这里不写了\r\n\r\n5. main 函数\r\n\r\nin haskell\r\n\r\n```haskell\r\nmain :: IO ()\r\nmain = do\r\n  -- a <- async_fmap_add $ async_lift_add $ async_join_add async_init\r\n  a <- async_fmap_add . async_lift_add . async_join_add $ async_init\r\n  print a\r\n```\r\n\r\nin typescript\r\n\r\n```typescript\r\nfunction main() {\r\n  // const a = async_fmap_add(\r\n  //   async_lift_add(async_join_add(async_init()))\r\n  // )._wrapped_();\r\n\r\n  const a = compose(\r\n    async_fmap_add,\r\n    compose(\r\n      async_lift_add,\r\n      async_join_add\r\n    )\r\n  )(async_init)._wrapped_();\r\n\r\n  return pure(() => console.log(a));\r\n}\r\n\r\nmain()._wrapped_()();\r\n```\r\n\r\n# 关于 Promise 和 async\r\n\r\nPromise 就是 Monad，Promise.resolve 就是 pure，Promise.then 就是>>=。\r\n\r\nasync 就是 do block，await 就是 <- ，return 意义一样。\r\n"}]},{"path":"/blog/关于本博客.md","title":"关于本博客","text":"如果你看过它的源码，你可能会感到惊讶。除了 react 和 react-dom 之外，相当多的依赖都在@saber2pr 命名下。\r\n\r\n> 包括 router、redux 库，audio 媒体组件、markdown 组件、tree 树形选择器组件等。\r\n\r\n我建立这个博客的初衷并不仅仅是记录自己学习经验，更多的是想要替换社区现有的开源库(在我的项目中)。\r\n\r\n我不仅仅是担心有一天它们会闭源(我说假如)，更多的问题是，在使用 bundler 打包后的体积惊人的大。我认为仅仅是实现路由和状态管理并不需要很多的代码。我想要一个轻量的版本。实现它们对我来说并不难。(有点 js 基础就可以实现)\r\n\r\nrouter 和 redux 它们本身并不与 react 耦合在一起。一个基于 BOM，一个是思想。\r\n\r\n我甚至企图替换掉最底层的 react 库。(为此我花了一些时间实现了 react-like，但是仍然不能彻底兼容 react 的行为。)\r\n\r\n为什么不使用 Hexo，或者是 Gatsby 等构建工具？\r\n\r\n我现在有充足的时间来做一个更独特更精彩的版本。同样我也是基于 markdown。我可以很容易的添加扩展，因为所有代码都是我写的。\r\n如果是利用第三方库来构建这个博客，我觉得我到现在可能也没法搞清楚前端路由以及状态管理，或者是 node，因为这个博客需要使用 node 来解析 markdown 目录树，将它注入到变量中。\r\n\r\n我会继续维护它，某一天想到的新点子我会马上实现，我不会让这个页面变复杂，它将永远是静态页面。我尽量让这个页面简洁大方，容易阅读为主，如果可能的话，我会稍微加入一些图片，或者是音频，听一首惬意的轻音乐不也很好吗。(现在已经有音乐了，在`关于`页面中可以找到一个播放控件。)\r\n"}]}