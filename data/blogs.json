[
  {
    "name": "saber2prの窝",
    "content": "你说既视感？\n\n错觉！\n\n为什么会有这个 Page？\n\n大概我想记录自己的心得但穷于购买 server service。\n\n为什么要搞一些闪瞎眼的 Animation？？\n\n如果没有过渡你可能想马上关掉这个呆掉的 Page。\n\n这个 page 上面大概有些什么值得我看的东西？\n\n如果你对二刺猿感兴趣我建议你点击`链接`->`bilibili`离开这里。\n",
    "href": "/blog/hello"
  },
  {
    "name": "HTTP跨域之OPTIONS请求",
    "content": "前几天在写一个前后端交互的项目，遇到个问题：Header 无法发送 Authorization 字段。\n\n我明明用 RESTClient 发 POST 测试得好好的。。(后来知道 OPTIONS 请求是浏览器自动发的，RESTClient 要手动发)\n\n后端 API 鉴权采用类 jwt 的方式，为什么说类 jwt 呢，因为我不是按标准格式编码的，直接利用 JSON.stringify 来序列化 json 数据（当然 token 属性我已经私钥加密了）。前端从 localStorage 里拿到了 jwt，放请求头 Authorization 字段里，firefox 抓包发现请求头没带上 jwt，请求变成了 OPTIONS 请求。\n\n1. 什么是 OPTIONS 请求？\n\nOPTIONS 请求又称预检请求，就是在正式请求服务端 API 前的一个\"打招呼、询问\"。\n\n2. 为什么需要 OPTIONS 请求？\n\n前端带了特殊的请求头去访问后端，就会触发 OPTIONS 请求，会先询问后端是否支持该请求头字段(对应响应头 Access-Control-Allow-Headers)，以及后端是否支持该请求方法(对应响应头 Access-Control-Allow-Methods)。\n\n3. 那这样每次不得发两次请求？\n\nOPTIONS 请求可以被缓存(对应响应头 Access-Control-Max-Age)，在缓存过期前，不会再发 OPTIONS 请求询问。\n",
    "href": "/blog/http-request-options"
  },
  {
    "name": "reflect-metadata中HashMap巨大Object的读取速度优化",
    "content": "HashMap 原理比较复杂，不是这篇文章重点。(其实是本菜鸡不懂(\n\nreflect-metadata 中实现了 HashMap 的 polyfill，需要能快速读取数据，而 js 的 Object 当属性很多的时候性能并不好，不然就不会有 Map 了。然而 reflect-metadata 中 HashMap 用的是 Dictionary，利用了一个非常 hack 的方法。\n\nHashMap\n\n```typescript\ntype HashMap<V> = Record<string, V>;\n\nconst HashMap = {\n  // create an obj into dictionary mode (a.k.a. \"slow\" mode on v8)\n  create: <V>() => MakeDictionary(Object.create(null) as HashMap<V>),\n\n  has: <V>(map: HashMap<V>, key: string | number | symbol) =>\n    Object.prototype.hasOwnProperty.call(map, key),\n\n  get: <V>(map: HashMap<V>, key: string | number | symbol): V | undefined =>\n    Object.prototype.hasOwnProperty.call(map, key)\n      ? map[key as string | number]\n      : undefined\n};\n```\n\n好像有点简单啊，除了有个 MakeDictionary 函数\n\n在 reflect-metadata 源码中最后有一个 MakeDictionary 函数，来看看这个神奇的函数\n\nMakeDictionary\n\n```typescript\n// uses a heuristic used by v8 and chakra to force an obj into dictionary mode.\nfunction MakeDictionary<T>(obj: T): T {\n  (<any>obj).__ = undefined;\n  delete (<any>obj).__;\n  return obj;\n}\n```\n\n它给 obj 添加了\\_\\_属性，值为 undefined，然后又删了，注释解释说这可以启发 v8 或者査克拉引擎将 Object 转换到 dictionary mode（？？），可以大幅提升 Object 属性读取的速度？\n\n下面来测试一下（Node 环境）\n\n先写一个 fill 函数，用来填充属性\n\n```typescript\nfunction fillSomething(obj: Object, size: number = 100000) {\n  while (size--) obj[size] = Math.random();\n}\n```\n\n测试一下读取速度\n\n```typescript\n// 普通obj\nconst obj = {};\n// 填充100000个随机属性\nfillSomething(obj);\n\nconsole.time(\"obj\");\nconsole.log(obj[\"5555\"]);\nconsole.timeEnd(\"obj\"); // obj 2.813ms\n\n// 创建一个hashMap\nconst hashMap = HashMap.create();\n// 填充100000个随机属性\nfillSomething(hashMap);\n\nconsole.time(\"hashMap\");\nconsole.log(HashMap.get(hashMap, \"5555\"));\nconsole.timeEnd(\"hashMap\"); // hashMap 0.398ms\n```\n\n足足快了 30 多倍？\n\n真假？。。其实把上面两个 time 顺序颠倒也不是这么回事，但出自 rbuckton 大神之手应该不是随便写的\n\n所以以后遇到巨大 Object 的时候不妨用此方法优化一下试试。\n",
    "href": "/blog/objToDic"
  },
  {
    "name": "使用reflect-metadata反射实现Typescript-IOC及依赖注入",
    "content": "1. 首先说明要干什么。\n\n实现一个存放类的容器，并能按照类之间依赖关系自动构建实例。\n\n2. 核心原理：\n\n利用 Reflect-metadata 获取构造函数中的参数类型(design:paramtypes)。\n\n利用 Reflect-metadata 在目标对象上定义和获取元数据。\n\n先举个例子：\n\n```typescript\nclass Service {\n  constructor() {}\n}\n\nclass Controller {\n  constructor(private Service: Service) {}\n}\n```\n\n一个 Service 类，一个 Controller 类，其中 Controller 类依赖于 Service 类。\n\n利用 Reflect 可以轻松获取 Controller 类构造函数中的 paramtypes。\n\n实现@Injectable\n\nInjectable 函数返回一个类装饰器，利用反射获取被装饰类的构造函数的参数类型。\n\n先举个栗子\n\n```typescript\nconst enum DESIGN {\n  PARAMTYPES = \"design:paramtypes\"\n}\n\nfunction Injectable(): ClassDecorator {\n  return target => {\n    // 获取被装饰类的构造函数的参数类型\n    const ctorParams: any[] = Reflect.getMetadata(DESIGN.PARAMTYPES, target);\n    console.log(ctorParams);\n  };\n}\n```\n\n利用设计键获取到参数列表：\n\n```typescript\nclass Service {\n  constructor() {}\n}\n\n@Injectable() // [ Service() ]\nclass Controller {\n  constructor(private Service: Service) {}\n}\n```\n\n@Injectable\n\n```typescript\nexport function Injectable(id?: PropertyKey): ClassDecorator {\n  return target => {\n    // 索引键值默认为target.name\n    const token = id || target.name;\n\n    // 如果token已存在则抛出Error\n    if (Reflect.hasMetadata(token, MetaStore)) {\n      throw new Error(`id:[${String(token)}] is existed!`);\n    } else {\n      Reflect.defineMetadata(token, target, MetaStore);\n    }\n  };\n}\n```\n\nInjectable 提供了可选项 id?，用来避免命名冲突。\n\n这样只要被 Injectable()装饰过的类都会被缓存到 MetaStore 中。\n\n实现@Inject\n\n读写 target 身上的元数据，用于注入依赖信息\n\n```typescript\n// target身上的元数据类型\nexport interface DepMeta {\n  id: PropertyKey;\n  index: number;\n}\n\nexport function Inject(id: PropertyKey): ParameterDecorator {\n  return (target, _, index) => {\n    // 获取到target身上的DepMeta数组，如果没有就创建一个新的\n    const depMeta =\n      Reflect.getMetadata<Array<DepMeta>>(CUSTOM.META, target) || [];\n    // push一个DepMeta，id和index\n    depMeta.push({ id, index });\n    // 再把DepMeta数组保存回target\n    Reflect.defineMetadata(CUSTOM.META, depMeta, target);\n  };\n}\n```\n\nindex 即参数在函数(构造函数)arguments 数组中的下标，id 为 Injectable-token\n\n例如：\n\n```typescript\n@Injectable() // 缓存到MetaStore, id: 'Service'.\nclass Service {\n  constructor() {}\n}\n\ninterface IService {}\n\nclass Controller {\n  // inject注解，请求依赖为id- 'Service', 位置为index- 0\n  constructor(@Inject(\"Service\") private Service: IService) {}\n}\n```\n\n实现 Injector 函数（核心）\n\n从入口开始构建整个依赖树，并生成根实例\n\n```typescript\ntype Constructor<T = any> = { new (...args: Array<any>): T };\n\nexport function Injector(Target: Constructor): any {\n  // 如果是静态类或singleton，直接返回\n  if (Reflect.hasMetadata(CUSTOM.STATIC, Target)) return Target;\n\n  // 获取Target构造函数的参数列表\n  const deps =\n    Reflect.getMetadata<Array<Constructor>>(DESIGN.PARAMTYPES, Target) || [];\n\n  // 获取target身上DepMeta数组\n  const tags = Reflect.getMetadata<DepMeta[]>(CUSTOM.META, Target) || [];\n\n  // 遍历DepMetas\n  tags.forEach(tag => {\n    // 如果MetaStore中注册了tag.id\n    if (Reflect.hasMetadata(tag.id, MetaStore)) {\n      // 按index将Injectable插入deps中\n      deps[tag.index] = Reflect.getMetadata(tag.id, MetaStore);\n    } else {\n      // Inject请求的Injectable没有在MetaStore中找到\n      throw new Error(`injected dep:${String(tag.id)} not found`);\n    }\n  });\n  // 递归构建,当deps为空时结束\n  const instances = deps.map(Injector);\n\n  // 注入依赖，生成实例\n  return new Target(...instances);\n}\n```\n\nDemo\n\n```typescript\n@Injectable()\nclass Service {\n  public getUser() {\n    return \"saber!\";\n  }\n}\n\nclass Controller {\n  public constructor(@Inject(\"Service\") private Service: Service) {}\n\n  public test() {\n    console.log(this.Service.getUser());\n  }\n}\n\nconst app = Injector(Controller);\n\napp.test(); // 'saber!\n```\n",
    "href": "/blog/saber-ioc"
  },
  {
    "name": "一行代码实现koa中间件",
    "content": "本质就是把下一层的 async 函数包装一层后传给上一层 await 调用，和递归差不多。\n\n```typescript\nconst process = (...jobs) =>\n  jobs.reduceRight(\n    (next, job) => async () => await job(ctx, next),\n    () => Promise.resolve()\n  );\n```\n\n测试\n\n```typescript\nasync function job1(ctx, next) {\n  console.log(ctx.name, \"1\");\n  await next();\n  console.log(ctx.name, \"5\");\n}\n\nasync function job2(ctx, next) {\n  console.log(ctx.name, \"2\");\n  await next();\n  console.log(ctx.name, \"4\");\n}\n\nasync function job3(ctx) {\n  console.log(ctx.name, \"3\");\n}\n\nconst ctx = { name: \"koa\" };\n\nconst process = (...jobs) =>\n  jobs.reduceRight((next, job) => async () => await job(ctx, next), null);\n\nprocess(job1, job2, job3)(); // koa 1, koa 2, koa 3, koa 4, koa 5\n```\n",
    "href": "/blog/saber-koa"
  },
  {
    "name": "reflect-metadata实现及其原理",
    "content": "最近研究了一下 reflect 机理，基本算是实现了所有的 api，也通过了全部的测试用例，所以想写一篇文章记录下来。\n\nps: 这篇文章最先发在我的知呼上：https://zhuanlan.zhihu.com/p/65239993\n\nReflect Metadata 是 ES7 的一个提案，它主要用来在声明的时候添加和读取元数据。Typescript 使用反射需要安装一个依赖 reflect-metadata.\n\nTypescript 拥有完整的面向对象支持，依赖注入技术(DI)已经在 Angular、Nest 等框架中大规模使用了，就像这样\n\n```typescript\nclass Service {}\n\nclass Controller {\n  constructor(private Service: Service) {}\n}\n```\n\nIOC 框架会获取到 Controller 所依赖的类，并注入一个实例或类本身，这其中获取依赖类型就会利用到 Reflect。\n\n利用元数据设计键(Design-time type annotations)来获取依赖类型\n\n```typescript\nfunction Injectable(): ClassDecorator {\n  return target => {\n    const metadata = Reflect.getMetadata(\"design:paramtypes\", target);\n    console.log(metadata);\n  };\n}\n\nclass Service {\n  constructor() {}\n}\n\n@Injectable() // 输出 [ Service() ]\nclass Controller {\n  constructor(private Service: Service) {}\n}\n```\n\n这里需要利用装饰器来获取。这里也许你会有疑问，元数据需要先 defineMetadata 然后在 getMetadata 获取，这里为什么可以直接获取?\n\n答案就是如果 tsconfig 开启了 emitDecoratorMetadata 为 true，编译器会发出设计元数据信息。\n\n来看下 ts 编译后的 js (已开启 emitDecoratorMetadata)\n\n```typescript\n// 判断一下Reflect上是否有metadata函数，并赋给__metadata\nvar __metadata =\n  (this && this.__metadata) ||\n  function(k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\n      return Reflect.metadata(k, v);\n  };\n\nvar Service = /** @class */ (function() {\n  function Service() {}\n  return Service;\n})();\n\nvar Controller = /** @class */ (function() {\n  function Controller(Service) {\n    this.Service = Service;\n  }\n  Controller = __decorate(\n    [\n      Injectable(),\n      // 注意这里，使用design-paramtypes键定义了元数据，值是[Service]\n      __metadata(\"design:paramtypes\", [Service])\n    ],\n    Controller\n  );\n  return Controller;\n})();\n\nfunction Injectable() {\n  return function(target) {\n    Reflect.getMetadata(\"design:paramtypes\", target);\n  };\n}\n```\n\n开启了 emitDecoratorMetadata 编译器会自动生成 Design-time type annotations。\n\n通过前面的实例，容易发现，Reflect 内部应该会维护一个 Map，而且应该是 WeakMap，\n\n果不其然，在 reflect-metadata 这个库内部使用了 WeakMap，而且居然还自带了 Polyfill(不仅实现 WeakMap，还有 HashMap...)\n\n[[Metadata]] internal slot\n\nhttps://github.com/rbuckton/reflect-metadata/blob/master/Reflect.ts#L685\n\nnaive WeakMap shim\n\nhttps://github.com/rbuckton/reflect-metadata/blob/master/Reflect.ts#L1725\n\n下面开始实现。\n\n实现 Reflect.defineMetadata\n\n首先创建一个 WeakMap，它将负责维护所有类和类实例的元数据，以及解决自动回收问题。\n\n```typescript\nconst Metadata = new WeakMap<Object, Map<PropertyKey, MetadataMap>>();\n```\n\n这是一个高维的 Map，对于每个 Object 也就是类或者类实例，它都关联一个 Map。这个 Map 里又关联了属性 key 和属性所对应的 Map，所以又是一个高维的 Map。所以这个 Metadata 就是一个 3 维的 Map。\n\n```typescript\nexport function defineMetadata(\n  metadataKey: MetadataKey,\n  metadataValue: MetadataValue,\n  target: Object,\n  propertyKey: PropertyKey = DEFAULTKAY\n) {\n  // 判断target类型，因为target将作为WeakMap的键，必须是对象类型\n  if (typeof target !== \"object\" && typeof target !== \"function\") {\n    throw new TypeError();\n  }\n\n  // 如果传入propertyKey，要求类型为string或symbol\n  if (propertyKey && ![\"string\", \"symbol\"].includes(typeof propertyKey)) {\n    throw new TypeError();\n  }\n\n  // 从Metadata中获取target关联的Map，若没有就创建一个新的Map\n  const targetMetadata =\n    Metadata.get(target) || new Map<PropertyKey, MetadataMap>();\n\n  // 将targetMetadata再保存回Metadata中\n  Metadata.set(target, targetMetadata);\n\n  // 从targetMetadata中获取propertyKey关联的Map，若没有就创建一个新的Map\n  const metadataMap: MetadataMap = targetMetadata.get(propertyKey) || new Map();\n\n  // 将metadataMap再保存回targetMetadata中\n  targetMetadata.set(propertyKey, metadataMap);\n\n  // 设置元数据到metadataMap，键为metadataKey，值metadataValue\n  metadataMap.set(metadataKey, metadataValue);\n}\n```\n\n实现 Reflect.getMetadata\n\n这个 api 会依赖 getMetadataMap、getOwnMetadataMap。所以先倒着来实现\n\n1. getOwnMetadataMap\n\n```typescript\nexport function getOwnMetadataMap(\n  target: Object,\n  propertyKey: PropertyKey = DEFAULTKAY\n) {\n  // 判断target类型，因为target将作为WeakMap的键，必须是对象类型\n  if (typeof target !== \"object\" && typeof target !== \"function\") {\n    throw new TypeError();\n  }\n\n  // 从Metadata中获取target关联的Map，如果没有就返回undefined\n  const targetMetadata = Metadata.get(target);\n  if (!targetMetadata) return;\n\n  // 从targetMetadata中获取propertyKey关联的Map，如果没有就返回undefined\n  const metadataMap = targetMetadata.get(propertyKey);\n  if (!metadataMap) return;\n\n  // 返回metadataMap\n  return metadataMap;\n}\n```\n\n2. getMetadataMap\n\n获取 target 及其原型上的元数据 Map，对于同一个 propertyKey，自身的 metadataMap 覆盖原型的 metadataMap\n\n```typescript\nexport function getMetadataMap(\n  target: Object,\n  propertyKey: PropertyKey = DEFAULTKAY\n) {\n  // 如果自身有了propertyKey对应的map\n  if (Boolean(getOwnMetadataMap(target, propertyKey))) {\n    return getOwnMetadataMap(target, propertyKey);\n  }\n\n  // 去原型上找propertyKey对应的map，如果没有就返回undefined\n  const targetMetadata = Metadata.get(Object.getPrototypeOf(target));\n  if (!targetMetadata) return;\n\n  // 从targetMetadata中获取propertyKey关联的Map，如果没有就返回undefined\n  const metadataMap = targetMetadata.get(propertyKey);\n  if (!metadataMap) return;\n\n  // 返回metadataMap\n  return metadataMap;\n}\n```\n\n实现 getMetadata\n\n利用 getMetadataMap 拿到 target 关联的 metadataMap，然后根据 metadataKey 获取对应的 metadataValue\n\n```typescript\nexport function getMetadata<T>(\n  metadataKey: MetadataKey,\n  target: Object,\n  propertyKey?: PropertyKey\n): T {\n  // 根据propertyKey获取target的metadataMap，如果没有就返回undefined\n  const metadataMap = getMetadataMap(target, propertyKey);\n  if (!metadataMap) return;\n\n  // 返回metadataKey对应的metadataValue\n  return metadataMap.get(metadataKey);\n}\n```\n\n同样的还有 getOwnMetadata，只需要考虑 getOwnMetadataMap 就可以了\n\n实现 Reflect.getMetadataKeys\n\n用来获取 target 身上的所有元数据键\n\n它会依赖 getOwnMetadataKeys，所以先实现 getOwnMetadataKeys\n\n实现 getOwnMetadataKeys\n\n获取 target 自身的所有元数据键\n\n```typescript\nexport function getOwnMetadataKeys(\n  target: Object,\n  propertyKey?: PropertyKey\n): MetadataKey[] {\n  // 获取target身上与propertyKey关联的metadataMap，若没有返回空数组\n  const metadataMap = getOwnMetadataMap(target, propertyKey);\n  if (!metadataMap) return [];\n\n  // metadataMap转为数组并返回\n  return Array.from(metadataMap.keys());\n}\n```\n\n实现 getMetadataKeys\n\n获取自身的 metadataKeys，获取原型的 metadataKeys，合并后返回\n\n```typescript\nexport function getMetadataKeys(\n  target: Object,\n  propertyKey?: PropertyKey\n): MetadataKey[] {\n  // 获取target自身与propertyKey关联的metadataKeys\n  const ownKeys = getOwnMetadataKeys(target, propertyKey);\n\n  // 获取target原型与propertyKey关联的metadataKeys\n  const protoKeys = getOwnMetadataKeys(\n    Object.getPrototypeOf(target),\n    propertyKey\n  );\n\n  // 返回结果\n  return [...ownKeys, ...protoKeys];\n}\n```\n\n实现 Reflect.hasMetadata\n\n用来判断 target 上是否有对应的 metadataKey\n\n注意是判断有无 key，而不是有无 value，所以不能等价 Boolean(getMetadata)，因为 metadataValue 可以是 null 和 undefined 等值。测试用例对这里做了大量的 test。\n\n```typescript\nexport function hasMetadata(\n  metadataKey: MetadataKey,\n  target: Object,\n  propertyKey?: PropertyKey\n) {\n  const metadataKeys = getMetadataKeys(target, propertyKey);\n  return metadataKeys.includes(metadataKey);\n}\n```\n\n这个很简单，没什么好说的\n\n同样还有 hasOwnMetadata，利用 getOwnMetadataKeys 就 ok\n\n实现 Reflect.deleteMetadata\n\n```typescript\nexport function deleteMetadata(\n  metadataKey: MetadataKey,\n  target: Object,\n  propertyKey?: PropertyKey\n) {\n  const metadataMap = getOwnMetadataMap(target, propertyKey);\n  if (!metadataMap) return false;\n\n  return metadataMap.delete(metadataKey);\n}\n```\n\n实现 Reflect.decorate\n\n这个可以从测试用例上获取思路\n\n```typescript\n// reflect-decorate.test.ts\n\nit(\"DecoratorCorrectTargetInPipelineForFunctionOverload\", () => {\n  let sent: Function[] = [];\n  let A = function A(): void {};\n  let B = function B(): void {};\n  let decorators = [\n    (target: Function): any => {\n      sent.push(target);\n      return undefined;\n    },\n    (target: Function): any => {\n      sent.push(target);\n      return undefined;\n    },\n    (target: Function): any => {\n      sent.push(target);\n      return A;\n    },\n    (target: Function): any => {\n      sent.push(target);\n      return B;\n    }\n  ];\n  let target = function(): void {};\n  Reflect.decorate(decorators, target);\n  expect(sent).toEqual([target, B, A, A]);\n});\n```\n\n测试中给出的 decorators 是 4 个箭头函数的数组，把 target 参数 push 到 sent 里，然后返回一个结果\n\n要求是 Reflect.decorate 执行后，sent 是[target, B, A, A]\n\n再结合测试用例的 name 分析，看到了管道(Pipeline)，那应该会想到 reduce 而且是 reduceRight。\n\ntarget 就是 initialValue，decorators 就是 reducers。\n\ndecorate\n\n有点类型 redux 的样子，target 就是 state，decorators 就是 reducers\n\n```typescript\nexport function decorate(\n  decorators: (PropertyDecorator | MethodDecorator)[],\n  target: Object | Function,\n  propertyKey?: string | symbol,\n  attributes?: PropertyDescriptor\n): PropertyDescriptor {\n  // 如果decorators是空数组则抛出TypeError\n  if (0 === decorators.length) {\n    throw new TypeError();\n  }\n\n  // target作为initialValue，遍历decorators，将上一个decorator的结果作为target传给下一个decorator\n  return decorators.reduceRight(\n    (target, decorator) => decorator(target, propertyKey, attributes) || target,\n    <any>target\n  );\n}\n```\n\n确定 Reflect 的 type 以及混入原生 Reflect\n\n为了避免类型冲突，首先需要给原生 Reflect 的 type 起个别名，就叫 IReflect 吧\n\n```typescript\nexport type IReflect = typeof Reflect;\nexport const reflect = Reflect;\n```\n\n然后混入 Reflector\n\n```typescript\nexport const Reflect: typeof Reflector & IReflect = Object.assign(\n  reflect,\n  Reflector\n);\n```\n\n因为原生 Reflect 对象的属性不可枚举，所以只能往原生 reflect 合并\n\nps: 之前我写的 IOC 框架依赖的 reflect-metadata 也换成了现在实现的这个版本，demo 也能跑起来，感觉还不错。\n\nSaber2pr/saber-ioc\n\nhttps://github.com/Saber2pr/saber-ioc\n\nGithub\n\n@saber2pr/reflect\n\nhttps://github.com/Saber2pr/-saber2pr-reflect\n",
    "href": "/blog/saber-reflect"
  },
  {
    "name": "前端history路由实现",
    "content": "本质就是，一个观察者模式的实现。组件监听浏览器 url 的变化，作出匹配和响应。但是，路由有一点是观察者模式无法做到的，那就是当用户点击浏览器前进和后退键时，观察者不能察觉到这种行为。所以需要借助几个原生的 api 来填补这个缺点。那就是 onpopstate 事件。浏览器点击前进和后退键时会发射这个事件，所以我们可以监听这个事件，在事件回调里调用观察者 dispatch 来衔接。\n\n```typescript\nwindow.onpopstate = event => {\n  // 调用事件处理函数\n  gotoRoute(__routes, event.state);\n};\n```\n\n\\_\\_routes 对象是我们事先注册的路由，类型如下：\n\n```typescript\nexport interface Routes {\n  [url: string]: string | (() => void);\n}\n```\n\ngotoRoute 函数可以找到\\_\\_routes 对象中对应的路由分支，并执行注册的监听器。\n\n```typescript\nconst gotoRoute = (routes: Routes, start: string): void => {\n  let current = routes[start];\n  if (typeof current === \"undefined\") RouteException(start);\n  let url: string;\n  while (typeof current === \"string\") {\n    const next = routes[current];\n    if (next) {\n      url = current;\n      current = next;\n    } else {\n      RouteException(current);\n    }\n  }\n  __currentHref = url || start;\n  current();\n};\n```\n\n\\_\\_currentHref 会把当前的 url 记录下来以供组件拉取。\n\n除此之外，我们还需要提供手动触发路由的函数\n\n```typescript\nexport function push(url: string) {\n  // 将url显示到浏览器地址栏上，并把url记录到state中备用。\n  window.history.pushState(url, null, url);\n  url in __routes ? gotoRoute(__routes, url) : RouteException(url);\n}\n```\n\n路由注册函数 useRoutes\n\n```typescript\nexport function useRoutes(\n  arg1: Routes | string,\n  arg2?: string | (() => void)\n): UnUseRoutes {\n  if (typeof arg1 === \"string\") {\n    arg1 in __routes || (__routes[arg1] = arg2);\n    return () => arg1 in __routes && delete __routes[arg1];\n  } else {\n    Object.keys(arg1).forEach(\n      key => key in __routes || (__routes[key] = arg1[key])\n    );\n    return () =>\n      Object.keys(arg1).forEach(key => key in __routes && delete __routes[key]);\n  }\n}\n```\n\n最后需要注意，在函数组件中注册路由监听器必须在 useEffect 中进行，关于 useEffect 此处不多讲了。\n\nsaber-router 项目地址\n\nhttps://github.com/Saber2pr/saber-router\n",
    "href": "/blog/use-router"
  }
]
