{"path":"/blog","title":"blog","children":[{"path":"/blog/http","title":"http","children":[{"path":"/blog/http/HTTP跨域之OPTIONS请求.md","title":"HTTP跨域之OPTIONS请求","text":"前几天在写一个前后端交互的项目，遇到个问题：Header 无法发送 Authorization 字段。\n\n我明明用 RESTClient 发 POST 测试得好好的。。(后来知道 OPTIONS 请求是浏览器自动发的，RESTClient 要手动发)\n\n后端 API 鉴权采用类 jwt 的方式，为什么说类 jwt 呢，因为我不是按标准格式编码的，直接利用 JSON.stringify 来序列化 json 数据（当然 token 属性我已经私钥加密了）。前端从 localStorage 里拿到了 jwt，放请求头 Authorization 字段里，firefox 抓包发现请求头没带上 jwt，请求变成了 OPTIONS 请求。\n\n1. 什么是 OPTIONS 请求？\n\nOPTIONS 请求又称预检请求，就是在正式请求服务端 API 前的一个\"打招呼、询问\"。\n\n2. 为什么需要 OPTIONS 请求？\n\n前端带了特殊的请求头去访问后端，就会触发 OPTIONS 请求，会先询问后端是否支持该请求头字段(对应响应头 Access-Control-Allow-Headers)，以及后端是否支持该请求方法(对应响应头 Access-Control-Allow-Methods)。\n\n3. 那这样每次不得发两次请求？\n\nOPTIONS 请求可以被缓存(对应响应头 Access-Control-Max-Age)，在缓存过期前，不会再发 OPTIONS 请求询问。\n"},{"path":"/blog/http/前端history路由实现.md","title":"前端history路由实现","text":"本质就是，一个观察者模式的实现。组件监听浏览器 url 的变化，作出匹配和响应。但是，路由有一点是观察者模式无法做到的，那就是当用户点击浏览器前进和后退键时，观察者不能察觉到这种行为。所以需要借助几个原生的 api 来填补这个缺点。那就是 onpopstate 事件。浏览器点击前进和后退键时会发射这个事件，所以我们可以监听这个事件，在事件回调里调用观察者 dispatch 来衔接。\n\n```typescript\nwindow.onpopstate = event => {\n  // 调用事件处理函数\n  gotoRoute(__routes, event.state);\n};\n```\n\n\\_\\_routes 对象是我们事先注册的路由，类型如下：\n\n```typescript\nexport interface Routes {\n  [url: string]: string | (() => void);\n}\n```\n\ngotoRoute 函数可以找到\\_\\_routes 对象中对应的路由分支，并执行注册的监听器。\n\n```typescript\nconst gotoRoute = (routes: Routes, start: string): void => {\n  let current = routes[start];\n  if (typeof current === \"undefined\") RouteException(start);\n  let url: string;\n  while (typeof current === \"string\") {\n    const next = routes[current];\n    if (next) {\n      url = current;\n      current = next;\n    } else {\n      RouteException(current);\n    }\n  }\n  __currentHref = url || start;\n  current();\n};\n```\n\n\\_\\_currentHref 会把当前的 url 记录下来以供组件拉取。\n\n除此之外，我们还需要提供手动触发路由的函数\n\n```typescript\nexport function push(url: string) {\n  // 将url显示到浏览器地址栏上，并把url记录到state中备用。\n  window.history.pushState(url, null, url);\n  url in __routes ? gotoRoute(__routes, url) : RouteException(url);\n}\n```\n\n路由注册函数 useRoutes\n\n```typescript\nexport function useRoutes(\n  arg1: Routes | string,\n  arg2?: string | (() => void)\n): UnUseRoutes {\n  if (typeof arg1 === \"string\") {\n    arg1 in __routes || (__routes[arg1] = arg2);\n    return () => arg1 in __routes && delete __routes[arg1];\n  } else {\n    Object.keys(arg1).forEach(\n      key => key in __routes || (__routes[key] = arg1[key])\n    );\n    return () =>\n      Object.keys(arg1).forEach(key => key in __routes && delete __routes[key]);\n  }\n}\n```\n\n最后需要注意，在函数组件中注册路由监听器必须在 useEffect 中进行，关于 useEffect 此处不多讲了。\n\nsaber-router 项目地址\n\nhttps://github.com/Saber2pr/saber-router\n"}]},{"path":"/blog/node","title":"node","children":[{"path":"/blog/node/一行代码实现koa中间件.md","title":"一行代码实现koa中间件","text":"本质就是把下一层的 async 函数包装一层后传给上一层 await 调用，和递归差不多。\n\n```typescript\nconst process = (...jobs) =>\n  jobs.reduceRight(\n    (next, job) => async () => await job(ctx, next),\n    () => Promise.resolve()\n  );\n```\n\n测试\n\n```typescript\nasync function job1(ctx, next) {\n  console.log(ctx.name, \"1\");\n  await next();\n  console.log(ctx.name, \"5\");\n}\n\nasync function job2(ctx, next) {\n  console.log(ctx.name, \"2\");\n  await next();\n  console.log(ctx.name, \"4\");\n}\n\nasync function job3(ctx) {\n  console.log(ctx.name, \"3\");\n}\n\nconst ctx = { name: \"koa\" };\n\nconst process = (...jobs) =>\n  jobs.reduceRight((next, job) => async () => await job(ctx, next), null);\n\nprocess(job1, job2, job3)(); // koa 1, koa 2, koa 3, koa 4, koa 5\n```\n"}]},{"path":"/blog/react","title":"react","children":[{"path":"/blog/react/React-Fiber实现.md","title":"React-Fiber实现","text":"## 前言\n\ngithub 上添加 react-like 标签的项目有 20 个左右，几乎所有的项目都是使用 Javascript 编码。\n难以搞清楚一个对象的具体结构，就比如 Fiber 对象，上面有很多属性，有些是指针域，有些是对象，有些是数组，有些必选有些可选。。。\n如果不对数据结构进行合理建模的话，很难掌握对象的属性变动，也难以分析潜在的 bug，更不用说优化、重构之类的了。\n\n下面是来自某个项目的一段 JS 代码\n\n```javascript\nlet oldFiber,\n  newFiber,\n  element,\n  instance = workInProgress.stateNode;\nlet newState = Object.assign(\n  instance.state || {},\n  instance._partialState || {}\n);\nlet oldProps = instance.props;\nlet newProps = workInProgress.props;\nconst getDerivedStateFromProps = instance.constructor.getDerivedStateFromProps;\n```\n\n从这段代码中可以大致了解到 Fiber 拥有 stateNode、props 属性，Fiber.stateNode 上有 state、partialState、props 属性同时它还是个构造函数的原型（不难看出 Fiber.stateNode 应该是个 es6 class 对象）。\n\n是不是开始感到混乱了...\n\n不是说 Javascript 代码不好，相反 JS 代码相对简洁，但是作为 Typescript 的忠实粉丝，我决定还是使用 TS 来重写一遍，顺便加深对 Fiber Reconcile 过程的理解。\n"},{"path":"/blog/react/reconciler实现","title":"reconciler实现","children":[{"path":"/blog/react/reconciler实现/beginWork.md","title":"beginWork","text":"## reconcile 阶段入口\n\n判断当前 fiber 的类型(host or hook)，如果是 host 类型则根据 fiber.tag 生成一个 dom 节点，如果是 hook 类型则实例就是自己，在实例上保存一个 stateNode 属性(还是自己)用于在 createWorkInProgress 执行中回溯到 rootFiber。\n\n```typescript\nfunction beginWork(fiber: Fiber) {\n  if (fiber.type === \"hook\") {\n    return updateHOOKComponent(fiber);\n  } else {\n    return updateHostComponent(fiber);\n  }\n}\n```\n\n### updateHostComponent\n\n更新 host Fiber\n\n```typescript\nfunction updateHostComponent(fiber: Fiber) {\n  // 如果实例不存在，则生成一个真实DOM节点赋给instance\n  if (!fiber.instance) fiber.instance = renderToDOM(fiber);\n  // 对props.children(通过React.createElement生成的VNode树的children集合)进行reconcile新旧比对，标记effectType\n  return reconcileChildren(fiber, fiber.props.children);\n}\n```\n\n#### renderToDOM\n\n根据 host Fiber 生成对应实例(真实 DOM)\n\n```typescript\nfunction renderToDOM(fiber: Fiber) {\n  // 如果fiber.tag是function类型，则返回(这里主要用于类型安全)\n  if (typeof fiber.tag === \"function\") return;\n\n  // host Fiber实例可能是Element也可能是Text\n  let dom: HTMLElement | Text = null;\n\n  if (fiber.tag === \"text\") {\n    // 如果tag 值为 text，则创建一个文本节点\n    dom = document.createTextNode(\"\");\n  } else {\n    // 根据fiber.tag创建对应真实DOM\n    dom = document.createElement(fiber.tag);\n  }\n\n  // 根据fiber.props(即JSX标签上的属性)更新DOM节点\n  // 第二个参数为oldProps，因为这是Fiber实例初始化，故没有alternate(旧的Fiber)。直接传一个空属性进去。\n  updateHostProperties(dom, {}, fiber.props);\n\n  return dom as FiberInstance;\n}\n```\n\n### updateHOOKComponent\n\n更新 hook Fiber\n\n```typescript\nfunction updateHOOKComponent(fiber: Fiber) {\n  // 如果实例不存在，则把函数组件对应Fiber(就是自己)赋给instance\n  if (!fiber.instance) fiber.instance = fiber as FiberInstance;\n  // 在实例上保存一个 stateNode 属性(还是自己)用于回溯到 rootFiber。\n  fiber.instance.stateNode = fiber;\n\n  // 给全局变量currentFiber赋值，在Hook API使用\n  currentFiber = fiber.instance;\n\n  // 用于hook API ID 分配，hook需要一个id来标识\n  // 例如函数组件内多个useState Hook，在fiber.state上保存initialState时需要利用id区分\n  // Order.fallback在hook组件执行后将id分配器回滚。(具体见后续实现)\n  Order.fallback();\n\n  // 这里判断fiber.tag是否为function类型，hook Fiber的实例是函数组件，所以tag就是函数组件。\n  if (typeof fiber.tag !== \"function\") return;\n  // 执行函数组件，并传入props对象，返回hook Fiber的 Vnode children\n  return reconcileChildren(fiber, fiber.tag(fiber.props));\n}\n```\n"},{"path":"/blog/react/reconciler实现/commitAllWork.md","title":"commitAllWork","text":"## commit 阶段\n\n检测到 pendingCommit 被赋值后则立刻进入 commit 阶段\n\n### 函数声明\n\n```typescript\nfunction commitAllWork(fiber: Fiber): void;\n```\n\n传入 pendingCommit(一个 EffectFibers 链表，其实是 rootFiber，rootFiber 的 effectList 属性就相当于一个 Fiber 链表。JS 里数组不也是一种链表么，还是可迭代对象(Iteratable)呢)\n\n### 函数实现\n\n```typescript\nfunction commitAllWork(fiber: Fiber) {\n  // 遍历effectList链表，对每个EffectFiber执行commitWork操作\n  fiber.effectList.forEach(commitWork);\n\n  // 所有任务commit完毕后，将workInProgress和pendingCommit置空\n  workInProgress = null;\n  pendingCommit = null;\n}\n```\n"},{"path":"/blog/react/reconciler实现/commitWork.md","title":"commitWork","text":"## 单个 Fiber 的 commit 操作\n\n### 函数声明\n\n```typescript\nfunction commitWork(fiber: Fiber): void;\n```\n\n根据 Fiber.effectType 的类型进行 commit 操作\n\n### 函数实现\n\n```typescript\nfunction commitWork(fiber: Fiber) {\n  // 向上查找host Fiber类型的parent节点\n  let parentFiber = fiber.parent;\n  while (parentFiber.type === \"hook\") {\n    parentFiber = parentFiber.parent;\n  }\n\n  // 拿到host Fiber类型的parentFiber的实例(host Fiber类型的实例是真实DOM)\n  const parentDom = parentFiber.instance;\n\n  // 判断effectType\n  if (fiber.effectType === \"place\" && fiber.type === \"host\") {\n    // 如果是effectType:place，并且当前fiber是host Fiber类型\n\n    // 因为组件要被其他组件替换，即UnMount，则执行effects中的清理函数。\n    commitEffects(fiber);\n    // place替换真实DOM节点(或append创建)\n    commitPlace(fiber, parentDom, parentFiber.refChild);\n  } else if (fiber.effectType === \"update\") {\n    // 如果是effectType:update\n    // diff 新旧fiber的props属性(利用alternate链接到旧的fiber的props)\n    updateHostProperties(fiber.instance, fiber.alternate.props, fiber.props);\n  } else if (fiber.effectType === \"delete\") {\n    // 如果是effectType:delete\n    // 组件卸载，执行effects中的清理函数\n    commitEffects(fiber);\n    // 删除真实DOM节点\n    commitDelete(fiber, parentDom);\n  }\n\n  // 如果组件WillMount或者UnMount则执行一次commitEffects\n  // 本质是遍历Fiber.effects数组，执行注册的副作用任务，并收集副作用的返回值(清理函数)。\n  if (!fiber.isMount) commitEffects(fiber);\n\n  // 如果props中注册了ref指针，并且当前fiber是host Fiber类型，则将实例(真实DOM)赋值给ref.current\n  if (\"ref\" in fiber.props && fiber.type === \"host\") {\n    fiber.props.ref.current = fiber.instance;\n  }\n}\n```\n\n#### commitPlace\n\n替换或者创建 host Fiber 的实例\n\n```typescript\nfunction commitPlace(fiber: Fiber, parentDom: FiberInstance, refChild: Fiber) {\n  if (refChild) {\n    // 如果存在refChild表示是一次place操作\n    const newChild = fiber.instance;\n    // refChild就是fiber.alternate.sibling.instance，即旧fiber的兄弟节点\n    const oldChild = refChild.instance;\n\n    // 在旧fiber的兄弟节点前插入新fiber的实例\n    parentDom.insertBefore(newChild, oldChild);\n  } else {\n    // 没有refChild，则是一次create操作\n    // 组件WillMount，设置标志位true\n    fiber.isMount = true;\n    // 在DOM树上添加host Fiber实例\n    parentDom.append(fiber.instance);\n  }\n}\n```\n\n#### commitDelete\n\n删除 host Fiber 的实例(从 DOM 树上移除)\n\n```typescript\nfunction commitDelete(fiber: Fiber, parentDom: FiberInstance) {\n  // 如果是hook Fiber，则找它的host Fiber子节点，但不能是text类型tag\n  while (fiber.type === \"hook\") {\n    if (fiber.child.tag === \"text\") break;\n    fiber = fiber.child;\n  }\n  // 找到了hook Fiber的host Fiber子节点，将它的实例从DOM树上移除\n  parentDom.removeChild(fiber.instance);\n}\n```\n"},{"path":"/blog/react/reconciler实现/createElement.md","title":"createElement","text":"## jsxFactory 函数\n\n即 React.createElement 函数，用于生成 VNode 节点并链接成 VNode 树\n\n### 函数声明\n\n```typescript\nfunction createElement<K extends keyof HTMLElementTagNameMap>(\n  tag: K,\n  props: Partial<HTMLElementTagNameMap[K]>,\n  ...childNodes: JSX.Element[]\n): JSX.Element;\n```\n\nK 泛型参数约束为 keyof HTMLElementTagNameMap，例如\"div\"、\"a\"、\"button\"等，可以看看 TS 标准库中对 HTMLElementTagNameMap 的定义:\n\n```typescript\ninterface HTMLElementTagNameMap {\n  a: HTMLAnchorElement;\n  abbr: HTMLElement;\n  address: HTMLElement;\n  applet: HTMLAppletElement;\n  area: HTMLAreaElement;\n  article: HTMLElement;\n  aside: HTMLElement;\n  audio: HTMLAudioElement;\n  b: HTMLElement;\n  base: HTMLBaseElement;\n  basefont: HTMLBaseFontElement;\n  bdo: HTMLElement;\n  blockquote: HTMLQuoteElement;\n  body: HTMLBodyElement;\n  br: HTMLBRElement;\n  button: HTMLButtonElement;\n  ...\n}\n```\n\n所以 HTMLElementTagNameMap[K]就是 K 对应 HTMLElement 的属性类型。\n\nchildNodes 为子节点，举个例子\n\n```typescript\nconst List = React.createElement(\n  \"ul\",\n  null,\n  React.createElement(\"li\", null),\n  React.createElement(\"li\", null)\n);\n```\n\n这个 List 是个 JSX.Element 实例，其 childNodes 为[{tag:\"li\", props:null}, {tag:\"li\", props:null}]，渲染到真实 DOM 就是\n\n```html\n<ul>\n  <li></li>\n  <li></li>\n</ul>\n```\n\n### 函数实现\n\n```typescript\nexport function createElement<K extends keyof HTMLElementTagNameMap>(\n  tag: K,\n  props: Partial<HTMLElementTagNameMap[K]>,\n  ...childNodes: JSX.Element[]\n): JSX.Element {\n  // 用于map的映射函数\n  // 判断childNode类型，如果它是string或者number类型，则生成一个为tag为text的VNode\n  // 将childNode(就是文本节点内容)作为props中nodeValue的值\n  const mapper = (c: any): any =>\n    typeof c === \"string\" || typeof c === \"number\"\n      ? createElement(\"text\" as \"span\", { nodeValue: c as string })\n      : c;\n\n  // 对childNodes中每个子节点执行上面的映射函数\n  const children = [].concat(...childNodes).map(mapper);\n  // 将处理好的children保存在props中然后返回一个VNode节点\n  return <any>{ tag, props: { ...props, children } };\n}\n```\n\n这里有个非常有趣的操作，看似无用\n\n```typescript\n[].concat(...childNodes);\n```\n\n[].concat(...array) 这个表达式常用来对 array 数组降维，例如\n\n```typescript\n[].concat(...[1, 2, [3, 4]]); // [1, 2, 3, 4]\n```\n\n那么 childNodes 数组什么时候可能会变的不“平坦”呢？\n\n举个场景例子，在 React 组件中常有一种操作\n\n比如想通过数组['a', 'b']得到一个 a, b, c 的列表\n\n```html\n<ul>\n  <li>a</li>\n  <li>b</li>\n  <li>c</li>\n</ul>\n```\n\n在 React 中 JSX 标签可以看作是值，那么可以使用数组 map 来高效生成：\n\n```typescript\n<ul>\n  {[\"a\", \"b\"].map(ch => (\n    <li key={ch}>{ch}</li>\n  ))}\n  <li>c</li>\n</ul>\n```\n\n编译之后\n\n```typescript\nReact.createElement(\n  \"ul\",\n  null,\n  [\"a\", \"b\"].map(ch =>\n    React.createElement(\n      \"li\",\n      { key: ch },\n      React.createElement(\"text\", { nodeValue: ch })\n    )\n  ),\n  React.createElement(\n    \"li\",\n    null,\n    React.createElement(\"text\", { nodeValue: \"c\" })\n  )\n);\n```\n\n分析一下它生成的 VNode 树\n\n```typescript\n{\n  tag: \"ul\", props: null,\n  [\n    {tag:\"li\", null,\n      {tag:\"text\", {nodeValue: 'a'}}\n    },\n    {tag:\"li\", null,\n      {tag:\"text\", {nodeValue: 'b'}}\n    }\n  ],\n  {tag:\"li\", null,\n      {tag:\"text\", {nodeValue: 'c'}}\n  }\n}\n```\n\n简化一下就是变成了[['a', 'b'], 'c']的结构，变不“平坦”了！但是三个 li 标签在结构上应该是['a', 'b', 'c']才对，所以需要数组降维。\n"},{"path":"/blog/react/reconciler实现/hook","title":"hook","children":[{"path":"/blog/react/reconciler实现/hook/createContext.md","title":"createContext","text":"## Context Hook\n\ncontext 理解为全局变量就好了，只不过约定使用 createContext 创建，使用 useContext 读取。\n(如果是 class 组件，需要实现为 provider & customer，但当前只实现函数组件。)\n\n### 实现\n\n```typescript\nfunction createContext<T extends Dict>(context: T) {\n  return context;\n}\n\nfunction useContext<T extends Dict>(context: T) {\n  return context;\n}\n```\n\ncontext 初次听起来怪怪的，但是实际上它就是这样。\nuseContext 读取了 context，其实就已经引入了副作用，至少它访问了外部环境。需要将 Context 包装在 Monad 里才对，然后把对 Context 的操作 liftM 进 Context Monad 里。(貌似 React 内部的 useContext 会引发 rerender，应该是改变 context 后需要重新通知所有组件一次)\n"},{"path":"/blog/react/reconciler实现/hook/useEffect.md","title":"useEffect","text":"## Effect Hook\n\n这是一个 pure 操作，将副作用包裹在了 Monad 里（可以理解为外面又包了一层函数），react 调度机制会在一轮渲染之后执行这些副作用操作，保证了副作用与函数组件主体的充分隔离。\n\n### Effect 类型\n\n```typescript\ntype Effect = () => Effect | void;\n```\n\n这是一个利用函数特性实现的 Monad。首先是个映射到自身类型的自函子，然后可以 return 可以 >>=，即自函子范畴上的幺半群。\n\n## useEffect 实现\n\n```typescript\nexport function useEffect(effect: Effect, deps?: any[]) {\n  if (deps) {\n    // 如果deps存在，使用memorize优化\n    useMemo(() => currentFiber.effects.push(effect), deps);\n  } else {\n    currentFiber.effects.push(effect);\n  }\n}\n```\n\n这里将 Moand 放到了一个 List 中，在纯函数组件执行完之后(进入 commitWork 阶段)，依次执行。\n"},{"path":"/blog/react/reconciler实现/hook/useMemo.md","title":"useMemo","text":"## Memo Hook\n\nmemorize 优化\n\n因为对于纯函数来说，相同的输入得到相同的输出，所以可以把结果缓存起来，对于同样的输入没必要再执行第二遍。\n\n### 对 deps 数组的 diff\n\n```typescript\nconst diffArray = <T extends any[]>(a: T, b: T) => {\n  if (a.length && b.length) {\n    let i = a.length > b.length ? a.length : b.length;\n    while (i--) if (a[i] !== b[i]) return false;\n    return true;\n  } else {\n    return false;\n  }\n};\n```\n\n没什么好解释的。\n\n## useMemo 实现\n\n依赖 Fiber.memorize 属性\n\n```typescript\n// memo hook的顺序id分配器\nconst MemoOrder = Order.create();\n\nexport function useMemo(callback: Function, deps: any[] = []) {\n  // 给当前hook关联的memorize分配一个id\n  const id = MemoOrder.forward();\n\n  // currentFiber是一个不断变化的值，hook内部需要捕获并缓存一份它的瞬时值\n  // 记录即缓存一份currentFiber，拿到控制权，用于从当前记录点恢复\n  const fiber = currentFiber;\n\n  // fiber.memorize是一个memorizations map，类型为 {[id:string]: Dict}\n  const memoMap = fiber.memorize;\n\n  // 获取上一次输入\n  const memorized = memoMap[id] || [];\n\n  if (diffArray(deps, memorized)) {\n  } else {\n    // 如果和上次输入不同，则更新memorization为新的deps\n    memoMap[id] = deps;\n    // 执行memo callback\n    callback();\n  }\n}\n```\n"},{"path":"/blog/react/reconciler实现/hook/useRef.md","title":"useRef","text":"## Ref Hook\n\nref 用来索引到 host Fiber 的实例(真实 DOM)\n\nref 是一个指针，在 JS 中实现为对象，传递它的引用避免值拷贝\n\n### ref 类型\n\n```typescript\ntype RefAttributes<T extends HTMLElement> = {\n  current: T;\n};\n```\n\n是一个对象，只有一个成员属性 current，泛型类型约束为 HTMLElement，即 T 类型需要满足 [继承自 HTMLElement] 的条件\n\n### 何时被初始化？\n\n在组件对应 Fiber commit 时初始化(异步初始化)，在组件内部需要异步读取此值，例如在 useEffect 里，在 onClick 里等等，组件内顶层直接读取值为 null(因为组件执行是同步的)\n\n在实现 commitWork 的时候已经解释了 ref 的初始化。这里不再赘述。\n\n## useRef 实现\n\n因为它本质就是利用了 JS 中对象赋值传引用的特性。所以十分简单。\n\n```typescript\nexport function useRef<T extends HTMLElement>(\n  current: T = null\n): React.RefAttributes<T> {\n  return { current };\n}\n```\n\n没有什么好解释的。\n\n> 其实就是对 ref 惰性求值，你也可以把它实现为 pure 版本，利用 Monad 包装起来，例如 ref = () => current\n"},{"path":"/blog/react/reconciler实现/hook/useState.md","title":"useState","text":"## State Hook\n\n在 beginWork/updateHookComponent 函数中留了两个问题，就是关于 Order 类和 currentFiber。\n\n#### updateHOOKComponent\n\n```typescript\nfunction updateHOOKComponent(fiber: Fiber) {\n  // 省略细节...\n\n  currentFiber = fiber.instance;\n\n  Order.fallback();\n\n  // 省略细节...\n}\n```\n\n### currentFiber\n\ncurrentFiber 为调度过程中的瞬时执行点，在 hook API 闭包内会捕获并保存一份拷贝。\n\n### Order\n\n顺序 ID 分配器\n\n```typescript\nclass Order {\n  private constructor() {}\n  public static create() {\n    const instance = new Order();\n    Order.insList.push(instance);\n    return instance;\n  }\n  public static insList: Order[] = [];\n  private it = Order.INIT();\n  public forward() {\n    return this.it.next().value;\n  }\n  private fallback() {\n    this.it = Order.INIT();\n  }\n  public static fallback() {\n    Order.insList.forEach(ins => ins.fallback());\n  }\n  private static *INIT() {\n    for (let i = 0; ; ++i) yield i;\n  }\n}\n```\n\n就是个惰性的无穷数列，即[0, 1 ..]\nforward 用于分配 ID，fallback 用于分配器回滚。\n它解决了什么问题？区分多次调用同类型 Hook API 的上下文。\n\n## useState 实现\n\n依赖 Fiber.state 属性\n\n```typescript\n// state hook的顺序id分配器\nconst StateOrder = Order.create();\n\n// setState类型\ntype Dispatcher<T> = (state: T) => void;\n\nexport function useState<T>(initialState: T): [T, Dispatcher<T>] {\n  // 给当前hook关联的state分配一个id\n  const id = StateOrder.forward();\n\n  // currentFiber是一个不断变化的值，hook内部需要捕获并缓存一份它的瞬时值\n  // 记录即缓存一份currentFiber，拿到控制权，用于从当前记录点恢复\n  const fiber = currentFiber;\n\n  // fiber.state是一个state map，类型为 {[id:string]: Dict}\n  const stateMap = fiber.state;\n\n  // 如果当前id不存在则stateMap[id]初始化为init state\n  if (!(id in stateMap)) stateMap[id] = initialState;\n\n  // setState函数\n  const setState: Dispatcher<T> = state => {\n    // 检查setState执行时期，如果workInProgress存在表明是同步调用setState\n    // setState必须为异步调用，否则调度机制会陷入死循环\n    // 而且同步调用setState也没有任何意义。\n    if (workInProgress) {\n      throw new Error(\"setState should be executed asynchronously.\");\n    }\n\n    // 根据id拿到当前hook分配到的state，并更新为传入的新的state\n    stateMap[id] = state;\n\n    // 从hook 闭包内保存的fiber断点恢复(或叫返回现场)\n    React.render(fiber);\n  };\n\n  // 返回分配到的state和setState函数\n  return [stateMap[id], setState];\n}\n```\n"}]},{"path":"/blog/react/reconciler实现/performUnitOfWork.md","title":"performUnitOfWork","text":"## 函数声明\n\n```typescript\nfunction performUnitOfWork(fiber: Fiber): void;\n```\n\n遍历一颗 Fiber 链表，reconcile 然后收集 effectFibers(向上合并最终收集到 Fiber 链表的 head Fiber(即 rootFiber)的 effectLists 中)\n\n## 函数实现\n\n```typescript\nfunction performUnitOfWork(fiber: Fiber) {\n  // beginWork内部负责对fiber.child的两条sibling-sibling链表进行新旧比对\n  // 通过child.alternate拿到旧的链表\n  // 最终返回fiber.child\n  const next = beginWork(fiber);\n  // 如果next(也就是fiber.child)存在，则直接返回它\n  if (next) return next;\n\n  // 如果不存在，则开始回溯\n  let current = fiber;\n  while (current) {\n    // completeWork负责向上收集effectFibers，如果到达了顶点，则把当前Fiber节点赋值给pendingCommit\n    completeWork(current);\n\n    // 如果有sibling，则返回它的sibling\n    if (current.sibling) return current.sibling;\n    // 如果没有sibling，则向上回溯\n    current = current.parent;\n  }\n}\n```\n"},{"path":"/blog/react/reconciler实现/performWork.md","title":"performWork","text":"## performWork 渲染流程\n\nrender 渲染流程入口\n\n### 函数声明\n\n```typescript\nfunction performWork(deadline: IdleDeadline);\n```\n\nperformWork 由 requestIdleCallback 函数注册到后台协同任务队列，当 JS 线程空闲时执行队列中的函数。\n\n### 函数实现\n\n```typescript\nfunction performWork(deadline: IdleDeadline) {\n  // 内部循环迭代workInProgress\n  workLoop(deadline);\n\n  // 如果workInProgress为空了，表示当前渲染任务执行完毕，查看updateQueue是否为空\n  // 如果不为空则再请求一次后台协同任务\n  if (workInProgress || updateQueue.length) {\n    requestIdleCallback(performWork);\n  }\n}\n```\n"},{"path":"/blog/react/reconciler实现/reconcileChildren.md","title":"reconcileChildren","text":"## children 新旧比对\n\n拿到当前 fiber 对应 VNode 树的 children 集合作为新链表，通过 alternate 拿到旧链表，然后 diff 两条链表。\n\n### 函数声明\n\n```typescript\nfunction reconcileChildren(fiber: Fiber, newChildren: Fiber | Fiber[]): Fiber;\n```\n\n第二个参数 newChildren 来源：当 fiber 为 host Fiber 类型时，则从 props.children 中取(由 jsxFactory 函数即 React.createElement 函数收集 children VNode)；当 fiber 为 hook Fiber 类型时(此时 fiber.tag 为 function 类型，也就是你的函数组件)，执行 fiber.tag(fiber.props)，即将 props 传入函数组件执行，返回 children。\n\n### 函数实现\n\n```typescript\nfunction reconcileChildren(fiber: Fiber, newChildren: Fiber | Fiber[]) {\n  // 数组化，归一化处理。例如'a' -> ['a'], ['a', 'b'] -> ['a', 'b']\n  const children = React.Children.toArray<Fiber>(newChildren);\n\n  // 拿到旧fiber节点的child\n  let nextOldFiber = fiber.alternate ? fiber.alternate.child : null;\n\n  let newFiber: Fiber = null;\n  let i = 0;\n\n  // 新旧两条链表开始比对，一条是VNode.props.children链表，一条是oldFiber.sibling链表\n  while (i < children.length || nextOldFiber) {\n    // prevChild用来记录上一次的newFiber，用于链接新的sibling-sibling链表\n    const prevChild = newFiber;\n\n    // 遍历过程中当前旧的节点\n    const oldFiber = nextOldFiber;\n\n    // 当前新的VNode节点\n    const element = i < children.length && children[i];\n\n    // 如果oldFiber存在且element也存在，并且两者tag相同，则两个fiber节点相同\n    // 否则不同\n    const sameTag = oldFiber && element && element.tag === oldFiber.tag;\n\n    if (sameTag) {\n      // 如果新旧节点相同，则直接拷贝旧的节点，并标记effectType为update\n      // 为什么要拷贝，而不是直接newFiber = oldFiber，下文解释\n\n      newFiber = new Fiber(oldFiber.type);\n      newFiber.tag = oldFiber.tag;\n      newFiber.instance = oldFiber.instance;\n      newFiber.state = oldFiber.state;\n      newFiber.props = element.props;\n      newFiber.parent = fiber;\n      newFiber.alternate = oldFiber; // 新fiber上利用alternate链接到旧的fiber，后续commit:update需要\n      newFiber.effectType = \"update\";\n      newFiber.effects = oldFiber.effects;\n      newFiber.isMount = oldFiber.isMount;\n    }\n    if (element && !sameTag) {\n      // 如果新的节点存在，但和旧的节点不同，则保持新节点的属性，并标记effectType为place\n\n      newFiber = new Fiber(typeof element.tag === \"string\" ? \"host\" : \"hook\");\n      newFiber.tag = element.tag;\n      newFiber.props = element.props;\n      newFiber.parent = fiber;\n      newFiber.effectType = \"place\";\n      newFiber.isMount = false; // 要被替换掉，所以UnMount\n    }\n    if (oldFiber && !sameTag) {\n      // 如果旧的节点存在，但和新的节点不同，则删除旧的节点，并标记effectType为delete\n\n      oldFiber.effectType = \"delete\";\n      oldFiber.isMount = false; // 要被删除掉，所以UnMount\n      // 提交到parent Fiber effectList中\n      fiber.effectList.push(oldFiber);\n      // 节点被删除，在父节点上标记refChild\n      fiber.refChild = oldFiber.sibling;\n    }\n\n    // 旧链表向后遍历\n    if (nextOldFiber) nextOldFiber = nextOldFiber.sibling;\n\n    if (i === 0) {\n      // 如果是第一个child则赋给parentFiber.child\n      fiber.child = newFiber;\n    } else if (prevChild && element) {\n      // 链接新链表的sibling-sibling\n      prevChild.sibling = newFiber;\n    }\n\n    // 新链表向后遍历，element依靠index索引从children获取current节点\n    i++;\n  }\n\n  // 返回第一个child\n  return fiber.child;\n}\n```\n\n解释当 effectType 为 update 时为什么要拷贝:\n一个词 immutable.\n"},{"path":"/blog/react/reconciler实现/render.md","title":"render","text":"## ReactDOM.render\n\n渲染流程起点\n\n### 函数声明\n\n```typescript\nexport namespace ReactDOM {\n  export function render(component: JSX.Element): void;\n  export function render(component: JSX.Element, container: HTMLElement): void;\n}\n```\n\n函数重载两次\n\n传入 container 参数(也就是 div#root)，表示这是第一次渲染，并清空 rootContainer 子节点。创建一个 host Fiber(rootFiber)，其实例为 container，将 component 添加到 rootFiber 的子节点(即保存到 rootFiber.props 的 children 属性 )。\n\n不传 container 参数表示是一次由 hook 函数组件调用 ReactDispatcher 引起的更新(场景为用户点击事件)，例如 useState 返回的 setState 函数执行，在 createWorkInProgress 函数中将从当前 fiber 实例上的 stateNode 向上回溯到 rootFiber 并赋值给 workInProgress。\n\n### 函数实现\n\n```typescript\nexport namespace ReactDOM {\n  export function render(\n    component: JSX.Element,\n    container?: HTMLElement\n  ): void {\n    let fiber: Fiber;\n\n    if (container) {\n      // 第一次渲染\n\n      // 创建一个rootFiber\n      fiber = new Fiber(\"host\");\n\n      // rootFiber实例为真实DOM(div#root)\n      fiber.instance = container as FiberInstance;\n\n      // 清空rootFiber实例子节点\n      container.innerHTML = null;\n\n      // 将component添加到 rootFiber 的子节点\n      fiber.props = { children: component };\n    } else {\n      // 创建一个hook Fiber\n      fiber = new Fiber(\"hook\");\n\n      // 将函数组件作为hook Fiber的实例\n      fiber.instance = component as FiberInstance;\n\n      // 设置高优先级\n      fiber.expirationTime = 1;\n    }\n\n    // 放入待调度队列\n    updateQueue.push(fiber);\n\n    // 启动渲染流程\n    requestIdleCallback(performWork);\n  }\n}\n```\n"},{"path":"/blog/react/reconciler实现/updateHostProperties.md","title":"updateHostProperties","text":"## 更新 DOM\n\ndom 操作\n\n### 函数声明\n\n```typescript\ntype Dict = { [k: string]: any };\n\nfunction updateHostProperties(\n  dom: (HTMLElement | Text) & Dict,\n  oldProps: Dict,\n  newProps: Dict\n): void;\n```\n\n三个参数，dom 的类型为 HTMLElement 或者 Text，`& Dict`用于给这俩个类型添加属性索引，第二个参数为 dom 节点旧的属性，即 host Fiber 的 alternate.props，第三个参数为新的 host Fiber 的 props，由 React.createElement 生成的 VNode 节点提供。\n\n### 函数实现\n\n```typescript\n// props中需要过滤掉的属性\nconst fiberProps = [\"children\", \"ref\"];\n\nfunction updateHostProperties(\n  dom: (HTMLElement | Text) & Dict,\n  oldProps: Dict,\n  newProps: Dict\n) {\n  // 遍历newProps属性，diff\n  Object.entries(newProps).forEach(([k, v]) => {\n    // 过滤属性\n    if (fiberProps.includes(k)) return;\n    // style属性过滤掉，下文单独处理\n    if (k === \"style\") return;\n    // 新旧值没变化，跳过此次DOM操作\n    if (oldProps[k] === v) return;\n    // on开头的event事件handle变lower case\n    if (k.startsWith(\"on\")) k = k.toLowerCase();\n    // 应用变化的属性到真实DOM\n    dom[k] = v;\n  });\n  // style属性diff\n  if (\"style\" in dom) {\n    const newStyle = newProps.style || {};\n    const oldStyle = oldProps.style || {};\n    Object.entries(newStyle).forEach(([k, v]) => {\n      // 新旧样式属性没变化，跳过此次DOM操作\n      if (oldStyle[k] === v) return;\n      // 应用变化的样式属性到真实DOM\n      dom.style[k] = v;\n    });\n  }\n}\n```\n"},{"path":"/blog/react/reconciler实现/workLoop.md","title":"workLoop","text":"## workLoop 渲染循环\n\n用于创建并迭代更新 workInProgress(一个 Fiber 链表)。同时负责检查 pendingCommit(就是收集了 effectFibers 的 rootFiber，也可以实现为一个 Fiber 链表)，如果有就进入 commit 阶段。\n\n### 函数声明\n\n```typescript\nfunction workLoop(deadline: IdleDeadline);\n```\n\n传入了一个 deadline 对象，检查空闲时间。\n\n### 函数实现\n\n```typescript\nfunction workLoop(deadline: IdleDeadline) {\n  // 如果workInProgress为空，则先构建一个Fiber赋值给workInProgress\n  // 本质是回溯到rootFiber\n  if (!workInProgress) workInProgress = createWorkInProgress(updateQueue);\n\n  // 如果workInProgress不为空且当前空闲时间足够就开始迭代更新。\n  while (\n    workInProgress &&\n    deadline.timeRemaining() > workInProgress.expirationTime\n  ) {\n    // 迭代更新\n    workInProgress = performUnitOfWork(workInProgress);\n  }\n\n  // 如果有pendingCommit则立刻commit\n  if (pendingCommit) commitAllWork(pendingCommit);\n}\n```\n"},{"path":"/blog/react/reconciler实现/全局变量.md","title":"全局变量","text":"## 概览\n\n在调度更新时全局范围内存在有四个变量\n\n```typescript\nconst updateQueue: Fiber[] = [];\nlet workInProgress: Fiber;\nlet pendingCommit: Fiber;\nlet currentFiber: Fiber;\n```\n\n### updateQueue\n\n一个任务队列。用于注册待调度更新的 Fiber 链表。当浏览器空闲时会从中取出 Fiber 链表开始调度更新。\n\n### workInProgress\n\n在迭代更新(新旧更替)过程中的 Fiber 链表快照。\n\n### pendingCommit\n\n在 workLoop 过程中收集到的标记有 EffectType 的 Fiber 链表，等待 commit。\n\n### currentFiber\n\n当前正在调度更新的 Fiber 节点。在 Hook API 中会读取并缓存一份此值的拷贝(保存现场，即 yield)，用于在渲染完毕之后返回现场。\n"}]},{"path":"/blog/react/数据结构类型","title":"数据结构类型","children":[{"path":"/blog/react/数据结构类型/Fiber数据结构.md","title":"Fiber数据结构","text":"## Fiber 链表\n\n> 数据域和 React Fiber 有所区别，但核心的指针域是一样的。\n\n### 概览\n\n```typescript\ntype Fiber = {\n  type: FiberType;\n  tag: Tag | React.FC;\n  effectType: EffectType;\n  parent: Fiber;\n  child: Fiber;\n  sibling: Fiber;\n  alternate: Fiber;\n  props: Props;\n  state: Dict;\n  memorize: Dict;\n  effects: Effect[];\n  effectList: Fiber[];\n  instance: FiberInstance;\n  stateNode: Fiber;\n  expirationTime: number;\n  isMount: boolean = false;\n  refChild: Fiber;\n};\n```\n\n### Fiber.type\n\n```typescript\ntype FiberType = \"host\" | \"hook\";\n```\n\n如果一个 Fiber 的 type 值为 \"host\"，那么表示它的实例(Fiber.instance)是原生 DOM 节点。\n如果值为\"hook\"，那么表示它的实例是函数组件(React.FC)对应的 Fiber，也就是自己，此时 Fiber.tag 是函数组件(function)。\n\n### Fiber.tag\n\n```typescript\ntype Fiber = {\n  tag: Tag | React.FC;\n};\n\n// Dict 字典类型\ntype Dict = { [k: string]: any };\n\nnamespace React {\n  // FC 函数组件类型\n  export type FC<T extends Dict = Dict> = (props: T) => JSX.Element;\n}\n\ntype Tag = keyof HTMLElementTagNameMap | \"text\";\n```\n\nFiber.tag 的类型可以是 string 类型，也可以是 function 类型。string 类型就是原生 DOM 节点的 TagNameMap 集合成员，这里在集合中添加了一个新的 tag: \"text\"，用于表示原生 Text 对象，即文本节点。\n\n当 tag 为 string 类型时，Fiber.instance 就是 DOM 实例，为 function 类型时，Fiber.instance 就是函数组件对应的 Fiber\n\n### Fiber.effectType\n\n```typescript\ntype EffectType = \"place\" | \"delete\" | \"update\";\n```\n\neffectType 有三种类型，替换，删除，更新。\n\n其实还有创建，但是其过程和 place 相似(从无到有不也是一种替换么？)，故只要在 reconcile 阶段 和 commit 阶段 处理中稍作判断即可当作 place 处理。\n\n### Fiber 指针域(parent, child, sibling)\n\n```typescript\ntype Fiber = {\n  parent: Fiber;\n  child: Fiber;\n  sibling: Fiber;\n};\n```\n\nFiber 链表的空间结构\n\n```typescript\nparent\n|    \\\nchild-sibling\n|\nchild\n```\n\n和 TreeNode 数据结构有所不同，Fiber 添加了一个称做 sibling 的指针域，指向自己的兄弟节点。在 TreeNode 的遍历中可以直接拿到 children 集合，然后使用栈或者队列进行深度优先或者广度优先遍历。而在 Fiber 节点中，采取的是深度优先 + 回溯的办法遍历，优先向下遍历 child-child 链表，到头之后优先回溯到 sibling，再向下遍历 child-child 链表，如果没有 sibling 就回溯到 parent，如果没有 parent 就遍历终止。\n\n### Fiber.alternate\n\n```typescript\ntype Fiber = {\n  alternate: Fiber;\n};\n```\n\nalternate 用于链接到旧的自己。\n\n在 reconcileChildrenArray 阶段中判断 tag 是否相同，相同则标记 effectType:'update'，tag 不同或者旧的自己为 null 则标记 effectType:'place'，并把旧的自己标记 effectType:'delete'然后提交到 parent 的 effectList 中。\n\n在 commit 阶段的 effectType:update 处理中，利用 alternate 链接到旧的自己并与之 diff props 判断，更新变化的属性到真实 DOM。\n\n### Fiber.props\n\n```typescript\ntype Dict = { [k: string]: any };\n\ninterface Props extends Dict {\n  children?: Fiber | Fiber[];\n  ref?: React.RefAttributes<any>;\n}\n```\n\n如果 Fiber.type 值为'host'， 那么 props 表示真实 DOM 数据域，用于描述 DOM 属性。在 commit effectType:'update' 阶段参与属性 diff。\n\n如果 Fiber.type 值为'hook'，则 props 用于函数组件传值，例如传递 children。在 updateHookComponent 阶段中将 props 传入函数组件实例并执行，得到新的 elements(VDom tree 的所有孩子节点) 用于 reconcileChildrenArray。\n\n### Fiber.state\n\n```typescript\ntype Fiber = {\n  state: Dict;\n};\n```\n\nFiber 函数组件状态。在 useState Hook 中读取和更新。\n\n### Fiber.memorize\n\n```typescript\ntype Fiber = {\n  memorize: Dict;\n};\n```\n\n记录 memo hook 上次的输入。\n\n### Fiber.effects\n\n```typescript\ntype Effect = (...args: any) => Effect | void;\n\ntype Fiber = {\n  effects: Effect[];\n};\n```\n\nFiber 函数组件中的副作用操作，在该 Fiber 最终的 commit 阶段执行。\n如果 effect 执行后返回了新的函数，则保存新的函数到 effects 中，在 commit effectType:'place'阶段和 commit effectType:'delete'执行。\n\n使用 Fiber.isMount 来确定副作用是否需要 commit，如果组件已经 Mount，则保持 effects。\n\n> Effect 是一个自函子类型，将自身映射为自身类型，其实应该算是 Monad 了。其实函数本身就是个 Monad，函数本身就实现了 return (高阶化) 和>>= (函数执行降阶)。\n\n### Fiber.effectList\n\n```typescript\ntype Fiber = {\n  effectList: Fiber[];\n};\n```\n\n用于向上收集打上 effectType 标记的 Fiber 节点，最终收集到 rootFiber。在 commit 阶段遍历 effectList 中所有 Fiber。\n\n### Fiber.instance\n\n```typescript\ntype FiberInstance = Fiber & HTMLElement;\n\ntype Fiber = {\n  instance: FiberInstance;\n};\n```\n\nFiber 实例，当 Fiber.type 值为'host'时，instance 就是真实 DOM，值为'hook'时，instance 就是函数组件对应 Fiber(自己)。\n\n### Fiber.stateNode\n\n```typescript\ntype Fiber = {\n  stateNode: Fiber;\n};\n```\n\n在 rootFiber 实例(rootContainer 也就是 div#root 节点) 上链接到 rootFiber。\n\n### Fiber.expirationTime\n\n```typescript\ntype Fiber = {\n  expirationTime: number;\n};\n```\n\nFiber 完成一次 reconcile 所需要的最少时间。\n\n### Fiber.isMount\n\n```typescript\ntype Fiber = {\n  isMount: boolean;\n};\n```\n\n标记 Fiber Mount 状态\n\n### Fiber.refChild\n\n```typescript\ntype Fiber = {\n  refChild: Fiber;\n};\n```\n\n当 Fiber.effectType 为'delete'时将自己的 sibling 标记到 parent 的 refChild 属性，用于 commit effectType:'place'阶段的 insertBefore。\n在 commit effectType:'place'阶段会判断 parent 上的 refChild 属性是否为空，如果为空则表示 create 操作(append)，如果不为空则表示 place 操作(insertBefore)。\n"},{"path":"/blog/react/数据结构类型/关于TSX的类型定义.md","title":"关于TSX的类型定义","text":"## JSX 接口\n\n在 global 命名空间中有一个抽象接口 JSX\n\nJSX 接口中的部分类型\n\n```typescript\ndeclare global {\n  namespace JSX {\n    // 标签集合接口，定义了可用的标签类型和对应属性。(需要你实现。)\n    type IntrinsicElements = {};\n    // JSX.Element 接口(需要你实现。)\n    interface Element {}\n    // Children 类型接口，用于对闭合标签中children做类型检查。(需要你实现。)\n    interface ElementChildrenAttribute {}\n  }\n}\n```\n\n#### JSX.IntrinsicElements\n\nJSX 标签集合接口，类似 HTMLElementTagNameMap\n\n```typescript\ndeclare global {\n  namespace JSX {\n    type IntrinsicElements = {\n      view: { bindtap?: Function };\n      richText: { bindtap?: Function };\n      text: { bindtap?: Function };\n      label: { bindtap?: Function };\n      navigator: { bindtap?: Function };\n    };\n  }\n}\n```\n\n在 global::JSX::IntrinsicElements 中实现标签名和对应的属性，然后在.tsx 文件中的 JSX 标签就会有 view、richText 这些的类型提示，并且都提示有一个可选的 bindtap 属性。例如\n\n```typescript\nfunction App() {\n  return (\n    <view>\n      <text bindtap={() => console.log(\"click\")} />\n      <text />\n    </view>\n  );\n}\n```\n\n#### 类型 mapped type\n\n因为都有 bindtap 属性所以可以直接抽离出来，然后使用 mapped type，将 TagNameMap 集合中每个属性的值并入一个 Base 基类型得到一个新的集合类型 IntrinsicElements\n\n> 有点类似 Functor，将`& Base`运算应用到 TagNameMap 范畴中的每个值，然后得到新的范畴 IntrinsicElements\n\n```typescript\n// TagNameMap 范畴\ntype TagNameMap = {\n  view: {};\n  richText: {};\n  text: {};\n  label: {};\n  navigator: {};\n};\n\ntype Base = {\n  bindtap?: Function;\n};\n\ndeclare global {\n  namespace JSX {\n    // IntrinsicElements 范畴\n    type IntrinsicElements = {\n      [Tag in keyof TagNameMap]: TagNameMap[Tag] & Base\n    };\n  }\n}\n```\n\n### JSX.ElementChildrenAttribute\n\n它用来干什么，举个例子 8\n\n就在上面例子基础上扩展\n\n```typescript\ndeclare global {\n  namespace JSX {\n    type IntrinsicElements = {\n      [Tag in keyof TagNameMap]: TagNameMap[Tag] & Base\n    };\n    export interface Element extends Base {}\n    export interface ElementChildrenAttribute {\n      children: any; // JSX标签中子节点即children的类型\n    }\n  }\n}\n```\n\n写一个 Component，子节点是个 function，即 render props 方式渲染\n\n```typescript\nfunction Text({ children }: { children?: (value: number) => JSX.Element }) {\n  return <text>{children(233)}</text>;\n}\n\nfunction App() {\n  return (\n    <view>\n      <text bindtap={() => console.log(\"click\")} />\n      <Text>{value => <text>{value}</text>}</Text>\n    </view>\n  );\n}\n```\n\n<Text/>标签的子节点被约束为(value: number) => JSX.Element 类型，Text Component 内部传给它一个值执行返回 JSX.Element。\nReact 中 Context Customer 就是采用此种方式渲染。\n\n如果去掉 JSX.ElementChildrenAttribute 中 children 的声明，在 App 组件内调用 Text 组件时，Text 组件的子节点类型就会变成 any。所以它的作用就是用于约束 JSX Children 的类型\n\n## 关于 TSX 编译\n\n如果是 jsx 文件，需要给 babel 添加@babel/plugin-transform-react-jsx 插件，并配置 pragma(即 jsxFactory 函数)为你实现的 createElement 函数，例如默认的 React.createElement。\n\n但是现在是 tsx 文件，ts 编译到 js 可以在 tsconfig.json 中配置 compileOptions，可以指定到 target，即具体的 es 版本，和 module 模块规范等。\ntsx 需要配置两个选项：\n\n1. 一个必选的 jsx，如果指定为 react，tsc 会把 tsx 标签编译为 createElement 形式(脱糖编译)，如果指定为 preserve，则保留 jsx 部分不变(不脱糖编译)。如果要使用 Fragment 标签，则 jsx 必须指定为 react。\n\n2. 可选的 jsxFactory，默认为 React.createElement。\n"}]},{"path":"/blog/react/浏览器API","title":"浏览器API","children":[{"path":"/blog/react/浏览器API/requestIdleCallback方法.md","title":"requestIdleCallback方法","text":"## 简介\n\n这个 API 是 BOM API 之一，即 window.requestIdleCallback，由浏览器实现。在 Node.js 上没有此 API 的实现。\n\n它会在浏览器空闲时期调用注册的函数，即 JS 引擎的空闲时期。\n\n函数签名(由于还处于提案阶段，Typescript 并没有给出函数的声明，所以需要自己 declare 声明函数的签名)\n\n```typescript\ndeclare interface IdleDeadline {\n  readonly didTimeout: boolean;\n  timeRemaining(): number; // 时间片中剩余时间(0 <= timeRemained < 50)\n}\n\ndeclare type IdleOptions = {\n  timeout: number;\n};\n\ndeclare type IdleCallback = (deadline: IdleDeadline) => void;\n\ndeclare function requestIdleCallback(callback: IdleCallback): number;\n\ndeclare function requestIdleCallback(\n  callback: IdleCallback,\n  options: IdleOptions\n): number;\n```\n\n浏览器将时间以每 50ms 切成片，每个时间片内会执行 JS 线程。如果有空余时间，会执行 IdleCallback，并传入一个 deadline 对象，用于获取剩余空闲时间。\n\n## Fiber 相关\n\n此 API 对于 Fiber 调度算法的意义重大，通过判断算法复杂度和 timeRemained 的相对大小决定是否进行调度更新。\n\n在 Fiber 调度逻辑中，requestIdleCallback 用于迭代更新 workInProgress\n\n简化后的逻辑\n\n```typescript\nfunction workLoop(deadline: IdleDeadline) {\n  nextWorkInProgress = performUnitOfWork(nextWorkInProgress);\n\n  if (nextWorkInProgress) {\n    requestIdleCallback(workLoop);\n  }\n}\n\n// 开始调度循环\nrequestIdleCallback(workLoop);\n```\n"}]}]},{"path":"/blog/reflect","title":"reflect","children":[{"path":"/blog/reflect/reflect-metadata中HashMap巨大Object的读取速度优化.md","title":"reflect-metadata中HashMap巨大Object的读取速度优化","text":"HashMap 原理比较复杂，不是这篇文章重点。(其实是本菜鸡不懂(\n\nreflect-metadata 中实现了 HashMap 的 polyfill，需要能快速读取数据，而 js 的 Object 当属性很多的时候性能并不好，不然就不会有 Map 了。然而 reflect-metadata 中 HashMap 用的是 Dictionary，利用了一个非常 hack 的方法。\n\nHashMap\n\n```typescript\ntype HashMap<V> = Record<string, V>;\n\nconst HashMap = {\n  // create an obj into dictionary mode (a.k.a. \"slow\" mode on v8)\n  create: <V>() => MakeDictionary(Object.create(null) as HashMap<V>),\n\n  has: <V>(map: HashMap<V>, key: string | number | symbol) =>\n    Object.prototype.hasOwnProperty.call(map, key),\n\n  get: <V>(map: HashMap<V>, key: string | number | symbol): V | undefined =>\n    Object.prototype.hasOwnProperty.call(map, key)\n      ? map[key as string | number]\n      : undefined\n};\n```\n\n好像有点简单啊，除了有个 MakeDictionary 函数\n\n在 reflect-metadata 源码中最后有一个 MakeDictionary 函数，来看看这个神奇的函数\n\nMakeDictionary\n\n```typescript\n// uses a heuristic used by v8 and chakra to force an obj into dictionary mode.\nfunction MakeDictionary<T>(obj: T): T {\n  (<any>obj).__ = undefined;\n  delete (<any>obj).__;\n  return obj;\n}\n```\n\n它给 obj 添加了\\_\\_属性，值为 undefined，然后又删了，注释解释说这可以启发 v8 或者査克拉引擎将 Object 转换到 dictionary mode（？？），可以大幅提升 Object 属性读取的速度？\n\n下面来测试一下（Node 环境）\n\n先写一个 fill 函数，用来填充属性\n\n```typescript\nfunction fillSomething(obj: Object, size: number = 100000) {\n  while (size--) obj[size] = Math.random();\n}\n```\n\n测试一下读取速度\n\n```typescript\n// 普通obj\nconst obj = {};\n// 填充100000个随机属性\nfillSomething(obj);\n\nconsole.time(\"obj\");\nconsole.log(obj[\"5555\"]);\nconsole.timeEnd(\"obj\"); // obj 2.813ms\n\n// 创建一个hashMap\nconst hashMap = HashMap.create();\n// 填充100000个随机属性\nfillSomething(hashMap);\n\nconsole.time(\"hashMap\");\nconsole.log(HashMap.get(hashMap, \"5555\"));\nconsole.timeEnd(\"hashMap\"); // hashMap 0.398ms\n```\n\n足足快了 30 多倍？\n\n真假？。。其实把上面两个 time 顺序颠倒也不是这么回事，但出自 rbuckton 大神之手应该不是随便写的\n\n所以以后遇到巨大 Object 的时候不妨用此方法优化一下试试。\n"},{"path":"/blog/reflect/reflect-metadata实现及其原理.md","title":"reflect-metadata实现及其原理","text":"最近研究了一下 reflect 机理，基本算是实现了所有的 api，也通过了全部的测试用例，所以想写一篇文章记录下来。\n\nps: 这篇文章最先发在我的知呼上：https://zhuanlan.zhihu.com/p/65239993\n\nReflect Metadata 是 ES7 的一个提案，它主要用来在声明的时候添加和读取元数据。Typescript 使用反射需要安装一个依赖 reflect-metadata.\n\nTypescript 拥有完整的面向对象支持，依赖注入技术(DI)已经在 Angular、Nest 等框架中大规模使用了，就像这样\n\n```typescript\nclass Service {}\n\nclass Controller {\n  constructor(private Service: Service) {}\n}\n```\n\nIOC 框架会获取到 Controller 所依赖的类，并注入一个实例或类本身，这其中获取依赖类型就会利用到 Reflect。\n\n利用元数据设计键(Design-time type annotations)来获取依赖类型\n\n```typescript\nfunction Injectable(): ClassDecorator {\n  return target => {\n    const metadata = Reflect.getMetadata(\"design:paramtypes\", target);\n    console.log(metadata);\n  };\n}\n\nclass Service {\n  constructor() {}\n}\n\n@Injectable() // 输出 [ Service() ]\nclass Controller {\n  constructor(private Service: Service) {}\n}\n```\n\n这里需要利用装饰器来获取。这里也许你会有疑问，元数据需要先 defineMetadata 然后在 getMetadata 获取，这里为什么可以直接获取?\n\n答案就是如果 tsconfig 开启了 emitDecoratorMetadata 为 true，编译器会发出设计元数据信息。\n\n来看下 ts 编译后的 js (已开启 emitDecoratorMetadata)\n\n```typescript\n// 判断一下Reflect上是否有metadata函数，并赋给__metadata\nvar __metadata =\n  (this && this.__metadata) ||\n  function(k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\n      return Reflect.metadata(k, v);\n  };\n\nvar Service = /** @class */ (function() {\n  function Service() {}\n  return Service;\n})();\n\nvar Controller = /** @class */ (function() {\n  function Controller(Service) {\n    this.Service = Service;\n  }\n  Controller = __decorate(\n    [\n      Injectable(),\n      // 注意这里，使用design-paramtypes键定义了元数据，值是[Service]\n      __metadata(\"design:paramtypes\", [Service])\n    ],\n    Controller\n  );\n  return Controller;\n})();\n\nfunction Injectable() {\n  return function(target) {\n    Reflect.getMetadata(\"design:paramtypes\", target);\n  };\n}\n```\n\n开启了 emitDecoratorMetadata 编译器会自动生成 Design-time type annotations。\n\n通过前面的实例，容易发现，Reflect 内部应该会维护一个 Map，而且应该是 WeakMap，\n\n果不其然，在 reflect-metadata 这个库内部使用了 WeakMap，而且居然还自带了 Polyfill(不仅实现 WeakMap，还有 HashMap...)\n\n[[Metadata]] internal slot\n\nhttps://github.com/rbuckton/reflect-metadata/blob/master/Reflect.ts#L685\n\nnaive WeakMap shim\n\nhttps://github.com/rbuckton/reflect-metadata/blob/master/Reflect.ts#L1725\n\n下面开始实现。\n\n实现 Reflect.defineMetadata\n\n首先创建一个 WeakMap，它将负责维护所有类和类实例的元数据，以及解决自动回收问题。\n\n```typescript\nconst Metadata = new WeakMap<Object, Map<PropertyKey, MetadataMap>>();\n```\n\n这是一个高维的 Map，对于每个 Object 也就是类或者类实例，它都关联一个 Map。这个 Map 里又关联了属性 key 和属性所对应的 Map，所以又是一个高维的 Map。所以这个 Metadata 就是一个 3 维的 Map。\n\n```typescript\nexport function defineMetadata(\n  metadataKey: MetadataKey,\n  metadataValue: MetadataValue,\n  target: Object,\n  propertyKey: PropertyKey = DEFAULTKAY\n) {\n  // 判断target类型，因为target将作为WeakMap的键，必须是对象类型\n  if (typeof target !== \"object\" && typeof target !== \"function\") {\n    throw new TypeError();\n  }\n\n  // 如果传入propertyKey，要求类型为string或symbol\n  if (propertyKey && ![\"string\", \"symbol\"].includes(typeof propertyKey)) {\n    throw new TypeError();\n  }\n\n  // 从Metadata中获取target关联的Map，若没有就创建一个新的Map\n  const targetMetadata =\n    Metadata.get(target) || new Map<PropertyKey, MetadataMap>();\n\n  // 将targetMetadata再保存回Metadata中\n  Metadata.set(target, targetMetadata);\n\n  // 从targetMetadata中获取propertyKey关联的Map，若没有就创建一个新的Map\n  const metadataMap: MetadataMap = targetMetadata.get(propertyKey) || new Map();\n\n  // 将metadataMap再保存回targetMetadata中\n  targetMetadata.set(propertyKey, metadataMap);\n\n  // 设置元数据到metadataMap，键为metadataKey，值metadataValue\n  metadataMap.set(metadataKey, metadataValue);\n}\n```\n\n实现 Reflect.getMetadata\n\n这个 api 会依赖 getMetadataMap、getOwnMetadataMap。所以先倒着来实现\n\n1. getOwnMetadataMap\n\n```typescript\nexport function getOwnMetadataMap(\n  target: Object,\n  propertyKey: PropertyKey = DEFAULTKAY\n) {\n  // 判断target类型，因为target将作为WeakMap的键，必须是对象类型\n  if (typeof target !== \"object\" && typeof target !== \"function\") {\n    throw new TypeError();\n  }\n\n  // 从Metadata中获取target关联的Map，如果没有就返回undefined\n  const targetMetadata = Metadata.get(target);\n  if (!targetMetadata) return;\n\n  // 从targetMetadata中获取propertyKey关联的Map，如果没有就返回undefined\n  const metadataMap = targetMetadata.get(propertyKey);\n  if (!metadataMap) return;\n\n  // 返回metadataMap\n  return metadataMap;\n}\n```\n\n2. getMetadataMap\n\n获取 target 及其原型上的元数据 Map，对于同一个 propertyKey，自身的 metadataMap 覆盖原型的 metadataMap\n\n```typescript\nexport function getMetadataMap(\n  target: Object,\n  propertyKey: PropertyKey = DEFAULTKAY\n) {\n  // 如果自身有了propertyKey对应的map\n  if (Boolean(getOwnMetadataMap(target, propertyKey))) {\n    return getOwnMetadataMap(target, propertyKey);\n  }\n\n  // 去原型上找propertyKey对应的map，如果没有就返回undefined\n  const targetMetadata = Metadata.get(Object.getPrototypeOf(target));\n  if (!targetMetadata) return;\n\n  // 从targetMetadata中获取propertyKey关联的Map，如果没有就返回undefined\n  const metadataMap = targetMetadata.get(propertyKey);\n  if (!metadataMap) return;\n\n  // 返回metadataMap\n  return metadataMap;\n}\n```\n\n实现 getMetadata\n\n利用 getMetadataMap 拿到 target 关联的 metadataMap，然后根据 metadataKey 获取对应的 metadataValue\n\n```typescript\nexport function getMetadata<T>(\n  metadataKey: MetadataKey,\n  target: Object,\n  propertyKey?: PropertyKey\n): T {\n  // 根据propertyKey获取target的metadataMap，如果没有就返回undefined\n  const metadataMap = getMetadataMap(target, propertyKey);\n  if (!metadataMap) return;\n\n  // 返回metadataKey对应的metadataValue\n  return metadataMap.get(metadataKey);\n}\n```\n\n同样的还有 getOwnMetadata，只需要考虑 getOwnMetadataMap 就可以了\n\n实现 Reflect.getMetadataKeys\n\n用来获取 target 身上的所有元数据键\n\n它会依赖 getOwnMetadataKeys，所以先实现 getOwnMetadataKeys\n\n实现 getOwnMetadataKeys\n\n获取 target 自身的所有元数据键\n\n```typescript\nexport function getOwnMetadataKeys(\n  target: Object,\n  propertyKey?: PropertyKey\n): MetadataKey[] {\n  // 获取target身上与propertyKey关联的metadataMap，若没有返回空数组\n  const metadataMap = getOwnMetadataMap(target, propertyKey);\n  if (!metadataMap) return [];\n\n  // metadataMap转为数组并返回\n  return Array.from(metadataMap.keys());\n}\n```\n\n实现 getMetadataKeys\n\n获取自身的 metadataKeys，获取原型的 metadataKeys，合并后返回\n\n```typescript\nexport function getMetadataKeys(\n  target: Object,\n  propertyKey?: PropertyKey\n): MetadataKey[] {\n  // 获取target自身与propertyKey关联的metadataKeys\n  const ownKeys = getOwnMetadataKeys(target, propertyKey);\n\n  // 获取target原型与propertyKey关联的metadataKeys\n  const protoKeys = getOwnMetadataKeys(\n    Object.getPrototypeOf(target),\n    propertyKey\n  );\n\n  // 返回结果\n  return [...ownKeys, ...protoKeys];\n}\n```\n\n实现 Reflect.hasMetadata\n\n用来判断 target 上是否有对应的 metadataKey\n\n注意是判断有无 key，而不是有无 value，所以不能等价 Boolean(getMetadata)，因为 metadataValue 可以是 null 和 undefined 等值。测试用例对这里做了大量的 test。\n\n```typescript\nexport function hasMetadata(\n  metadataKey: MetadataKey,\n  target: Object,\n  propertyKey?: PropertyKey\n) {\n  const metadataKeys = getMetadataKeys(target, propertyKey);\n  return metadataKeys.includes(metadataKey);\n}\n```\n\n这个很简单，没什么好说的\n\n同样还有 hasOwnMetadata，利用 getOwnMetadataKeys 就 ok\n\n实现 Reflect.deleteMetadata\n\n```typescript\nexport function deleteMetadata(\n  metadataKey: MetadataKey,\n  target: Object,\n  propertyKey?: PropertyKey\n) {\n  const metadataMap = getOwnMetadataMap(target, propertyKey);\n  if (!metadataMap) return false;\n\n  return metadataMap.delete(metadataKey);\n}\n```\n\n实现 Reflect.decorate\n\n这个可以从测试用例上获取思路\n\n```typescript\n// reflect-decorate.test.ts\n\nit(\"DecoratorCorrectTargetInPipelineForFunctionOverload\", () => {\n  let sent: Function[] = [];\n  let A = function A(): void {};\n  let B = function B(): void {};\n  let decorators = [\n    (target: Function): any => {\n      sent.push(target);\n      return undefined;\n    },\n    (target: Function): any => {\n      sent.push(target);\n      return undefined;\n    },\n    (target: Function): any => {\n      sent.push(target);\n      return A;\n    },\n    (target: Function): any => {\n      sent.push(target);\n      return B;\n    }\n  ];\n  let target = function(): void {};\n  Reflect.decorate(decorators, target);\n  expect(sent).toEqual([target, B, A, A]);\n});\n```\n\n测试中给出的 decorators 是 4 个箭头函数的数组，把 target 参数 push 到 sent 里，然后返回一个结果\n\n要求是 Reflect.decorate 执行后，sent 是[target, B, A, A]\n\n再结合测试用例的 name 分析，看到了管道(Pipeline)，那应该会想到 reduce 而且是 reduceRight。\n\ntarget 就是 initialValue，decorators 就是 reducers。\n\ndecorate\n\n有点类型 redux 的样子，target 就是 state，decorators 就是 reducers\n\n```typescript\nexport function decorate(\n  decorators: (PropertyDecorator | MethodDecorator)[],\n  target: Object | Function,\n  propertyKey?: string | symbol,\n  attributes?: PropertyDescriptor\n): PropertyDescriptor {\n  // 如果decorators是空数组则抛出TypeError\n  if (0 === decorators.length) {\n    throw new TypeError();\n  }\n\n  // target作为initialValue，遍历decorators，将上一个decorator的结果作为target传给下一个decorator\n  return decorators.reduceRight(\n    (target, decorator) => decorator(target, propertyKey, attributes) || target,\n    <any>target\n  );\n}\n```\n\n确定 Reflect 的 type 以及混入原生 Reflect\n\n为了避免类型冲突，首先需要给原生 Reflect 的 type 起个别名，就叫 IReflect 吧\n\n```typescript\nexport type IReflect = typeof Reflect;\nexport const reflect = Reflect;\n```\n\n然后混入 Reflector\n\n```typescript\nexport const Reflect: typeof Reflector & IReflect = Object.assign(\n  reflect,\n  Reflector\n);\n```\n\n因为原生 Reflect 对象的属性不可枚举，所以只能往原生 reflect 合并\n\nps: 之前我写的 IOC 框架依赖的 reflect-metadata 也换成了现在实现的这个版本，demo 也能跑起来，感觉还不错。\n\nSaber2pr/saber-ioc\n\nhttps://github.com/Saber2pr/saber-ioc\n\nGithub\n\n@saber2pr/reflect\n\nhttps://github.com/Saber2pr/-saber2pr-reflect\n"},{"path":"/blog/reflect/依赖注入(IOC)实现.md","title":"依赖注入(IOC)实现","text":"## 实现 reflect-metadata\n\n1. 首先说明要干什么。\n   实现一个存放类的容器，并能按照类之间依赖关系自动构建实例。\n\n2. 核心原理：\n\n利用 Reflect-metadata 获取构造函数中的参数类型(design:paramtypes)。\n利用 Reflect-metadata 在目标对象上定义和获取元数据。\n\n先举个例子：\n\n```typescript\nclass Service {\n  constructor() {}\n}\n\nclass Controller {\n  constructor(private Service: Service) {}\n}\n```\n\n一个 Service 类，一个 Controller 类，其中 Controller 类依赖于 Service 类。\n\n利用 Reflect 可以轻松获取 Controller 类构造函数中的 paramtypes。\n\n## 实现@Injectable\n\n> Injectable 函数返回一个类装饰器，利用反射获取被装饰类的构造函数的参数类型。\n\n先举个栗子\n\n```typescript\nconst enum DESIGN {\n  PARAMTYPES = \"design:paramtypes\"\n}\n\nfunction Injectable(): ClassDecorator {\n  return target => {\n    // 获取被装饰类的构造函数的参数类型\n    const ctorParams: any[] = Reflect.getMetadata(DESIGN.PARAMTYPES, target);\n    console.log(ctorParams);\n  };\n}\n```\n\n利用设计键获取到参数列表：\n\n```typescript\nclass Service {\n  constructor() {}\n}\n\n@Injectable() // Array [ Service() ]\nclass Controller {\n  constructor(private Service: Service) {}\n}\n```\n\n## @Injectable\n\n```typescript\nexport function Injectable(id?: PropertyKey): ClassDecorator {\n  return target => {\n    // 索引键值默认为target.name\n    const token = id || target.name;\n\n    // 如果token已存在则抛出Error\n    if (Reflect.hasMetadata(token, MetaStore)) {\n      throw new Error(`id:[${String(token)}] is existed!`);\n    } else {\n      Reflect.defineMetadata(token, target, MetaStore);\n    }\n  };\n}\n```\n\n> Injectable 提供了可选项 id?，用来避免命名冲突。\n\n这样只要被 Injectable()装饰过的类都会被缓存到 MetaStore 中。\n\n## @Inject\n\n> 构造函数参数注入。读写 target 身上的元数据，用于注入依赖信息。\n\n```typescript\n// target身上的元数据类型(参数注入)\nexport type ParamMeta = Array<[PropertyKey, number]>;\n\nexport function Inject(id: PropertyKey): ParameterDecorator {\n  return (target, _, index) => {\n    // 获取到target身上的ParamMeta，如果没有就创建一个新的\n    const depMeta =\n      Reflect.getMetadata<ParamMeta>(CUSTOM.META_PARAM, target) || [];\n\n    // push一个ParamMeta，id和index\n    depMeta.push([id, index]);\n\n    // 再把ParamMeta保存回target\n    Reflect.defineMetadata(CUSTOM.META, depMeta, target);\n  };\n}\n```\n\n> index 即参数在函数(构造函数)arguments 数组中的下标，id 为 Injectable-token\n\n例如：\n\n```typescript\n@Injectable() // 缓存到MetaStore, id: 'Service'.\nclass Service {}\n\ninterface IService {}\n\nclass Controller {\n  // inject注解，请求依赖为id: 'Service', 位置为index: 0\n  constructor(@Inject(\"Service\") private Service: IService) {}\n}\n```\n\n## @InjectProp\n\n> 成员属性注入。读写 target 身上的元数据，用于注入依赖信息。\n\n```typescript\n// target身上的元数据类型(成员属性注入)\nexport type PropMeta = Array<[PropertyKey, PropertyKey]>;\n\nexport function InjectProp(id?: PropertyKey): PropertyDecorator {\n  return (target, key) => {\n    // 请求的依赖token，默认为成员属性名key\n    const token = id || key;\n\n    // 获取到target身上的PropMeta，如果没有就创建一个新的\n    const depMeta =\n      Reflect.getMetadata<PropMeta>(CUSTOM.META_PROP, target) || [];\n\n    // push一个PropMeta，id和index\n    depMeta.push([token, key]);\n\n    // 再把ParamMeta保存回target\n    Reflect.defineMetadata(CUSTOM.META_PROP, depMeta, target);\n  };\n}\n```\n\n例如：\n\n```typescript\n@Injectable() // 缓存到MetaStore, id: 'Service'.\nclass Service {}\n\ninterface IService {}\n\nclass Controller {\n  // inject注解，请求依赖为id: 'Service', 属性名为'Service'\n  @InjectProp() private Service: IService;\n}\n```\n\n## 实现 Injector 函数（核心）\n\n> 从入口开始构建整个依赖树，并生成根实例\n> 这里需要利用 AOP 思想，在 Target 生成实例前后做切面\n\n```typescript\ntype Constructor<T = any> = { new (...args: Array<any>): T };\n\nexport function Injector<T>(Target: Constructor<T>): T | Constructor<T> {\n  // 如果是静态类，直接返回\n  if (Reflect.hasMetadata(CUSTOM.STATIC, Target)) return Target;\n\n  // before 拿到ParamMeta实例数组\n  const instances = before(Target);\n\n  // 注入ParamMeta实例数组，生成Target实例\n  const target = new Target(...instances);\n\n  // after 进行PropMeta依赖注入\n  after(target);\n\n  return target;\n}\n```\n\n## before\n\n> 通过 Target 获取元数据信息(ParamMeta)，返回处理好的依赖项实例数组\n\n```typescript\nfunction before<T>(Target: Constructor<T>) {\n  // 获取设计元数据，也就是构造函数参数中的依赖项\n  const deps =\n    Reflect.getMetadata<Array<Constructor>>(DESIGN.PARAMTYPES, Target) || [];\n\n  // 获取Injected tags\n  const tags = Reflect.getMetadata<ParamMeta>(CUSTOM.META_PARAM, Target) || [];\n\n  // 遍历每一个tag\n  tags.forEach(([id, index]) => {\n    // 如果MetaStore中已注册\n    if (Reflect.hasMetadata(id, MetaStore)) {\n      // 找到MetaStore中id对应的metadata，按index插入deps\n      deps[index] = Reflect.getMetadata(id, MetaStore);\n    } else {\n      // 若没找到，则抛出异常\n      throw new Error(`injected dep:${String(id)} not found`);\n    }\n  });\n\n  // 对每一个ParamMeta依赖进行Injector依赖注入，得到实例数组并返回\n  return deps.map(Injector);\n}\n```\n\n## after\n\n> 通过 Target 实例获取元数据信息(PropMeta)，将处理好的依赖项定义到 Target 实例上\n\n```typescript\nfunction after<T>(target: T) {\n  // 获取PropMeta，也就是成员属性名关联的元数据\n  const props = Reflect.getMetadata<PropMeta>(CUSTOM.META_PROP, target) || [];\n\n  // 遍历每一个PropMeta元素\n  props.forEach(([id, key]) => {\n    // 如果MetaStore中已注册\n    if (Reflect.hasMetadata(id, MetaStore)) {\n      // 在MetaStore中找到对应metadata，也就是PropertyKey对应的依赖\n      const dep = Reflect.getMetadata<Constructor>(id, MetaStore);\n      // 对依赖进行依赖注入，得到依赖实例\n      const instance = Injector(dep);\n\n      // 将依赖实例作为属性定义到target上\n      Object.defineProperty(target, key, { value: instance });\n    } else {\n      // 若没找到，则抛出异常\n      throw new Error(`injected dep:${String(id)} not found`);\n    }\n  });\n}\n```\n\nDemo\n\n```typescript\n@Injectable()\nclass Service {\n  public getUser() {\n    return \"saber!\";\n  }\n}\n\nclass Controller {\n  public constructor(@Inject(\"Service\") private Service: Service) {}\n\n  // @InjectProp() private Service: Service\n\n  public test() {\n    console.log(this.Service.getUser());\n  }\n}\n\nconst app = Injector(Controller);\n\napp.test(); // 'saber!\n```\n"},{"path":"/blog/reflect/实现一个基于IOC的HttpServer框架","title":"实现一个基于IOC的HttpServer框架","children":[{"path":"/blog/reflect/实现一个基于IOC的HttpServer框架/实现一个基于IOC的HttpServer框架(上).md","title":"实现一个基于IOC的HttpServer框架(上)","text":"总体思路：\n\n1. Controller 用来组织元数据\n2. parse 方法将 Controller 中的 metadata 提取出来，得到 Controller-Metadata-Node\n3. transform 方法将 Controller-Metadata-Node 转为 requestListeners\n\n利用 Class 来组织元数据，利用装饰器和 Reflect 注入元数据信息\n\n```typescript\n@Controller(\"/user\") // 注入 baseUrl: '/user'\nclass UserController {\n  @Post(\"/register\") // 注入 POST: '/register'\n  public register() {}\n\n  @Get(\"/login\") // 注入 GET: '/login'\n  public login() {}\n}\n```\n\n> 现在利用 Reflect 来实现装饰器 Controller、Get、Post\n\n## 在此之前需要定义 constants\n\n> 因为 Reflect 需要 metadataKey 来索引 metadata\n\n```typescript\nexport namespace KEY {\n  export const enum Controller {\n    BaseUrl = \"controller:baseUrl\",\n    GET = \"method:get\",\n    POST = \"method:post\"\n  }\n}\n```\n\n## 实现装饰器部分\n\n### 1. @Controller\n\n> 用来注入 baseUrl 元数据\n\n```typescript\nexport function Controller(path?: string): ClassDecorator {\n  return target =>\n    Reflector.defineMetadata(KEY.Controller.BaseUrl, path, target);\n}\n```\n\n### + DecoratorFactory\n\n> @Post 和@Get 相似代码太多，抽离一个 Factory 方法\n> 输入 Method type 和路由 path，返回一个 MethodDecorator\n\n```typescript\nexport function DecoratorFactory(\n  type: KEY.Controller,\n  path: string\n): MethodDecorator {\n  return (target, key) => Reflector.defineMetadata(type, path, target, key);\n}\n```\n\n### 2. @Post、@Get\n\n> 用来注入 method 类型、路由 path、对应的响应方法名(propertyKey)\n\n```typescript\nexport function Get(path?: string): MethodDecorator {\n  return DecoratorFactory(KEY.Controller.GET, path);\n}\n\nexport function Post(path?: string): MethodDecorator {\n  return DecoratorFactory(KEY.Controller.POST, path);\n}\n```\n\n利用上述装饰器可以将 requestListener 需要的 path、method、callbackName 等信息定义在 Controller 上\n\n### parse\n\n> 解决如何提取出 Controller 中的 metadata 及其转化为 Controller-Metadata-Node\n\n首先明确，输入和输入的 type\n\n输入一个 Class，返回一个 Controller-Metadata-Node\n\n```typescript\n// 伪代码\nfunction parse(Controller: { new (): any }): Controller-Metadata-Node\n```\n\n定义 type\n\n```typescript\n// GET和POST还有别的method懒得写了\nexport type Method = \"GET\" | \"POST\";\n\n// 路由\nexport type Routes = Array<{\n  method: Method;\n  path: string;\n  callback: Function;\n}>;\n\n// Controller-Metadata-Node\nexport interface Controller {\n  baseUrl: string;\n  routes: Routes;\n}\n```\n\n实现 parse\n\n```typescript\n// parse函数实现\n// 输入一个Class类型，输出Controller-Metadata-Node\nexport function parse(Controller: { new (): any }): Controller {\n  // 提取baseUrl\n  const baseUrl = Reflector.getMetadata<string>(\n    KEY.Controller.BaseUrl,\n    Controller\n  );\n  // 实例化\n  const target = new Controller();\n  // 获取实例的所有方法callbackNames\n  const methods = Object.keys(Object.getPrototypeOf(target));\n\n  // 遍历所有callbackNames\n  // 匹配对应的method并输出\n  const routes = methods.reduce((receiver, key) => {\n    resolve(target, key, \"GET\", receiver);\n    resolve(target, key, \"POST\", receiver);\n    return receiver;\n  }, []);\n\n  // 返回Controller-Metadata-Node\n  return {\n    baseUrl,\n    routes\n  };\n}\n```\n\n说一下 resolve 函数做了什么\n\n### + resolve\n\n> reduce 的辅助函数，用于匹配 method 与 metadata\n\n```typescript\nexport function resolve(\n  target: Object,\n  key: string,\n  method: Method,\n  receiver: Routes\n) {\n  // 获取target.key上methodKey对应的metadata\n  const path = Reflector.getMetadata<string>(\n    mapMethodToKey(method),\n    target,\n    key\n  );\n  // 如果method对应的path存在，则往receiver中push一个route\n  if (path) receiver.push({ method, path, callback: target[pathToProp(path)] });\n}\n```\n\n这里需要实现两个 util 函数\n\n### + mapMethodToKey 、pathToProp\n\n> mapMethodToKey 用来进行 Pattern matching\n> pathToProp 用来处理 path 的前缀\n\n```typescript\nexport function mapMethodToKey(method: Method): KEY.Controller {\n  switch (method) {\n    case \"GET\":\n      return KEY.Controller.GET;\n    case \"POST\":\n      return KEY.Controller.POST;\n    default:\n      throw new TypeError();\n  }\n}\n\nexport function pathToProp(path: string) {\n  if (path.startsWith(\"/\")) {\n    return path.slice(1);\n  }\n  return path;\n}\n```\n\ntransform\n\n> 将 Controller-Metadata-Node 转为 requestListeners（Units）\n\n首先明确，输入和输入的 type\n\n输入一个 Controller-Metadata-Node 返回 Units\n\n```typescript\n// requestListener需要的信息\nexport interface Unit {\n  url: string;\n  callback: Function;\n  method: string;\n}\n\n// 实现transform\nexport function transform(controller: Controller): Unit[] {\n  return controller.routes.map<Unit>(({ path, callback, method }) => ({\n    url: controller.baseUrl + path,\n    callback,\n    method\n  }));\n}\n```\n\n> transform 这一步做的有点少，其实应该直接转为 requestListeners\n\n### + mapUnitToJob\n\n> 用来把 transform 得到的 units 转为 requestListeners\n\n这里用的是 Koa 所以：\n\n```typescript\n// 得到requestListeners序列\nexport function mapUnitToJob(units: Unit[]): Job<Context>[] {\n  return units.map<Job>(unit => async (ctx, next) => {\n    const { url, method } = ctx.request;\n    if (url === unit.url && method === unit.method) {\n      // 混入ctx\n      await unit.callback.apply(\n        Object.assign(unit.origin, { ContextService: ctx })\n      );\n    } else {\n      await next();\n    }\n  });\n}\n```\n\n利用 Koa-compose 就可以组合 requestListeners 序列\n\n### + ContextService\n\n```typescript\n@Injectable()\nexport class ContextService {\n  public request: Context[\"request\"];\n  public response: Context[\"response\"];\n}\n```\n\n只要注入 ContextService 就可以获取 koa-context 信息\n\n例如\n\n```typescript\n@Controller(\"/user\")\nclass UserController {\n  constructor(private ContextService: ContextService) {}\n\n  @Get(\"/login\")\n  public login() {\n    this.ContextService.response.end(\"login\");\n  }\n\n  @Get(\"/hello\")\n  public hello() {\n    this.ContextService.response.end(\"hello\");\n  }\n}\n```\n\n现在有了定义 metadata 的 decorators、parser 和 transformer\n\n最后需要的就是一个 Factory 类，将这几个过程有序组织起来\n\n### Factory\n\n```typescript\nexport class Factory {\n  public constructor(private modules: Array<{ new (): any }>) {\n    // 将classes转为units\n    this.units = [].concat(...this.modules.map(mod => transform(parse(mod))));\n  }\n  public instance: KoaBody;\n  private units: Unit[];\n  public create() {\n    // 将units转为requestListeners，实例化一个koa-app，koa.use...\n    this.instance = Koa().use(compose(...mapUnitToJob(this.units)));\n    // 返回koa实例\n    return this.instance;\n  }\n}\n```\n\ndemo\n\n```typescript\n@Controller(\"/user\")\nclass UserController {\n  constructor(private ContextService: ContextService) {}\n\n  @Get(\"/login\")\n  public login() {\n    this.ContextService.response.end(\"login\");\n  }\n\n  @Get(\"/hello\")\n  public hello() {\n    this.ContextService.response.end(\"hello\");\n  }\n}\n\nnew Factory([UserController])\n  .create()\n  .listen(3001, () => console.log(\"http://localhost:3001\"));\n```\n\n> 现在只是实现了从 Controllers 到 requestListeners，关于 Service 注入在下一篇文章分享。\n"},{"path":"/blog/reflect/实现一个基于IOC的HttpServer框架/实现一个基于IOC的HttpServer框架(下).md","title":"实现一个基于IOC的HttpServer框架(下)","text":"上一篇文章实现了从 Controllers 到 requestListeners 的转化，下面需要解决的问题是当 Controller 使用了 IOC 容器来注入 Service 时怎么 parse 以及思路。\n\n以每个 Controller 为一个根节点构建它的实例，parser 从实例中解析出 baseUrl 和 routes\n\n之前我写的 IOC 容器被我重构了 qwq，API 现在是 Inject、Injectable、Injector.\n\n> 1. Inject 负责添加依赖信息\n> 2. Injectable 用来注册和缓存 constructors\n> 3. Injector 用来构建根实例\n\n所以需要在 parse 方法中使用 Injector 对 Controller 进行依赖注入\n\n```typescript\nexport function parse(Controller: { new (): any }): Controller {\n  const baseUrl = Reflector.getMetadata<string>(\n    KEY.Controller.BaseUrl,\n    Controller\n  );\n\n  // Injector将Controller需要的依赖注入其中，返回它的一个实例\n  const target = Injector(Controller);\n  const methods = Object.keys(Object.getPrototypeOf(target));\n\n  const routes = methods.reduce((receiver, key) => {\n    resolve(target, key, \"GET\", receiver);\n    resolve(target, key, \"POST\", receiver);\n    resolve(target, key, \"DELETE\", receiver);\n    resolve(target, key, \"PUT\", receiver);\n    return receiver;\n  }, []);\n\n  return {\n    baseUrl,\n    routes\n  };\n}\n```\n\n> emmm，这就搞定了。原来是 new Controller，现在是 Injector(Controller)\n\nDemo\n\n```typescript\n@Injectable()\nclass UserService {\n  public getUserName() {\n    return \"saber2pr!\";\n  }\n\n  public getHello() {\n    return \"Hello!\";\n  }\n}\n\n@Controller(\"/user\")\nclass UserController {\n  constructor(\n    private ContextService: ContextService,\n    @Inject(\"UserService\") private UserService: UserService\n  ) {}\n\n  @Get(\"/login\")\n  public login() {\n    this.ContextService.response.end(this.UserService.getUserName());\n  }\n\n  @Get(\"/hello\")\n  public hello() {\n    this.ContextService.response.end(this.UserService.getHello());\n  }\n}\n\nnew Factory([UserController])\n  .create()\n  .listen(3001, () => console.log(\"http://localhost:3001\"));\n// http://localhost:3001/user/login\n// http://localhost:3001/user/hello\n```\n\n> 关于 saber-ioc 现在已重构为@saber2pr/ioc\n> 之前写的文章也做了更新，主要是简化了大部分代码\n\n(最后瞎扯一句) 关于 OOP 的依赖注入和函数式的 compose 一直是个争论的问题，到底哪种方式更好谁也说不清(\n"}]}]},{"path":"/blog/saber2prの窝.md","title":"saber2prの窝","text":"你说既视感？\n\n错觉！\n\n为什么会有这个 Page？\n\n大概我想记录自己的心得但穷于购买 server service。\n\n为什么要搞一些闪瞎眼的 Animation？？\n\n如果没有过渡你可能想马上关掉这个呆掉的 Page。\n\n这个 page 上面大概有些什么值得我看的东西？\n\n如果你对二刺猿感兴趣我建议你点击`链接`->`bilibili`离开这里。\n"}]}