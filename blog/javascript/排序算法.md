### 冒泡排序 O(N^2)

> 它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从 A 到 Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。

```ts
export const sortB = (args: number[]) => {
  for (let i = 0; i < args.length; i++) {
    // 关键点，j < args.length - (1 + i)
    // 每一轮比较完毕，最后一个元素肯定是最大值，所以做后一个可以不比较，即每循环一次，比较次数减一
    for (let j = 0; j < args.length - (1 + i); j++) {
      // 每一趟都是比较相邻两个数
      if (args[j] > args[j + 1]) {
        const temp = args[j]
        args[j] = args[j + 1]
        args[j + 1] = temp
      }
    }
  }
  return args
}
```

### 快速排序 O(nlogn)

> 通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

```ts
export function sortQuick(arr: number[]): number[] {
  // 终止条件，被拆分为一个元素
  if (arr.length <= 1) return arr

  // 找到中间元素索引
  const index = Math.floor(arr.length / 2)
  // 中间元素值
  const stand = arr[index]
  // 去掉中间元素
  arr.splice(index, 1)

  const left = []
  const right = []
  // 以中间元素为基准，小的值放在左边，大的放右边
  arr.forEach(v => (v < stand ? left.push(v) : right.push(v)))

  // 连接好left、中间元素和right，递归
  // 注意此处为二分法，left会不断拆分成左中右
  return sortQuick(left).concat(stand, sortQuick(right))
}
```

### 选择排序 O(N^2)

> 从头至尾扫描序列，找出最小的一个元素，和第一个元素交换，接着从剩下的元素中继续这种选择和交换方式，最终得到一个有序序列。

```ts
export function sortSelect(arr: number[]) {
  const len = arr.length
  for (let i = 0; i < len; i++) {
    let index = i
    for (let j = i + 1; j < len; j++) {
      // 每一轮比较选出最小值索引
      if (arr[j] < arr[i]) {
        index = j
      }
    }
    const temp = arr[i]
    arr[i] = arr[index]
    arr[index] = temp
  }
  return arr
}
```
